diff -upr /home/finger/rtlwifi_new1/debug.c drivers/net/wireless/realtek/rtw88/debug.c
--- /home/finger/rtlwifi_new1/debug.c	2019-06-14 10:13:19.898404584 -0500
+++ drivers/net/wireless/realtek/rtw88/debug.c	2019-05-29 10:30:34.152337248 -0500
@@ -1,1999 +1,316 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *****************************************************************************/
-
-#include "wifi.h"
-#include "cam.h"
-
-#include <linux/moduleparam.h>
-#include <linux/vmalloc.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-#include <linux/export.h>
-#endif
-
-#ifdef CONFIG_RTLWIFI_DEBUG
-void _rtl_dbg_trace(struct rtl_priv *rtlpriv, u64 comp, int level,
-		    const char *fmt, ...)
-{
-	if (unlikely((comp & rtlpriv->cfg->mod_params->debug_mask) &&
-		     level <= rtlpriv->cfg->mod_params->debug_level)) {
-		struct va_format vaf;
-		va_list args;
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/* Copyright(c) 2018-2019  Realtek Corporation
+ */
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include "main.h"
+#include "sec.h"
+#include "fw.h"
+#include "debug.h"
+#include "phy.h"
 
-		va_start(args, fmt);
+#ifdef CONFIG_RTW88_DEBUGFS
 
-		vaf.fmt = fmt;
-		vaf.va = &args;
-
-		pr_info(":<%lx> %pV", in_interrupt(), &vaf);
-
-		va_end(args);
-	}
-}
-EXPORT_SYMBOL_GPL(_rtl_dbg_trace);
-
-void _rtl_dbg_print(struct rtl_priv *rtlpriv, u64 comp, int level,
-		    const char *fmt, ...)
-{
-	if (unlikely((comp & rtlpriv->cfg->mod_params->debug_mask) &&
-		     level <= rtlpriv->cfg->mod_params->debug_level)) {
-		struct va_format vaf;
-		va_list args;
-
-		va_start(args, fmt);
-
-		vaf.fmt = fmt;
-		vaf.va = &args;
-
-		pr_info("%pV", &vaf);
-
-		va_end(args);
-	}
-}
-EXPORT_SYMBOL_GPL(_rtl_dbg_print);
-
-void _rtl_dbg_print_data(struct rtl_priv *rtlpriv, u64 comp, int level,
-			 const char *titlestring,
-			 const void *hexdata, int hexdatalen)
-{
-	if (unlikely(((comp) & rtlpriv->cfg->mod_params->debug_mask) &&
-		     ((level) <= rtlpriv->cfg->mod_params->debug_level))) {
-		pr_info("In process \"%s\" (pid %i): %s\n",
-			current->comm, current->pid, titlestring);
-		print_hex_dump_bytes("", DUMP_PREFIX_NONE,
-				     hexdata, hexdatalen);
-	}
-}
-EXPORT_SYMBOL_GPL(_rtl_dbg_print_data);
-
-struct rtl_debugfs_priv {
-	struct rtl_priv *rtlpriv;
+struct rtw_debugfs_priv {
+	struct rtw_dev *rtwdev;
 	int (*cb_read)(struct seq_file *m, void *v);
 	ssize_t (*cb_write)(struct file *filp, const char __user *buffer,
 			    size_t count, loff_t *loff);
-	u32 cb_data;
+	union {
+		u32 cb_data;
+		u8 *buf;
+		struct {
+			u32 page_offset;
+			u32 page_num;
+		} rsvd_page;
+		struct {
+			u8 rf_path;
+			u32 rf_addr;
+			u32 rf_mask;
+		};
+		struct {
+			u32 addr;
+			u32 len;
+		} read_reg;
+	};
 };
 
-static struct dentry *debugfs_topdir;
-
-static int rtl_debug_get_common(struct seq_file *m, void *v)
+static int rtw_debugfs_single_show(struct seq_file *m, void *v)
 {
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
+	struct rtw_debugfs_priv *debugfs_priv = m->private;
 
 	return debugfs_priv->cb_read(m, v);
 }
 
-static int dl_debug_open_common(struct inode *inode, struct file *file)
-{
-	return single_open(file, rtl_debug_get_common, inode->i_private);
-}
-
-static const struct file_operations file_ops_common = {
-	.open = dl_debug_open_common,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = seq_release,
-};
-
-static int rtl_debug_get_mac_page(struct seq_file *m, void *v)
+static ssize_t rtw_debugfs_common_write(struct file *filp,
+					const char __user *buffer,
+					size_t count, loff_t *loff)
 {
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-	u32 page = debugfs_priv->cb_data;
-	int i, n;
-	int max = 0xff;
-
-	for (n = 0; n <= max; ) {
-		seq_printf(m, "\n%8.8x  ", n + page);
-		for (i = 0; i < 4 && n <= max; i++, n += 4)
-			seq_printf(m, "%8.8x    ",
-				   rtl_read_dword(rtlpriv, (page | n)));
-	}
-	seq_puts(m, "\n");
-	return 0;
-}
-
-#define RTL_DEBUG_IMPL_MAC_SERIES(page, addr)			\
-static struct rtl_debugfs_priv rtl_debug_priv_mac_ ##page = {	\
-	.cb_read = rtl_debug_get_mac_page,			\
-	.cb_data = addr,					\
-}
+	struct rtw_debugfs_priv *debugfs_priv = filp->private_data;
 
-RTL_DEBUG_IMPL_MAC_SERIES(0, 0x0000);
-RTL_DEBUG_IMPL_MAC_SERIES(1, 0x0100);
-RTL_DEBUG_IMPL_MAC_SERIES(2, 0x0200);
-RTL_DEBUG_IMPL_MAC_SERIES(3, 0x0300);
-RTL_DEBUG_IMPL_MAC_SERIES(4, 0x0400);
-RTL_DEBUG_IMPL_MAC_SERIES(5, 0x0500);
-RTL_DEBUG_IMPL_MAC_SERIES(6, 0x0600);
-RTL_DEBUG_IMPL_MAC_SERIES(7, 0x0700);
-RTL_DEBUG_IMPL_MAC_SERIES(10, 0x1000);
-RTL_DEBUG_IMPL_MAC_SERIES(11, 0x1100);
-RTL_DEBUG_IMPL_MAC_SERIES(12, 0x1200);
-RTL_DEBUG_IMPL_MAC_SERIES(13, 0x1300);
-RTL_DEBUG_IMPL_MAC_SERIES(14, 0x1400);
-RTL_DEBUG_IMPL_MAC_SERIES(15, 0x1500);
-RTL_DEBUG_IMPL_MAC_SERIES(16, 0x1600);
-RTL_DEBUG_IMPL_MAC_SERIES(17, 0x1700);
-
-static int rtl_debug_get_bb_page(struct seq_file *m, void *v)
-{
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-	struct ieee80211_hw *hw = rtlpriv->hw;
-	u32 page = debugfs_priv->cb_data;
-	int i, n;
-	int max = 0xff;
-
-	for (n = 0; n <= max; ) {
-		seq_printf(m, "\n%8.8x  ", n + page);
-		for (i = 0; i < 4 && n <= max; i++, n += 4)
-			seq_printf(m, "%8.8x    ",
-				   rtl_get_bbreg(hw, (page | n), 0xffffffff));
-	}
-	seq_puts(m, "\n");
-	return 0;
-}
-
-#define RTL_DEBUG_IMPL_BB_SERIES(page, addr)			\
-static struct rtl_debugfs_priv rtl_debug_priv_bb_ ##page = {	\
-	.cb_read = rtl_debug_get_bb_page,			\
-	.cb_data = addr,					\
+	return debugfs_priv->cb_write(filp, buffer, count, loff);
 }
 
-RTL_DEBUG_IMPL_BB_SERIES(8, 0x0800);
-RTL_DEBUG_IMPL_BB_SERIES(9, 0x0900);
-RTL_DEBUG_IMPL_BB_SERIES(a, 0x0a00);
-RTL_DEBUG_IMPL_BB_SERIES(b, 0x0b00);
-RTL_DEBUG_IMPL_BB_SERIES(c, 0x0c00);
-RTL_DEBUG_IMPL_BB_SERIES(d, 0x0d00);
-RTL_DEBUG_IMPL_BB_SERIES(e, 0x0e00);
-RTL_DEBUG_IMPL_BB_SERIES(f, 0x0f00);
-RTL_DEBUG_IMPL_BB_SERIES(18, 0x1800);
-RTL_DEBUG_IMPL_BB_SERIES(19, 0x1900);
-RTL_DEBUG_IMPL_BB_SERIES(1a, 0x1a00);
-RTL_DEBUG_IMPL_BB_SERIES(1b, 0x1b00);
-RTL_DEBUG_IMPL_BB_SERIES(1c, 0x1c00);
-RTL_DEBUG_IMPL_BB_SERIES(1d, 0x1d00);
-RTL_DEBUG_IMPL_BB_SERIES(1e, 0x1e00);
-RTL_DEBUG_IMPL_BB_SERIES(1f, 0x1f00);
-
-static int rtl_debug_get_reg_rf(struct seq_file *m, void *v)
-{
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-	struct ieee80211_hw *hw = rtlpriv->hw;
-	enum radio_path rfpath = debugfs_priv->cb_data;
-	int i, n;
-	int max = 0x40;
-
-	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
-		max = 0xff;
-
-	seq_printf(m, "\nPATH(%d)", rfpath);
+static ssize_t rtw_debugfs_single_write(struct file *filp,
+					const char __user *buffer,
+					size_t count, loff_t *loff)
+{
+	struct seq_file *seqpriv = (struct seq_file *)filp->private_data;
+	struct rtw_debugfs_priv *debugfs_priv = seqpriv->private;
 
-	for (n = 0; n <= max; ) {
-		seq_printf(m, "\n%8.8x  ", n);
-		for (i = 0; i < 4 && n <= max; n += 1, i++)
-			seq_printf(m, "%8.8x    ",
-				   rtl_get_rfreg(hw, rfpath, n, 0xffffffff));
-	}
-	seq_puts(m, "\n");
-	return 0;
+	return debugfs_priv->cb_write(filp, buffer, count, loff);
 }
 
-#define RTL_DEBUG_IMPL_RF_SERIES(page, addr)			\
-static struct rtl_debugfs_priv rtl_debug_priv_rf_ ##page = {	\
-	.cb_read = rtl_debug_get_reg_rf,			\
-	.cb_data = addr,					\
+static int rtw_debugfs_single_open_rw(struct inode *inode, struct file *filp)
+{
+	return single_open(filp, rtw_debugfs_single_show, inode->i_private);
 }
 
-RTL_DEBUG_IMPL_RF_SERIES(a, RF90_PATH_A);
-RTL_DEBUG_IMPL_RF_SERIES(b, RF90_PATH_B);
-
-static int rtl_debug_get_cam_register(struct seq_file *m, void *v)
+static int rtw_debugfs_close(struct inode *inode, struct file *filp)
 {
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-	int start = debugfs_priv->cb_data;
-	u32 target_cmd = 0;
-	u32 target_val = 0;
-	u8 entry_i = 0;
-	u32 ulstatus;
-	int i = 100, j = 0;
-	int end = (start + 11 > TOTAL_CAM_ENTRY ? TOTAL_CAM_ENTRY : start + 11);
-
-	/* This dump the current register page */
-	seq_printf(m,
-		   "\n#################### SECURITY CAM (%d-%d) ##################\n",
-		   start, end - 1);
-
-	for (j = start; j < end; j++) {
-		seq_printf(m, "\nD:  %2x > ", j);
-		for (entry_i = 0; entry_i < CAM_CONTENT_COUNT; entry_i++) {
-			/* polling bit, and No Write enable, and address  */
-			target_cmd = entry_i + CAM_CONTENT_COUNT * j;
-			target_cmd = target_cmd | BIT(31);
-
-			/* Check polling bit is clear */
-			while ((i--) >= 0) {
-				ulstatus = rtl_read_dword(
-						rtlpriv,
-						rtlpriv->cfg->maps[RWCAM]);
-				if (ulstatus & BIT(31))
-					continue;
-				else
-					break;
-			}
-
-			rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],
-					target_cmd);
-			target_val = rtl_read_dword(rtlpriv,
-						    rtlpriv->cfg->maps[RCAMO]);
-			seq_printf(m, "%8.8x ", target_val);
-		}
-	}
-	seq_puts(m, "\n");
 	return 0;
 }
 
-#define RTL_DEBUG_IMPL_CAM_SERIES(page, addr)			\
-static struct rtl_debugfs_priv rtl_debug_priv_cam_ ##page = {	\
-	.cb_read = rtl_debug_get_cam_register,			\
-	.cb_data = addr,					\
-}
-
-RTL_DEBUG_IMPL_CAM_SERIES(1, 0);
-RTL_DEBUG_IMPL_CAM_SERIES(2, 11);
-RTL_DEBUG_IMPL_CAM_SERIES(3, 22);
-
-static const char * const table_txpwr_lmt[] = {
-	"FCC", "2.4G", "20M", "CCK", "1T", "01", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "01", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "02", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "02", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "03", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "03", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "04", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "04", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "05", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "05", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "06", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "06", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "07", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "07", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "08", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "08", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "09", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "09", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "10", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "10", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "11", "32",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "11", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "12", "26",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "12", "30",
-	"FCC", "2.4G", "20M", "CCK", "1T", "13", "20",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "28",
-	"MKK", "2.4G", "20M", "CCK", "1T", "13", "28",
-	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
-	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
-	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "26",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "30",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "32",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "34",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "34",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "34",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "34",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "34",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "32",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "30",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "28",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "22",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "14",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "30",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "34",
-	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
-	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
-	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
-	"FCC", "2.4G", "20M", "HT", "1T", "01", "26",
-	"ETSI", "2.4G", "20M", "HT", "1T", "01", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "01", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "02", "30",
-	"ETSI", "2.4G", "20M", "HT", "1T", "02", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "02", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "03", "32",
-	"ETSI", "2.4G", "20M", "HT", "1T", "03", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "03", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "04", "34",
-	"ETSI", "2.4G", "20M", "HT", "1T", "04", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "04", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "05", "34",
-	"ETSI", "2.4G", "20M", "HT", "1T", "05", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "05", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "06", "34",
-	"ETSI", "2.4G", "20M", "HT", "1T", "06", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "06", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "07", "34",
-	"ETSI", "2.4G", "20M", "HT", "1T", "07", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "07", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "08", "34",
-	"ETSI", "2.4G", "20M", "HT", "1T", "08", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "08", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "09", "32",
-	"ETSI", "2.4G", "20M", "HT", "1T", "09", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "09", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "10", "30",
-	"ETSI", "2.4G", "20M", "HT", "1T", "10", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "10", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "11", "26",
-	"ETSI", "2.4G", "20M", "HT", "1T", "11", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "11", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "12", "20",
-	"ETSI", "2.4G", "20M", "HT", "1T", "12", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "12", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "13", "14",
-	"ETSI", "2.4G", "20M", "HT", "1T", "13", "30",
-	"MKK", "2.4G", "20M", "HT", "1T", "13", "34",
-	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
-	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
-	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
-	"FCC", "2.4G", "20M", "HT", "2T", "01", "26",
-	"ETSI", "2.4G", "20M", "HT", "2T", "01", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "01", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "02", "28",
-	"ETSI", "2.4G", "20M", "HT", "2T", "02", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "02", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "03", "30",
-	"ETSI", "2.4G", "20M", "HT", "2T", "03", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "03", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "04", "30",
-	"ETSI", "2.4G", "20M", "HT", "2T", "04", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "04", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "05", "32",
-	"ETSI", "2.4G", "20M", "HT", "2T", "05", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "05", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "06", "32",
-	"ETSI", "2.4G", "20M", "HT", "2T", "06", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "06", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "07", "32",
-	"ETSI", "2.4G", "20M", "HT", "2T", "07", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "07", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "08", "30",
-	"ETSI", "2.4G", "20M", "HT", "2T", "08", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "08", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "09", "30",
-	"ETSI", "2.4G", "20M", "HT", "2T", "09", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "09", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "10", "28",
-	"ETSI", "2.4G", "20M", "HT", "2T", "10", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "10", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "11", "26",
-	"ETSI", "2.4G", "20M", "HT", "2T", "11", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "11", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "12", "20",
-	"ETSI", "2.4G", "20M", "HT", "2T", "12", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "12", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "13", "14",
-	"ETSI", "2.4G", "20M", "HT", "2T", "13", "18",
-	"MKK", "2.4G", "20M", "HT", "2T", "13", "30",
-	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
-	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
-	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
-	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
-	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
-	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
-	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
-	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
-	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
-	"FCC", "2.4G", "40M", "HT", "1T", "03", "26",
-	"ETSI", "2.4G", "40M", "HT", "1T", "03", "30",
-	"MKK", "2.4G", "40M", "HT", "1T", "03", "34",
-	"FCC", "2.4G", "40M", "HT", "1T", "04", "26",
-	"ETSI", "2.4G", "40M", "HT", "1T", "04", "30",
-	"MKK", "2.4G", "40M", "HT", "1T", "04", "34",
-	"FCC", "2.4G", "40M", "HT", "1T", "05", "30",
-	"ETSI", "2.4G", "40M", "HT", "1T", "05", "30",
-	"MKK", "2.4G", "40M", "HT", "1T", "05", "34",
-	"FCC", "2.4G", "40M", "HT", "1T", "06", "32",
-	"ETSI", "2.4G", "40M", "HT", "1T", "06", "30",
-	"MKK", "2.4G", "40M", "HT", "1T", "06", "34",
-	"FCC", "2.4G", "40M", "HT", "1T", "07", "30",
-	"ETSI", "2.4G", "40M", "HT", "1T", "07", "30",
-	"MKK", "2.4G", "40M", "HT", "1T", "07", "34",
-	"FCC", "2.4G", "40M", "HT", "1T", "08", "26",
-	"ETSI", "2.4G", "40M", "HT", "1T", "08", "30",
-	"MKK", "2.4G", "40M", "HT", "1T", "08", "34",
-	"FCC", "2.4G", "40M", "HT", "1T", "09", "26",
-	"ETSI", "2.4G", "40M", "HT", "1T", "09", "30",
-	"MKK", "2.4G", "40M", "HT", "1T", "09", "34",
-	"FCC", "2.4G", "40M", "HT", "1T", "10", "20",
-	"ETSI", "2.4G", "40M", "HT", "1T", "10", "30",
-	"MKK", "2.4G", "40M", "HT", "1T", "10", "34",
-	"FCC", "2.4G", "40M", "HT", "1T", "11", "14",
-	"ETSI", "2.4G", "40M", "HT", "1T", "11", "30",
-	"MKK", "2.4G", "40M", "HT", "1T", "11", "34",
-	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
-	"ETSI", "2.4G", "40M", "HT", "1T", "12", "63",
-	"MKK", "2.4G", "40M", "HT", "1T", "12", "63",
-	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
-	"ETSI", "2.4G", "40M", "HT", "1T", "13", "63",
-	"MKK", "2.4G", "40M", "HT", "1T", "13", "63",
-	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
-	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
-	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
-	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
-	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
-	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
-	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
-	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
-	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
-	"FCC", "2.4G", "40M", "HT", "2T", "03", "24",
-	"ETSI", "2.4G", "40M", "HT", "2T", "03", "18",
-	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
-	"FCC", "2.4G", "40M", "HT", "2T", "04", "24",
-	"ETSI", "2.4G", "40M", "HT", "2T", "04", "18",
-	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
-	"FCC", "2.4G", "40M", "HT", "2T", "05", "26",
-	"ETSI", "2.4G", "40M", "HT", "2T", "05", "18",
-	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
-	"FCC", "2.4G", "40M", "HT", "2T", "06", "28",
-	"ETSI", "2.4G", "40M", "HT", "2T", "06", "18",
-	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
-	"FCC", "2.4G", "40M", "HT", "2T", "07", "26",
-	"ETSI", "2.4G", "40M", "HT", "2T", "07", "18",
-	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
-	"FCC", "2.4G", "40M", "HT", "2T", "08", "26",
-	"ETSI", "2.4G", "40M", "HT", "2T", "08", "18",
-	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
-	"FCC", "2.4G", "40M", "HT", "2T", "09", "26",
-	"ETSI", "2.4G", "40M", "HT", "2T", "09", "18",
-	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
-	"FCC", "2.4G", "40M", "HT", "2T", "10", "20",
-	"ETSI", "2.4G", "40M", "HT", "2T", "10", "18",
-	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
-	"FCC", "2.4G", "40M", "HT", "2T", "11", "14",
-	"ETSI", "2.4G", "40M", "HT", "2T", "11", "18",
-	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
-	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
-	"ETSI", "2.4G", "40M", "HT", "2T", "12", "63",
-	"MKK", "2.4G", "40M", "HT", "2T", "12", "63",
-	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
-	"ETSI", "2.4G", "40M", "HT", "2T", "13", "63",
-	"MKK", "2.4G", "40M", "HT", "2T", "13", "63",
-	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
-	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
-	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
-	"FCC", "5G", "20M", "OFDM", "1T", "36", "30",
-	"ETSI", "5G", "20M", "OFDM", "1T", "36", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "36", "30",
-	"FCC", "5G", "20M", "OFDM", "1T", "40", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "40", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "40", "30",
-	"FCC", "5G", "20M", "OFDM", "1T", "44", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "44", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "44", "30",
-	"FCC", "5G", "20M", "OFDM", "1T", "48", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "48", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "48", "30",
-	"FCC", "5G", "20M", "OFDM", "1T", "52", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "52", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "52", "28",
-	"FCC", "5G", "20M", "OFDM", "1T", "56", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "56", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "56", "28",
-	"FCC", "5G", "20M", "OFDM", "1T", "60", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "60", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "60", "28",
-	"FCC", "5G", "20M", "OFDM", "1T", "64", "28",
-	"ETSI", "5G", "20M", "OFDM", "1T", "64", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "64", "28",
-	"FCC", "5G", "20M", "OFDM", "1T", "100", "26",
-	"ETSI", "5G", "20M", "OFDM", "1T", "100", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "100", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "104", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "104", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "104", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "108", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "108", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "108", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "112", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "112", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "112", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "116", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "116", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "116", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "120", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "120", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "120", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "124", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "124", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "124", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "128", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "128", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "128", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "132", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "132", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "132", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "136", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "136", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "136", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "140", "28",
-	"ETSI", "5G", "20M", "OFDM", "1T", "140", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "140", "32",
-	"FCC", "5G", "20M", "OFDM", "1T", "144", "28",
-	"ETSI", "5G", "20M", "OFDM", "1T", "144", "32",
-	"MKK", "5G", "20M", "OFDM", "1T", "144", "63",
-	"FCC", "5G", "20M", "OFDM", "1T", "149", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "149", "63",
-	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
-	"FCC", "5G", "20M", "OFDM", "1T", "153", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "153", "63",
-	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
-	"FCC", "5G", "20M", "OFDM", "1T", "157", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "157", "63",
-	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
-	"FCC", "5G", "20M", "OFDM", "1T", "161", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "161", "63",
-	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
-	"FCC", "5G", "20M", "OFDM", "1T", "165", "32",
-	"ETSI", "5G", "20M", "OFDM", "1T", "165", "63",
-	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
-	"FCC", "5G", "20M", "HT", "1T", "36", "30",
-	"ETSI", "5G", "20M", "HT", "1T", "36", "32",
-	"MKK", "5G", "20M", "HT", "1T", "36", "28",
-	"FCC", "5G", "20M", "HT", "1T", "40", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "40", "32",
-	"MKK", "5G", "20M", "HT", "1T", "40", "28",
-	"FCC", "5G", "20M", "HT", "1T", "44", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "44", "32",
-	"MKK", "5G", "20M", "HT", "1T", "44", "28",
-	"FCC", "5G", "20M", "HT", "1T", "48", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "48", "32",
-	"MKK", "5G", "20M", "HT", "1T", "48", "28",
-	"FCC", "5G", "20M", "HT", "1T", "52", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "52", "32",
-	"MKK", "5G", "20M", "HT", "1T", "52", "28",
-	"FCC", "5G", "20M", "HT", "1T", "56", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "56", "32",
-	"MKK", "5G", "20M", "HT", "1T", "56", "28",
-	"FCC", "5G", "20M", "HT", "1T", "60", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "60", "32",
-	"MKK", "5G", "20M", "HT", "1T", "60", "28",
-	"FCC", "5G", "20M", "HT", "1T", "64", "28",
-	"ETSI", "5G", "20M", "HT", "1T", "64", "32",
-	"MKK", "5G", "20M", "HT", "1T", "64", "28",
-	"FCC", "5G", "20M", "HT", "1T", "100", "26",
-	"ETSI", "5G", "20M", "HT", "1T", "100", "32",
-	"MKK", "5G", "20M", "HT", "1T", "100", "32",
-	"FCC", "5G", "20M", "HT", "1T", "104", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "104", "32",
-	"MKK", "5G", "20M", "HT", "1T", "104", "32",
-	"FCC", "5G", "20M", "HT", "1T", "108", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "108", "32",
-	"MKK", "5G", "20M", "HT", "1T", "108", "32",
-	"FCC", "5G", "20M", "HT", "1T", "112", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "112", "32",
-	"MKK", "5G", "20M", "HT", "1T", "112", "32",
-	"FCC", "5G", "20M", "HT", "1T", "116", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "116", "32",
-	"MKK", "5G", "20M", "HT", "1T", "116", "32",
-	"FCC", "5G", "20M", "HT", "1T", "120", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "120", "32",
-	"MKK", "5G", "20M", "HT", "1T", "120", "32",
-	"FCC", "5G", "20M", "HT", "1T", "124", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "124", "32",
-	"MKK", "5G", "20M", "HT", "1T", "124", "32",
-	"FCC", "5G", "20M", "HT", "1T", "128", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "128", "32",
-	"MKK", "5G", "20M", "HT", "1T", "128", "32",
-	"FCC", "5G", "20M", "HT", "1T", "132", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "132", "32",
-	"MKK", "5G", "20M", "HT", "1T", "132", "32",
-	"FCC", "5G", "20M", "HT", "1T", "136", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "136", "32",
-	"MKK", "5G", "20M", "HT", "1T", "136", "32",
-	"FCC", "5G", "20M", "HT", "1T", "140", "26",
-	"ETSI", "5G", "20M", "HT", "1T", "140", "32",
-	"MKK", "5G", "20M", "HT", "1T", "140", "32",
-	"FCC", "5G", "20M", "HT", "1T", "144", "26",
-	"ETSI", "5G", "20M", "HT", "1T", "144", "63",
-	"MKK", "5G", "20M", "HT", "1T", "144", "63",
-	"FCC", "5G", "20M", "HT", "1T", "149", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "149", "63",
-	"MKK", "5G", "20M", "HT", "1T", "149", "63",
-	"FCC", "5G", "20M", "HT", "1T", "153", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "153", "63",
-	"MKK", "5G", "20M", "HT", "1T", "153", "63",
-	"FCC", "5G", "20M", "HT", "1T", "157", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "157", "63",
-	"MKK", "5G", "20M", "HT", "1T", "157", "63",
-	"FCC", "5G", "20M", "HT", "1T", "161", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "161", "63",
-	"MKK", "5G", "20M", "HT", "1T", "161", "63",
-	"FCC", "5G", "20M", "HT", "1T", "165", "32",
-	"ETSI", "5G", "20M", "HT", "1T", "165", "63",
-	"MKK", "5G", "20M", "HT", "1T", "165", "63",
-	"FCC", "5G", "20M", "HT", "2T", "36", "28",
-	"ETSI", "5G", "20M", "HT", "2T", "36", "20",
-	"MKK", "5G", "20M", "HT", "2T", "36", "22",
-	"FCC", "5G", "20M", "HT", "2T", "40", "30",
-	"ETSI", "5G", "20M", "HT", "2T", "40", "20",
-	"MKK", "5G", "20M", "HT", "2T", "40", "22",
-	"FCC", "5G", "20M", "HT", "2T", "44", "30",
-	"ETSI", "5G", "20M", "HT", "2T", "44", "20",
-	"MKK", "5G", "20M", "HT", "2T", "44", "22",
-	"FCC", "5G", "20M", "HT", "2T", "48", "30",
-	"ETSI", "5G", "20M", "HT", "2T", "48", "20",
-	"MKK", "5G", "20M", "HT", "2T", "48", "22",
-	"FCC", "5G", "20M", "HT", "2T", "52", "30",
-	"ETSI", "5G", "20M", "HT", "2T", "52", "20",
-	"MKK", "5G", "20M", "HT", "2T", "52", "22",
-	"FCC", "5G", "20M", "HT", "2T", "56", "30",
-	"ETSI", "5G", "20M", "HT", "2T", "56", "20",
-	"MKK", "5G", "20M", "HT", "2T", "56", "22",
-	"FCC", "5G", "20M", "HT", "2T", "60", "30",
-	"ETSI", "5G", "20M", "HT", "2T", "60", "20",
-	"MKK", "5G", "20M", "HT", "2T", "60", "22",
-	"FCC", "5G", "20M", "HT", "2T", "64", "28",
-	"ETSI", "5G", "20M", "HT", "2T", "64", "20",
-	"MKK", "5G", "20M", "HT", "2T", "64", "22",
-	"FCC", "5G", "20M", "HT", "2T", "100", "26",
-	"ETSI", "5G", "20M", "HT", "2T", "100", "20",
-	"MKK", "5G", "20M", "HT", "2T", "100", "30",
-	"FCC", "5G", "20M", "HT", "2T", "104", "30",
-	"ETSI", "5G", "20M", "HT", "2T", "104", "20",
-	"MKK", "5G", "20M", "HT", "2T", "104", "30",
-	"FCC", "5G", "20M", "HT", "2T", "108", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "108", "20",
-	"MKK", "5G", "20M", "HT", "2T", "108", "30",
-	"FCC", "5G", "20M", "HT", "2T", "112", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "112", "20",
-	"MKK", "5G", "20M", "HT", "2T", "112", "30",
-	"FCC", "5G", "20M", "HT", "2T", "116", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "116", "20",
-	"MKK", "5G", "20M", "HT", "2T", "116", "30",
-	"FCC", "5G", "20M", "HT", "2T", "120", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "120", "20",
-	"MKK", "5G", "20M", "HT", "2T", "120", "30",
-	"FCC", "5G", "20M", "HT", "2T", "124", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "124", "20",
-	"MKK", "5G", "20M", "HT", "2T", "124", "30",
-	"FCC", "5G", "20M", "HT", "2T", "128", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "128", "20",
-	"MKK", "5G", "20M", "HT", "2T", "128", "30",
-	"FCC", "5G", "20M", "HT", "2T", "132", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "132", "20",
-	"MKK", "5G", "20M", "HT", "2T", "132", "30",
-	"FCC", "5G", "20M", "HT", "2T", "136", "30",
-	"ETSI", "5G", "20M", "HT", "2T", "136", "20",
-	"MKK", "5G", "20M", "HT", "2T", "136", "30",
-	"FCC", "5G", "20M", "HT", "2T", "140", "26",
-	"ETSI", "5G", "20M", "HT", "2T", "140", "20",
-	"MKK", "5G", "20M", "HT", "2T", "140", "30",
-	"FCC", "5G", "20M", "HT", "2T", "144", "26",
-	"ETSI", "5G", "20M", "HT", "2T", "144", "63",
-	"MKK", "5G", "20M", "HT", "2T", "144", "63",
-	"FCC", "5G", "20M", "HT", "2T", "149", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "149", "63",
-	"MKK", "5G", "20M", "HT", "2T", "149", "63",
-	"FCC", "5G", "20M", "HT", "2T", "153", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "153", "63",
-	"MKK", "5G", "20M", "HT", "2T", "153", "63",
-	"FCC", "5G", "20M", "HT", "2T", "157", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "157", "63",
-	"MKK", "5G", "20M", "HT", "2T", "157", "63",
-	"FCC", "5G", "20M", "HT", "2T", "161", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "161", "63",
-	"MKK", "5G", "20M", "HT", "2T", "161", "63",
-	"FCC", "5G", "20M", "HT", "2T", "165", "32",
-	"ETSI", "5G", "20M", "HT", "2T", "165", "63",
-	"MKK", "5G", "20M", "HT", "2T", "165", "63",
-	"FCC", "5G", "40M", "HT", "1T", "38", "22",
-	"ETSI", "5G", "40M", "HT", "1T", "38", "30",
-	"MKK", "5G", "40M", "HT", "1T", "38", "30",
-	"FCC", "5G", "40M", "HT", "1T", "46", "30",
-	"ETSI", "5G", "40M", "HT", "1T", "46", "30",
-	"MKK", "5G", "40M", "HT", "1T", "46", "30",
-	"FCC", "5G", "40M", "HT", "1T", "54", "30",
-	"ETSI", "5G", "40M", "HT", "1T", "54", "30",
-	"MKK", "5G", "40M", "HT", "1T", "54", "30",
-	"FCC", "5G", "40M", "HT", "1T", "62", "24",
-	"ETSI", "5G", "40M", "HT", "1T", "62", "30",
-	"MKK", "5G", "40M", "HT", "1T", "62", "30",
-	"FCC", "5G", "40M", "HT", "1T", "102", "24",
-	"ETSI", "5G", "40M", "HT", "1T", "102", "30",
-	"MKK", "5G", "40M", "HT", "1T", "102", "30",
-	"FCC", "5G", "40M", "HT", "1T", "110", "30",
-	"ETSI", "5G", "40M", "HT", "1T", "110", "30",
-	"MKK", "5G", "40M", "HT", "1T", "110", "30",
-	"FCC", "5G", "40M", "HT", "1T", "118", "30",
-	"ETSI", "5G", "40M", "HT", "1T", "118", "30",
-	"MKK", "5G", "40M", "HT", "1T", "118", "30",
-	"FCC", "5G", "40M", "HT", "1T", "126", "30",
-	"ETSI", "5G", "40M", "HT", "1T", "126", "30",
-	"MKK", "5G", "40M", "HT", "1T", "126", "30",
-	"FCC", "5G", "40M", "HT", "1T", "134", "30",
-	"ETSI", "5G", "40M", "HT", "1T", "134", "30",
-	"MKK", "5G", "40M", "HT", "1T", "134", "30",
-	"FCC", "5G", "40M", "HT", "1T", "142", "30",
-	"ETSI", "5G", "40M", "HT", "1T", "142", "63",
-	"MKK", "5G", "40M", "HT", "1T", "142", "63",
-	"FCC", "5G", "40M", "HT", "1T", "151", "30",
-	"ETSI", "5G", "40M", "HT", "1T", "151", "63",
-	"MKK", "5G", "40M", "HT", "1T", "151", "63",
-	"FCC", "5G", "40M", "HT", "1T", "159", "30",
-	"ETSI", "5G", "40M", "HT", "1T", "159", "63",
-	"MKK", "5G", "40M", "HT", "1T", "159", "63",
-	"FCC", "5G", "40M", "HT", "2T", "38", "20",
-	"ETSI", "5G", "40M", "HT", "2T", "38", "20",
-	"MKK", "5G", "40M", "HT", "2T", "38", "22",
-	"FCC", "5G", "40M", "HT", "2T", "46", "30",
-	"ETSI", "5G", "40M", "HT", "2T", "46", "20",
-	"MKK", "5G", "40M", "HT", "2T", "46", "22",
-	"FCC", "5G", "40M", "HT", "2T", "54", "30",
-	"ETSI", "5G", "40M", "HT", "2T", "54", "20",
-	"MKK", "5G", "40M", "HT", "2T", "54", "22",
-	"FCC", "5G", "40M", "HT", "2T", "62", "22",
-	"ETSI", "5G", "40M", "HT", "2T", "62", "20",
-	"MKK", "5G", "40M", "HT", "2T", "62", "22",
-	"FCC", "5G", "40M", "HT", "2T", "102", "22",
-	"ETSI", "5G", "40M", "HT", "2T", "102", "20",
-	"MKK", "5G", "40M", "HT", "2T", "102", "30",
-	"FCC", "5G", "40M", "HT", "2T", "110", "30",
-	"ETSI", "5G", "40M", "HT", "2T", "110", "20",
-	"MKK", "5G", "40M", "HT", "2T", "110", "30",
-	"FCC", "5G", "40M", "HT", "2T", "118", "30",
-	"ETSI", "5G", "40M", "HT", "2T", "118", "20",
-	"MKK", "5G", "40M", "HT", "2T", "118", "30",
-	"FCC", "5G", "40M", "HT", "2T", "126", "30",
-	"ETSI", "5G", "40M", "HT", "2T", "126", "20",
-	"MKK", "5G", "40M", "HT", "2T", "126", "30",
-	"FCC", "5G", "40M", "HT", "2T", "134", "30",
-	"ETSI", "5G", "40M", "HT", "2T", "134", "20",
-	"MKK", "5G", "40M", "HT", "2T", "134", "30",
-	"FCC", "5G", "40M", "HT", "2T", "142", "30",
-	"ETSI", "5G", "40M", "HT", "2T", "142", "63",
-	"MKK", "5G", "40M", "HT", "2T", "142", "63",
-	"FCC", "5G", "40M", "HT", "2T", "151", "30",
-	"ETSI", "5G", "40M", "HT", "2T", "151", "63",
-	"MKK", "5G", "40M", "HT", "2T", "151", "63",
-	"FCC", "5G", "40M", "HT", "2T", "159", "30",
-	"ETSI", "5G", "40M", "HT", "2T", "159", "63",
-	"MKK", "5G", "40M", "HT", "2T", "159", "63",
-	"FCC", "5G", "80M", "VHT", "1T", "42", "20",
-	"ETSI", "5G", "80M", "VHT", "1T", "42", "30",
-	"MKK", "5G", "80M", "VHT", "1T", "42", "28",
-	"FCC", "5G", "80M", "VHT", "1T", "58", "20",
-	"ETSI", "5G", "80M", "VHT", "1T", "58", "30",
-	"MKK", "5G", "80M", "VHT", "1T", "58", "28",
-	"FCC", "5G", "80M", "VHT", "1T", "106", "20",
-	"ETSI", "5G", "80M", "VHT", "1T", "106", "30",
-	"MKK", "5G", "80M", "VHT", "1T", "106", "30",
-	"FCC", "5G", "80M", "VHT", "1T", "122", "30",
-	"ETSI", "5G", "80M", "VHT", "1T", "122", "30",
-	"MKK", "5G", "80M", "VHT", "1T", "122", "30",
-	"FCC", "5G", "80M", "VHT", "1T", "138", "30",
-	"ETSI", "5G", "80M", "VHT", "1T", "138", "63",
-	"MKK", "5G", "80M", "VHT", "1T", "138", "63",
-	"FCC", "5G", "80M", "VHT", "1T", "155", "30",
-	"ETSI", "5G", "80M", "VHT", "1T", "155", "63",
-	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
-	"FCC", "5G", "80M", "VHT", "2T", "42", "18",
-	"ETSI", "5G", "80M", "VHT", "2T", "42", "20",
-	"MKK", "5G", "80M", "VHT", "2T", "42", "22",
-	"FCC", "5G", "80M", "VHT", "2T", "58", "18",
-	"ETSI", "5G", "80M", "VHT", "2T", "58", "20",
-	"MKK", "5G", "80M", "VHT", "2T", "58", "22",
-	"FCC", "5G", "80M", "VHT", "2T", "106", "20",
-	"ETSI", "5G", "80M", "VHT", "2T", "106", "20",
-	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
-	"FCC", "5G", "80M", "VHT", "2T", "122", "30",
-	"ETSI", "5G", "80M", "VHT", "2T", "122", "20",
-	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
-	"FCC", "5G", "80M", "VHT", "2T", "138", "30",
-	"ETSI", "5G", "80M", "VHT", "2T", "138", "63",
-	"MKK", "5G", "80M", "VHT", "2T", "138", "63",
-	"FCC", "5G", "80M", "VHT", "2T", "155", "30",
-	"ETSI", "5G", "80M", "VHT", "2T", "155", "63",
-	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+static const struct file_operations file_ops_single_r = {
+	.owner = THIS_MODULE,
+	.open = rtw_debugfs_single_open_rw,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
 };
-#define TABLE_TXPWR_LIMIT_NUM		\
-	(sizeof(table_txpwr_lmt)/sizeof(table_txpwr_lmt[0]))
 
-struct rtl_channel_info {
-	u8 channel;
-	bool is_5g;	/* 5g channel? */
-	enum band_type band;
-	u8 ch_idx;	/* 2G: 0~13 */
-			/* 5G: 0~49 (include 80M channel) */
-			/* 5G 80M: within 49 */
-	u8 ch_idx2;	/* 5G 80M: 0~6 */
-	u64 rate_mask;	/* bitmap of possible rate */
-	u32 bw_mask;	/* bitmap of possible bandwidth */
-	u8 efuse_cck_offset;	/* 2G only */
-	u8 efuse_bw40_offset;	/* 2G or 5G */
+static const struct file_operations file_ops_single_rw = {
+	.owner = THIS_MODULE,
+	.open = rtw_debugfs_single_open_rw,
+	.release = single_release,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = rtw_debugfs_single_write,
 };
 
-struct rtl_rate_info {
-	enum rtl_desc_rate rate;
-	const char *rate_str;
-	enum rate_section rate_section;
-	bool is_cck;
-	bool is_ofdm;
-	u8 nss_1;	/* nss - 1 */
+static const struct file_operations file_ops_common_write = {
+	.owner = THIS_MODULE,
+	.write = rtw_debugfs_common_write,
+	.open = simple_open,
+	.release = rtw_debugfs_close,
 };
 
-static u8 get_pwr_limit_from_table(struct rtl_priv *rtlpriv,
-				   enum radio_path path,
-				   const struct rtl_rate_info *rate_info,
-				   enum ht_channel_width bandwidth,
-				   const struct rtl_channel_info *ch_info)
+static int rtw_debugfs_get_read_reg(struct seq_file *m, void *v)
 {
-	int i;
-	struct tab_pwr_limit {
-		const char *p[7];
-	} const *p;
-	u8 ret = 63;
-	unsigned long tmpl;
-	int junk;
-
-	/* In 5G and bandwidth is 20M or 40M, VHT and HT can cross reference */
-	bool cross_ref = (ch_info->is_5g &&
-			  (bandwidth == HT_CHANNEL_WIDTH_20 ||
-			   bandwidth == HT_CHANNEL_WIDTH_20_40));
-
-	for (i = 0, p = (struct tab_pwr_limit *)table_txpwr_lmt;
-	     i < TABLE_TXPWR_LIMIT_NUM; i += 7, p++) {
-		/* band */
-		if (ch_info->band == BAND_ON_5G && strcmp(p->p[1], "5G"))
-			continue;
-		if (ch_info->band == BAND_ON_2_4G && strcmp(p->p[1], "2.4G"))
-			continue;
-
-		/* bandwidth */
-		if (rate_info->rate_section == CCK ||
-		    rate_info->rate_section == OFDM) {
-			bandwidth = HT_CHANNEL_WIDTH_20;
-		}
-
-		if (bandwidth == HT_CHANNEL_WIDTH_20 && strcmp(p->p[2], "20M"))
-			continue;
-		if (bandwidth == HT_CHANNEL_WIDTH_20_40 &&
-		    strcmp(p->p[2], "40M"))
-			continue;
-		if (bandwidth == HT_CHANNEL_WIDTH_80 && strcmp(p->p[2], "80M"))
-			continue;
-
-		/* rate section */
-		if (rate_info->rate_section == CCK && strcmp(p->p[3], "CCK"))
-			continue;
-		if (rate_info->rate_section == OFDM && strcmp(p->p[3], "OFDM"))
-			continue;
-		if ((rate_info->rate_section == HT_MCS0_MCS7 ||
-		     rate_info->rate_section == HT_MCS8_MCS15)) {
-			if (strcmp(p->p[3], "HT") == 0)
-				;
-			else if (cross_ref && strcmp(p->p[3], "VHT") == 0)
-				;
-			else
-				continue;
-		}
-		if ((rate_info->rate_section == VHT_1SSMCS0_1SSMCS9 ||
-		     rate_info->rate_section == VHT_2SSMCS0_2SSMCS9)) {
-			if (strcmp(p->p[3], "VHT") == 0)
-				;
-			else if (cross_ref && strcmp(p->p[3], "HT") == 0)
-				;
-			else
-				continue;
-		}
-
-		/* NSS */
-		if (sscanf(p->p[4], "%ldT", &tmpl) != 1)
-			tmpl = 99;
-
-		if (rate_info->nss_1 + 1 != tmpl)
-			continue;
-
-		/* channel */
-		junk = kstrtoul(p->p[5], 10, &tmpl);
+	struct rtw_debugfs_priv *debugfs_priv = m->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	u32 val, len, addr;
 
-		if (ch_info->channel != tmpl)
-			continue;
-
-		/* value */
-		junk = kstrtoul(p->p[6], 10, &tmpl);
-
-		if (ret > tmpl)
-			ret = tmpl;
+	len = debugfs_priv->read_reg.len;
+	addr = debugfs_priv->read_reg.addr;
+	switch (len) {
+	case 1:
+		val = rtw_read8(rtwdev, addr);
+		seq_printf(m, "reg 0x%03x: 0x%02x\n", addr, val);
+		break;
+	case 2:
+		val = rtw_read16(rtwdev, addr);
+		seq_printf(m, "reg 0x%03x: 0x%04x\n", addr, val);
+		break;
+	case 4:
+		val = rtw_read32(rtwdev, addr);
+		seq_printf(m, "reg 0x%03x: 0x%08x\n", addr, val);
+		break;
 	}
-
-	return ret;
+	return 0;
 }
 
-static void get_rate_value(struct rtl_priv *rtlpriv,
-	u32 reg_addr, u32 bit_mask, u32 value,
-	u8 out_rate[], s8 out_pwr_val[], u8 *out_num)
-{
-	/* verify: replace original parsing function, and compare the result */
-
-#define DESC_RATENA	-1
-#define _M_REG_2_RATE_CORE(a0, a1, a2, a3, r0, r1, r2, r3, ign_mask)	\
-	{{a0, a1, a2, a3,}, ign_mask,					\
-	 {DESC_RATE ##r0, DESC_RATE ##r1, DESC_RATE ##r2, DESC_RATE ##r3,},}
-#define _M_REG_2_RATE(a0, a1, a2, a3, r0, r1, r2, r3)		\
-	_M_REG_2_RATE_CORE(a0, a1, a2, a3, r0, r1, r2, r3, true)
-#define _M_REG_2_RATE_CHKMASK(a0, r0, r1, r2, r3)	\
-	_M_REG_2_RATE_CORE(a0, 0, 0, 0, r0, r1, r2, r3, false)
-
-	struct rtl_reg2rate {
-		u32 reg_addr[4];
-		bool ign_mask;
-		enum rtl_desc_rate rate[4];
-	} reg2rates[] = {
-		_M_REG_2_RATE(0xe00, 0x830, 0, 0, 6M, 9M, 12M, 18M),
-		_M_REG_2_RATE(0xe04, 0x834, 0, 0, 24M, 36M, 48M, 54M),
-		_M_REG_2_RATE(0xe08, 0, 0, 0, NA, 1M, NA, NA),
-		_M_REG_2_RATE_CHKMASK(0x86c, 11M, 2M, 5_5M, 11M),
-		_M_REG_2_RATE(0xe10, 0x83c, 0, 0, MCS0, MCS1, MCS2, MCS3),
-		_M_REG_2_RATE(0xe14, 0x848, 0, 0, MCS4, MCS5, MCS6, MCS7),
-		_M_REG_2_RATE(0xe18, 0x84c, 0, 0, MCS8, MCS9, MCS10, MCS11),
-		_M_REG_2_RATE(0xe1c, 0x868, 0, 0, MCS12, MCS13, MCS14, MCS15),
-		_M_REG_2_RATE(0x838, 0, 0, 0, NA, 1M, 2M, 5_5M),
-		_M_REG_2_RATE(0xC20, 0xE20, 0x1820, 0x1a20, 1M, 2M, 5_5M, 11M),
-		_M_REG_2_RATE(0xC24, 0xE24, 0x1824, 0x1a24, 6M, 9M, 12M, 18M),
-		_M_REG_2_RATE(0xC28, 0xE28, 0x1828, 0x1a28, 24M, 36M, 48M, 54M),
-		_M_REG_2_RATE(0xC2C, 0xE2C, 0x182C, 0x1a2C,
-			      MCS0, MCS1, MCS2, MCS3),
-		_M_REG_2_RATE(0xC30, 0xE30, 0x1830, 0x1a30,
-			      MCS4, MCS5, MCS6, MCS7),
-		_M_REG_2_RATE(0xC34, 0xE34, 0x1834, 0x1a34,
-			      MCS8, MCS9, MCS10, MCS11),
-		_M_REG_2_RATE(0xC38, 0xE38, 0x1838, 0x1a38,
-			      MCS12, MCS13, MCS14, MCS15),
-		_M_REG_2_RATE(0xC3C, 0xE3C, 0x183C, 0x1a3C, VHT1SS_MCS0,
-			      VHT1SS_MCS1, VHT1SS_MCS2, VHT1SS_MCS3),
-		_M_REG_2_RATE(0xC40, 0xE40, 0x1840, 0x1a40, VHT1SS_MCS4,
-			      VHT1SS_MCS5, VHT1SS_MCS6, VHT1SS_MCS7),
-		_M_REG_2_RATE(0xC44, 0xE44, 0x1844, 0x1a44, VHT1SS_MCS8,
-			      VHT1SS_MCS9, VHT2SS_MCS0, VHT2SS_MCS1),
-		_M_REG_2_RATE(0xC48, 0xE48, 0x1848, 0x1a48, VHT2SS_MCS2,
-			      VHT2SS_MCS3, VHT2SS_MCS4, VHT2SS_MCS5),
-		_M_REG_2_RATE(0xC4C, 0xE4C, 0x184C, 0x1a4C, VHT2SS_MCS6,
-			      VHT2SS_MCS7, VHT2SS_MCS8, VHT2SS_MCS9),
-#if 0
-		_M_REG_2_RATE(0xCD8, 0xED8, 0x18D8, 0x1aD8,
-			      MCS16, MCS17, MCS18, MCS19),
-		_M_REG_2_RATE(0xCDC, 0xEDC, 0x18DC, 0x1aDC,
-			      MCS20, MCS21, MCS22, MCS23),
-		_M_REG_2_RATE(0xCE0, 0xEE0, 0x18E0, 0x1aE0, VHT3SS_MCS0,
-			      VHT3SS_MCS1, VHT3SS_MCS2, VHT3SS_MCS3),
-		_M_REG_2_RATE(0xCE4, 0xEE4, 0x18E4, 0x1aE4, VHT3SS_MCS4,
-			      VHT3SS_MCS5, VHT3SS_MCS6, VHT3SS_MCS7),
-		_M_REG_2_RATE(0xCE8, 0xEE8, 0x18E8, 0x1aE8, VHT3SS_MCS8,
-			      VHT3SS_MCS9),
-#endif
-	};
-
-#define REG2RATES_NUM		(sizeof(reg2rates)/sizeof(reg2rates[0]))
-
-	int i, j;
-	u32 mask;
-	u8 tmp;
-	struct rtl_reg2rate *reg2rate;
-
-	for (i = 0; i < REG2RATES_NUM; i++) {
-		reg2rate = &reg2rates[i];
-		for (j = 0; j < 4; j++) {
-			if (reg2rate->reg_addr[j] == 0)
-				break;
+static int rtw_debugfs_get_rf_read(struct seq_file *m, void *v)
+{
+	struct rtw_debugfs_priv *debugfs_priv = m->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	u32 val, addr, mask;
+	u8 path;
 
-			if (reg2rate->reg_addr[j] == reg_addr)
-				goto label_found;
-		}
-	}
+	path = debugfs_priv->rf_path;
+	addr = debugfs_priv->rf_addr;
+	mask = debugfs_priv->rf_mask;
 
-	/* not found */
-	*out_num = 0;
+	val = rtw_read_rf(rtwdev, path, addr, mask);
 
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-		 "Invalid reg_addr 0x%x in %s()\n", reg_addr, __func__);
-	return;
+	seq_printf(m, "rf_read path:%d addr:0x%08x mask:0x%08x val=0x%08x\n",
+		   path, addr, mask, val);
 
-	/* found */
-label_found:
-	*out_num = 0;
+	return 0;
+}
 
-	for (i = 0, mask = 0xFF; i < 4; i++, mask <<= 8) {
-		if (!(bit_mask & mask))
-			continue;
+static int rtw_debugfs_copy_from_user(char tmp[], int size,
+				      const char __user *buffer, size_t count,
+				      int num)
+{
+	int tmp_len;
 
-		if (reg2rate->rate[i] == DESC_RATENA)
-			continue;
+	if (count < num)
+		return -EFAULT;
 
-		/* out rate */
-		out_rate[*out_num] = reg2rate->rate[i];
+	tmp_len = (count > size - 1 ? size - 1 : count);
 
-		/* out pwr value ('value' is BCD code) */
-		tmp = (value & mask) >> (i * 8);
-		out_pwr_val[*out_num] = (tmp >> 4) * 10 + (tmp & 0x0F);
+	if (!buffer || copy_from_user(tmp, buffer, tmp_len))
+		return count;
 
-		/* increase out num */
-		*out_num += 1;
-	}
+	tmp[tmp_len] = '\0';
 
+	return 0;
 }
-EXPORT_SYMBOL(get_rate_value);
-
-static void get_diff_pwr_from_efuse(struct rtl_priv *rtlpriv,
-				    enum radio_path path,
-				    const struct rtl_rate_info *rate_info,
-				    enum ht_channel_width bandwidth,
-				    const struct rtl_channel_info *ch_info,
-				    int nss_1,
-				    s8 *diff_pwr,
-				    s8 *diff_pwr2)
-{
-	/* DONT use rate_info->nss_1 because this is recursive call! */
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
-
-	int offset = 0;
-	int nibble = 0;
-	int offset2 = 0;
-	int nibble2 = 0;
-	s8 tmp;
-
-	if (!ch_info->is_5g) {
-		if (nss_1 == 0) {
-			if (rate_info->is_cck) {
-				/* no diff */
-			} else if (rate_info->is_ofdm) {
-				offset2 = 0x1b;
-				nibble2 = 0;
-			}
 
-			if (bandwidth == HT_CHANNEL_WIDTH_20) {
-				offset = 0x1b;
-				nibble = 1;
-			} else if (bandwidth == HT_CHANNEL_WIDTH_20_40) {
-				/* no diff */
-			}
-		} else {
-			if (rate_info->is_cck) {
-				offset2 = 0x1d;
-				nibble2 = 0;
-			} else if (rate_info->is_ofdm) {
-				offset2 = 0x1d;
-				nibble2 = 1;
-			}
+static ssize_t rtw_debugfs_set_read_reg(struct file *filp,
+					const char __user *buffer,
+					size_t count, loff_t *loff)
+{
+	struct seq_file *seqpriv = (struct seq_file *)filp->private_data;
+	struct rtw_debugfs_priv *debugfs_priv = seqpriv->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	char tmp[32 + 1];
+	u32 addr, len;
+	int num;
 
-			if (bandwidth == HT_CHANNEL_WIDTH_20) {
-				offset = 0x1c;
-				nibble = 0;
-			} else if (bandwidth == HT_CHANNEL_WIDTH_20_40) {
-				offset = 0x1c;
-				nibble = 1;
-			}
+	rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 2);
 
-			offset += (nss_1 - 1) * 2;
-			offset2 += (nss_1 - 1) * 2;
-		}
-	} else {
-		if (rate_info->is_ofdm) {
-			switch (nss_1) {
-			case 0:
-				offset2 = 0x30;
-				nibble2 = 0;
-				break;
-			case 1:
-				offset2 = 0x34;
-				nibble2 = 1;
-				break;
-			case 2:
-				offset2 = 0x34;
-				nibble2 = 0;
-				break;
-			case 3:
-				offset2 = 0x35;
-				nibble2 = 0;
-				break;
-			}
-		}
+	num = sscanf(tmp, "%x %x", &addr, &len);
 
-		if (bandwidth == HT_CHANNEL_WIDTH_80) {
-			offset = 0x36 + nss_1 * 1;
-			nibble = 1;
-			offset2 = 0;	/* 80M no OFDM diff */
-			nibble2 = 0;
-		} else if (bandwidth == HT_CHANNEL_WIDTH_20_40) {
-			if (nss_1 > 0) {
-				offset = 0x31 + (nss_1 - 1) * 1;
-				nibble = 1;
-			}
-		} else if (bandwidth == HT_CHANNEL_WIDTH_20) {
-			if (nss_1 == 0) {
-				offset = 0x30;
-				nibble = 1;
-			} else {
-				offset = 0x31 + (nss_1 - 1) * 1;
-				nibble = 0;
-			}
-		}
-	}
-
-	if (offset)
-		offset += path * (0x3A - 0x10);	/* 0x2A bytes per path */
-	if (offset2)
-		offset2 += path * (0x3A - 0x10);/* 0x2A bytes per path */
-
-	/* fill diff_pwr */
-	if (offset) {
-		tmp = rtlefuse->efuse_map[0][offset];
-		if (nibble)
-			tmp = tmp >> 4;
-		else
-			tmp = (tmp << 4) >> 4;
-		*diff_pwr += tmp;
-	}
+	if (num !=  2)
+		return count;
 
-	/* fill diff_pwr2 */
-	if (offset2) {
-		tmp = rtlefuse->efuse_map[0][offset2];
-		if (nibble2)
-			tmp = tmp >> 4;
-		else
-			tmp = (tmp << 4) >> 4;
-		*diff_pwr2 += tmp;
+	if (len != 1 && len != 2 && len != 4) {
+		rtw_warn(rtwdev, "read reg setting wrong len\n");
+		return -EINVAL;
 	}
+	debugfs_priv->read_reg.addr = addr;
+	debugfs_priv->read_reg.len = len;
 
-	/* recursive? */
-	if (nss_1 == 0)
-		return;
-
-	get_diff_pwr_from_efuse(rtlpriv, path, rate_info, bandwidth, ch_info,
-				nss_1 - 1,
-				diff_pwr, diff_pwr2);
+	return count;
 }
 
-static void get_base_pwr_from_efuse(struct rtl_priv *rtlpriv,
-				    enum radio_path path,
-				    const struct rtl_rate_info *rate_info,
-				    enum ht_channel_width bandwidth,
-				    const struct rtl_channel_info *ch_info,
-				    u8 *base_pwr,
-				    s8 *diff_pwr,
-				    s8 *diff_pwr2)
+static int rtw_debugfs_get_dump_cam(struct seq_file *m, void *v)
 {
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
-
-	int offset;
-
-	/* base_pwr */
-	if (rate_info->is_cck)
-		offset = ch_info->efuse_cck_offset;
-	else
-		offset = ch_info->efuse_bw40_offset;
-
-	offset += path * (0x3A - 0x10);	/* 0x2A bytes per path */
-
-	*base_pwr = rtlefuse->efuse_map[0][offset];
-
-	if (ch_info->is_5g && bandwidth == HT_CHANNEL_WIDTH_80) {
-		*base_pwr += rtlefuse->efuse_map[0][offset + 1];
-		*base_pwr >>= 1;	/* avg. */
-	}
-
-	/* diff_pwr */
-	*diff_pwr = 0;
-	*diff_pwr2 = 0;
-
-	get_diff_pwr_from_efuse(rtlpriv, path, rate_info, bandwidth, ch_info,
-				rate_info->nss_1,
-				diff_pwr, diff_pwr2);
-}
-
-static void dump_tx_power_index_core(struct rtl_priv *rtlpriv,
-				     struct seq_file *m,
-				     enum radio_path path,
-				     const struct rtl_rate_info *rate_info,
-				     enum ht_channel_width bandwidth,
-				     const struct rtl_channel_info *ch_info)
-{
-#define HACK_REGULATORY		1	/* 0: by efuse */
-					/* 1: pwr by rate + pwr limit*/
-					/* 2: base pwr */
-					/* 3: pwr by rate */
-
-	struct rtl_hal_ops *halops = rtlpriv->cfg->ops;
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
-	struct rtl_phy *rtlphy = &rtlpriv->phy;
-	u8 tx_pwr = 0xEA;
-	u8 base_pwr;
-	s8 diff_pwr, diff_pwr2 = 0;
-
-	u8 channel = ch_info->channel;
-	u8 ch_idx = ch_info->ch_idx;
-	u8 ch_idx2 = ch_info->ch_idx2;
-	bool is_5g = ch_info->is_5g;
-	u8 band = ch_info->band;
-
-	enum rtl_desc_rate rate = rate_info->rate;
-	const char *rate_str = rate_info->rate_str;
-	enum rate_section rate_section = rate_info->rate_section;
-	int nss_idx = rate_info->nss_1;
-	bool is_cck = rate_info->is_cck;
-	bool is_ofdm = rate_info->is_ofdm;
-
-	bool is_80M = (bandwidth == HT_CHANNEL_WIDTH_80);
-	bool is_40M = (bandwidth == HT_CHANNEL_WIDTH_20_40);
-
-	u8 bak_eeprom_regulatory = rtlefuse->eeprom_regulatory;
-
-	s8 pwr_by_rate_offset;
-	u8 pwr_by_rate_base;
-	s8 pwr_limit, pwr_limit_tmp;
-	u8 bw_limit;
-	int regulation = TXPWR_LMT_WW;
+	struct rtw_debugfs_priv *debugfs_priv = m->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	u32 val, command;
+	u32 hw_key_idx = debugfs_priv->cb_data << RTW_SEC_CAM_ENTRY_SHIFT;
+	u32 read_cmd = RTW_SEC_CMD_POLLING;
 	int i;
 
-	u8 efuse_base_pwr;
-	s8 efuse_diff_pwr, efuse_diff_pwr2;
-
-	u8 tab_pwr_limit;
-
-	u8 reg_tx_pwr = 0xFF;
-
-	/* tx_pwr */
-	if (halops->get_txpower_index) {
-		if (HACK_REGULATORY)
-			rtlefuse->eeprom_regulatory = HACK_REGULATORY;
-
-		tx_pwr = halops->get_txpower_index(rtlpriv->hw, path, rate,
-						   bandwidth, channel);
-
-		if (HACK_REGULATORY)
-			rtlefuse->eeprom_regulatory = bak_eeprom_regulatory;
-	}
-
-	if (rtlpriv->phydm.ops &&
-	    rtlphy->current_channel == ch_info->channel &&
-	    rtlphy->current_chan_bw == bandwidth)
-		reg_tx_pwr = rtlpriv->phydm.ops->phydm_read_txagc(rtlpriv, path,
-							rate_info->rate);
-
-	/* base_pwr */
-	if (is_5g) {
-		if (is_80M)
-			base_pwr = rtlefuse->txpwr_5g_bw80base[path][ch_idx2];
-		else
-			base_pwr = rtlefuse->txpwr_5g_bw40base[path][ch_idx];
-	} else {
-		if (is_cck)
-			base_pwr = rtlefuse->txpwrlevel_cck[path][ch_idx];
-		else
-			base_pwr = rtlefuse->txpwrlevel_ht40_1s[path][ch_idx];
-	}
-
-	get_base_pwr_from_efuse(rtlpriv, path, rate_info, bandwidth, ch_info,
-				&efuse_base_pwr,
-				&efuse_diff_pwr, &efuse_diff_pwr2);
-
-	/* diff_pwr */
-	if (is_5g) {
-		if (is_ofdm && !is_80M) {
-			for (i = 0, diff_pwr2 = 0; i <= nss_idx; i++)
-			    diff_pwr2 += rtlefuse->txpwr_5g_ofdmdiff[path][i];
-		}
-
-		if (is_80M) {
-			for (i = 0, diff_pwr = 0; i <= nss_idx; i++)
-			    diff_pwr += rtlefuse->txpwr_5g_bw80diff[path][i];
-		} else if (is_40M) {
-			for (i = 0, diff_pwr = 0; i <= nss_idx; i++)
-			    diff_pwr += rtlefuse->txpwr_5g_bw40diff[path][i];
-		} else {
-			for (i = 0, diff_pwr = 0; i <= nss_idx; i++)
-			    diff_pwr += rtlefuse->txpwr_5g_bw20diff[path][i];
-		}
-	} else {
-		if (is_cck)
-			diff_pwr2 = 0;/*rtlefuse->txpwr_cckdiff;*/
-		else if (is_ofdm) {
-			for (i = 0, diff_pwr2 = 0; i <= nss_idx; i++)
-			    diff_pwr2 += rtlefuse->txpwr_legacyhtdiff[path][i];
-		}
-
-		if (is_40M) {
-			for (i = 0, diff_pwr = 0; i <= nss_idx; i++)
-				diff_pwr += rtlefuse->txpwr_ht40diff[path][i];
-		} else {
-			for (i = 0, diff_pwr = 0; i <= nss_idx; i++)
-				diff_pwr += rtlefuse->txpwr_ht20diff[path][i];
-		}
-	}
-
-	/* power by rate */
-	if (is_5g)
-		pwr_by_rate_base = rtlphy->txpwr_by_rate_base_5g
-					[path][nss_idx][rate_section - 1];
-	else
-		pwr_by_rate_base = rtlphy->txpwr_by_rate_base_24g
-					[path][nss_idx][rate_section];
-
-	pwr_by_rate_offset =
-		(s8)rtlphy->tx_power_by_rate_offset[band][path][nss_idx][rate];
-
-
-	/* power limit */
-	if (rate_section == 1 || rate_section == 0)
-		bw_limit = 0;	/* CCK or OFDM ==> 20M */
-	else if ((rate_section == 2 || rate_section == 3) &&
-		 band == BAND_ON_5G && bandwidth == 2)
-		bw_limit = 1;	/* HT 1/2SS && 5G && 80M ==> 40M */
-	else
-		bw_limit = bandwidth;
-
-	if (regulation == TXPWR_LMT_WW) {
-		for (i = 0, pwr_limit = 0x3F; i < 4; i++) {
-			pwr_limit_tmp = (is_5g ?
-				rtlphy->txpwr_limit_5g[i]
-					[bw_limit][rate_section]
-					[ch_idx][path]
-				:
-				rtlphy->txpwr_limit_2_4g[i]
-					[bw_limit][rate_section]
-					[ch_idx][path]
-				);
-
-			if (pwr_limit > pwr_limit_tmp)
-				pwr_limit = pwr_limit_tmp;
-		}
-	} else {
-		pwr_limit = (is_5g ?
-			rtlphy->txpwr_limit_5g[regulation]
-				[bw_limit][rate_section][ch_idx][path]
-			:
-			rtlphy->txpwr_limit_2_4g[regulation]
-				[bw_limit][rate_section][ch_idx][path]);
-	}
-
-	tab_pwr_limit = get_pwr_limit_from_table(rtlpriv,
-				  path, rate_info, bandwidth, ch_info);
-
-	/* output */
-#define DUMP_TX_POWER_TITLE()						\
-	seq_printf(m, "%3s %1s %2s %13s "				\
-		   "%4s %4s %2s "					\
-		   "%4s %4s %2s %4s %3s %2s "				\
-		   "%5s %4s %2s %4s "					\
-		   "%6s %5s %4s "					\
-		   "%6s %5s %2s %4s\n",					\
-		   "CH", "p", "bw", "RATE",				\
-		   "[PWR", "rPWR", "C]",				\
-		   "[(BAS", "eBAS", "C)", "(DIF", "eDF", "C)",		\
-		   "(DIF2", "eDF2", "C)", "CHK]",			\
-		   "[RaBas", "RaOff", "CHK]",				\
-		   "[LiOff", "(tLim", "C)", "CHK]")
-
-	seq_printf(m,
-		   "%3d %1d %2d %13s "
-		   " %02xh  %02xh %-2s "
-		   "  %02xh  %02xh %-2s %4d %3d %-2s %5d %4d %-2s %-4s "
-		   "%5xh %5d %-4s "
-		   "%6d %5d %-2s %-4s\n",
-		   channel, path, bandwidth, rate_str,
-		   tx_pwr, reg_tx_pwr,
-		   (reg_tx_pwr == 0xFF ? " " :
-		    reg_tx_pwr == tx_pwr ? "Q" : "X"),
-		   base_pwr, efuse_base_pwr,
-		   (base_pwr == efuse_base_pwr ? "O" : "X"),
-		   diff_pwr, efuse_diff_pwr,
-		   (diff_pwr == efuse_diff_pwr ? "O" : "X"),
-		   diff_pwr2, efuse_diff_pwr2,
-		   (diff_pwr2 == efuse_diff_pwr2 ? "O" : "X"),
-		   (HACK_REGULATORY != 2 ? "?" :
-			tx_pwr == base_pwr + diff_pwr + diff_pwr2 ? "O" : "X"),
-		   pwr_by_rate_base, pwr_by_rate_offset,
-		   (HACK_REGULATORY != 3 ? "?" :
-			tx_pwr == base_pwr + diff_pwr + diff_pwr2 +
-				  pwr_by_rate_offset ? "O" : "X"),
-		   pwr_limit, tab_pwr_limit,
-		   ((s8)(tab_pwr_limit - pwr_by_rate_base) == pwr_limit ? "O" :
-		    tab_pwr_limit == pwr_limit && pwr_limit == 0x3F ?
-		    "O" : "X"),
-		   (HACK_REGULATORY != 1 ? "?" :
-			tx_pwr == base_pwr + diff_pwr + diff_pwr2 +
-				  (pwr_by_rate_offset < pwr_limit ?
-				   pwr_by_rate_offset : pwr_limit) ? "O" : "X")
-		   );
-}
-
-static void dump_tx_power_index(struct rtl_priv *rtlpriv, struct seq_file *m)
-{
-	enum ch_idx {
-		CH_5G_IDX_36,
-		CH_5G_IDX_38,
-		CH_5G_IDX_40,
-		CH_5G_IDX_42,	/* 80M */
-		CH_5G_IDX_44,
-		CH_5G_IDX_46,
-		CH_5G_IDX_48,
-		CH_5G_IDX_52,
-		CH_5G_IDX_54,
-		CH_5G_IDX_56,
-		CH_5G_IDX_58,	/* 80M */
-		CH_5G_IDX_60,
-		CH_5G_IDX_62,
-		CH_5G_IDX_64,
-		CH_5G_IDX_100,
-		CH_5G_IDX_102,
-		CH_5G_IDX_104,
-		CH_5G_IDX_106,	/* 80M */
-		CH_5G_IDX_108,
-		CH_5G_IDX_110,
-		CH_5G_IDX_112,
-		CH_5G_IDX_116,
-		CH_5G_IDX_118,
-		CH_5G_IDX_120,
-		CH_5G_IDX_122,	/* 80M */
-		CH_5G_IDX_124,
-		CH_5G_IDX_126,
-		CH_5G_IDX_128,
-		CH_5G_IDX_132,
-		CH_5G_IDX_134,
-		CH_5G_IDX_136,
-		CH_5G_IDX_138,	/* 80M */
-		CH_5G_IDX_140,
-		CH_5G_IDX_142,
-		CH_5G_IDX_144,
-		CH_5G_IDX_149,
-		CH_5G_IDX_151,
-		CH_5G_IDX_153,
-		CH_5G_IDX_155,	/* 80M */
-		CH_5G_IDX_157,
-		CH_5G_IDX_159,
-		CH_5G_IDX_161,
-		CH_5G_IDX_165,
-		CH_5G_IDX_167,
-		CH_5G_IDX_169,
-		CH_5G_IDX_171,	/* 80M */
-		CH_5G_IDX_173,
-		CH_5G_IDX_175,
-		CH_5G_IDX_177,
-
-		/* 80M */
-		CH_5G_80M_IDX_42 = 0,
-		CH_5G_80M_IDX_58,
-		CH_5G_80M_IDX_106,
-		CH_5G_80M_IDX_122,
-		CH_5G_80M_IDX_138,
-		CH_5G_80M_IDX_155,
-		CH_5G_80M_IDX_171,
-	};
-
-#define RATE_ALL	0xFFFFFFFFFFFFFFFFULL	/* number to bitmap */
-#define RATE_NO_CCK	0xFFFFFFFFFFFFFFF0ULL	/* number to bitmap */
-#define BW_20		BIT(HT_CHANNEL_WIDTH_20)
-#define BW_40		BIT(HT_CHANNEL_WIDTH_20_40)
-#define BW_80		BIT(HT_CHANNEL_WIDTH_80)
-
-#define _M_EFUSE_CCK_OFFSET(ch)	(			\
-		(ch >= 1 && ch <= 2) ? 0x10 :		\
-		(ch >= 3 && ch <= 5) ? 0x11 :		\
-		(ch >= 6 && ch <= 8) ? 0x12 :		\
-		(ch >= 9 && ch <= 11) ? 0x13 :		\
-		(ch >= 12 && ch <= 13) ? 0x14 :		\
-		0x15 /* ch == 14 */)
-#define _M_EFUSE_BW40_OFFSET_2G(ch)	(		\
-		(ch >= 1 && ch <= 2) ? 0x16 :		\
-		(ch >= 3 && ch <= 5) ? 0x17 :		\
-		(ch >= 6 && ch <= 8) ? 0x18 :		\
-		(ch >= 9 && ch <= 11) ? 0x19 :		\
-		0x1A /* ch == 12~14 */)
-#define _M_EFUSE_BW40_OFFSET_5G(ch)	(		\
-		(ch >= 36 && ch <= 42) ? 0x22 :		\
-		(ch >= 44 && ch <= 48) ? 0x23 :		\
-		(ch >= 52 && ch <= 58) ? 0x24 :		\
-		(ch >= 60 && ch <= 64) ? 0x25 :		\
-		(ch >= 100 && ch <= 106) ? 0x26 :	\
-		(ch >= 108 && ch <= 112) ? 0x27 :	\
-		(ch >= 116 && ch <= 122) ? 0x28 :	\
-		(ch >= 124 && ch <= 128) ? 0x29 :	\
-		(ch >= 132 && ch <= 138) ? 0x2a :	\
-		(ch >= 140 && ch <= 144) ? 0x2b :	\
-		(ch >= 149 && ch <= 155) ? 0x2c :	\
-		(ch >= 157 && ch <= 161) ? 0x2d :	\
-		(ch >= 165 && ch <= 171) ? 0x2e :	\
-		(ch >= 173 && ch <= 177) ? 0x2f :	\
-		0 /* wrong */)
-
-#define _M_EFUSE_BW40_OFFSET(ch) (ch <= 14 ? _M_EFUSE_BW40_OFFSET_2G(ch) : \
-				  _M_EFUSE_BW40_OFFSET_5G(ch))
-
-#define _M_CH_2G(x)	{x, false, BAND_ON_2_4G,			\
-			 (x) - 1, (x) - 1,				\
-			 RATE_ALL, BW_20 | BW_40,			\
-			 _M_EFUSE_CCK_OFFSET(x), _M_EFUSE_BW40_OFFSET(x), \
-			}
-#define _M_CH_5G_20M(x)	{x, true, BAND_ON_5G,				\
-			 CH_5G_IDX_ ##x, CH_5G_IDX_ ##x,		\
-			 RATE_NO_CCK, BW_20,				\
-			 0, _M_EFUSE_BW40_OFFSET(x),			\
-			}
-#define _M_CH_5G_40M(x)	{x, true, BAND_ON_5G,				\
-			 CH_5G_IDX_ ##x, CH_5G_IDX_ ##x,		\
-			 RATE_NO_CCK, BW_40,				\
-			 0, _M_EFUSE_BW40_OFFSET(x),			\
-			}
-#define _M_CH_5G_80M(x)	{x, true, BAND_ON_5G,				\
-			 CH_5G_IDX_ ##x, CH_5G_80M_IDX_ ##x,		\
-			 RATE_NO_CCK, BW_80,				\
-			 0, _M_EFUSE_BW40_OFFSET(x),			\
-			}
-
-	static const struct rtl_channel_info channels[] = {
-		/* 2G */
-		_M_CH_2G(1),   _M_CH_2G(2),   _M_CH_2G(3),   _M_CH_2G(4),
-		_M_CH_2G(5),   _M_CH_2G(6),   _M_CH_2G(7),
-		_M_CH_2G(8),   _M_CH_2G(9),   _M_CH_2G(10),  _M_CH_2G(11),
-		_M_CH_2G(12),  _M_CH_2G(13),  _M_CH_2G(14),
-		/* 5G: Band 1 */
-		_M_CH_5G_20M(36),  _M_CH_5G_40M(38),  _M_CH_5G_20M(40),
-		_M_CH_5G_80M(42),
-		_M_CH_5G_20M(44),  _M_CH_5G_40M(46),  _M_CH_5G_20M(48),
-		/* 5G: Band 2 */
-		_M_CH_5G_20M(52),  _M_CH_5G_40M(54),  _M_CH_5G_20M(56),
-		_M_CH_5G_80M(58),
-		_M_CH_5G_20M(60),  _M_CH_5G_40M(62),  _M_CH_5G_20M(64),
-		/* 5G: Band 3 */
-		_M_CH_5G_20M(100), _M_CH_5G_40M(102), _M_CH_5G_20M(104),
-		_M_CH_5G_80M(106),
-		_M_CH_5G_20M(108), _M_CH_5G_40M(110), _M_CH_5G_20M(112),
-		/* 5G: Band 3 */
-		_M_CH_5G_20M(116), _M_CH_5G_40M(118), _M_CH_5G_20M(120),
-		_M_CH_5G_80M(122),
-		_M_CH_5G_20M(124), _M_CH_5G_40M(126), _M_CH_5G_20M(128),
-		/* 5G: Band 3 */
-		_M_CH_5G_20M(132), _M_CH_5G_40M(134), _M_CH_5G_20M(136),
-		_M_CH_5G_80M(138),
-		_M_CH_5G_20M(140), _M_CH_5G_40M(142), _M_CH_5G_20M(144),
-		/* 5G: Band 4 */
-		_M_CH_5G_20M(149), _M_CH_5G_40M(151), _M_CH_5G_20M(153),
-		_M_CH_5G_80M(155),
-		_M_CH_5G_20M(157), _M_CH_5G_40M(159), _M_CH_5G_20M(161),
-		/* 5G: Band 4 */
-		_M_CH_5G_20M(165), _M_CH_5G_40M(167), _M_CH_5G_20M(169),
-		_M_CH_5G_80M(171),
-		_M_CH_5G_20M(173), _M_CH_5G_40M(175), _M_CH_5G_20M(177),
-	};
-#undef RATE_ALL
-#undef RATE_NO_CCK
-#undef BW_20
-#undef BW_40
-#undef BW_80
-#undef _M_CH_2G
-#undef _M_CH_5G_20M
-#undef _M_CH_5G_40M
-#undef _M_CH_5G_80M
-
-#define _M_RATE_SECTION(rate) (						 \
-	(rate >= DESC_RATE1M && rate <= DESC_RATE11M) ? CCK :		 \
-	(rate >= DESC_RATE6M && rate <= DESC_RATE54M) ? OFDM :		 \
-	(rate >= DESC_RATEMCS0 && rate <= DESC_RATEMCS7) ?		 \
-		HT_MCS0_MCS7 :						 \
-	(rate >= DESC_RATEMCS8 && rate <= DESC_RATEMCS15) ?		 \
-		HT_MCS8_MCS15 :						 \
-	(rate >= DESC_RATEVHT1SS_MCS0 && rate <= DESC_RATEVHT1SS_MCS9) ? \
-		VHT_1SSMCS0_1SSMCS9 :					 \
-	(rate >= DESC_RATEVHT2SS_MCS0 && rate <= DESC_RATEVHT2SS_MCS9) ? \
-		VHT_2SSMCS0_2SSMCS9 : MAX_RATE_SECTION)
-#define _M_IS_CCK(rate)		(_M_RATE_SECTION(rate) == CCK)
-#define _M_IS_OFDM(rate)	(_M_RATE_SECTION(rate) == OFDM)
-#define _M_RATE_NSS_1(rate)	(					\
-		 _M_IS_CCK(rate) ? 0 :					\
-		 _M_IS_OFDM(rate) ? 0 :					\
-		 _M_RATE_SECTION(rate) == HT_MCS0_MCS7 ? 0 :		\
-		 _M_RATE_SECTION(rate) == HT_MCS8_MCS15 ? 1 :		\
-		 _M_RATE_SECTION(rate) == VHT_1SSMCS0_1SSMCS9 ? 0 :	\
-		 _M_RATE_SECTION(rate) == VHT_2SSMCS0_2SSMCS9 ? 1 : 0)
-#define _M_RATE(x)	{						\
-	DESC_RATE##x, #x, _M_RATE_SECTION(DESC_RATE##x),		\
-	_M_IS_CCK(DESC_RATE##x), _M_IS_OFDM(DESC_RATE##x),		\
-	_M_RATE_NSS_1(DESC_RATE##x),					\
-	}
-
-	static const struct rtl_rate_info rates[] = {
-		_M_RATE(1M),
-		_M_RATE(2M),
-		_M_RATE(5_5M),
-		_M_RATE(11M),
-
-		_M_RATE(6M),
-		_M_RATE(9M),
-		_M_RATE(12M),
-		_M_RATE(18M),
-		_M_RATE(24M),
-		_M_RATE(36M),
-		_M_RATE(48M),
-		_M_RATE(54M),
-
-		_M_RATE(MCS0),
-		_M_RATE(MCS1),
-		_M_RATE(MCS2),
-		_M_RATE(MCS3),
-		_M_RATE(MCS4),
-		_M_RATE(MCS5),
-		_M_RATE(MCS6),
-		_M_RATE(MCS7),
-		_M_RATE(MCS8),
-		_M_RATE(MCS9),
-		_M_RATE(MCS10),
-		_M_RATE(MCS11),
-		_M_RATE(MCS12),
-		_M_RATE(MCS13),
-		_M_RATE(MCS14),
-		_M_RATE(MCS15),
-
-		_M_RATE(VHT1SS_MCS0),
-		_M_RATE(VHT1SS_MCS1),
-		_M_RATE(VHT1SS_MCS2),
-		_M_RATE(VHT1SS_MCS3),
-		_M_RATE(VHT1SS_MCS4),
-		_M_RATE(VHT1SS_MCS5),
-		_M_RATE(VHT1SS_MCS6),
-		_M_RATE(VHT1SS_MCS7),
-		_M_RATE(VHT1SS_MCS8),
-		_M_RATE(VHT1SS_MCS9),
-		_M_RATE(VHT2SS_MCS0),
-		_M_RATE(VHT2SS_MCS1),
-		_M_RATE(VHT2SS_MCS2),
-		_M_RATE(VHT2SS_MCS3),
-		_M_RATE(VHT2SS_MCS4),
-		_M_RATE(VHT2SS_MCS5),
-		_M_RATE(VHT2SS_MCS6),
-		_M_RATE(VHT2SS_MCS7),
-		_M_RATE(VHT2SS_MCS8),
-		_M_RATE(VHT2SS_MCS9),
-	};
-#undef _M_RATE
-#undef _M_RATE_SECTION
-#define CHANNELS_NUM	(sizeof(channels)/sizeof(channels[0]))
-#define RATES_NUM	(sizeof(rates)/sizeof(rates[0]))
-
-	enum radio_path path;
-	enum ht_channel_width bandwidth;
-	int rate_idx, channel_idx;
-
-	const struct rtl_rate_info *rate_info;
-	const struct rtl_channel_info *channel_info;
-
-	for (channel_idx = 0; channel_idx < CHANNELS_NUM; channel_idx++) {
-		channel_info = &channels[channel_idx];
-
-		DUMP_TX_POWER_TITLE();
-
-		for (path = 0; path < 2; path++) {
-			for (bandwidth = 0; bandwidth < HT_CHANNEL_WIDTH_MAX;
-			     bandwidth++) {
-
-				if (!(channel_info->bw_mask & BIT(bandwidth)))
-					continue;
-
-				for (rate_idx = 0; rate_idx < RATES_NUM;
-				     rate_idx++) {
-					rate_info = &rates[rate_idx];
-
-					if (!(channel_info->rate_mask &
-					      BIT_ULL(rate_info->rate)))
-						continue;
-
-					dump_tx_power_index_core(rtlpriv, m,
-								 path,
-								 rate_info,
-								 bandwidth,
-								 channel_info);
-				}
-			}
-		}
+	seq_printf(m, "cam entry%d\n", debugfs_priv->cb_data);
+	seq_puts(m, "0x0      0x1      0x2     0x3     ");
+	seq_puts(m, "0x4     0x5\n");
+	mutex_lock(&rtwdev->mutex);
+	for (i = 0; i <= 5; i++) {
+		command = read_cmd | (hw_key_idx + i);
+		rtw_write32(rtwdev, RTW_SEC_CMD_REG, command);
+		val = rtw_read32(rtwdev, RTW_SEC_READ_REG);
+		seq_printf(m, "%8.8x", val);
+		if (i < 2)
+			seq_puts(m, " ");
 	}
+	seq_puts(m, "\n");
+	mutex_unlock(&rtwdev->mutex);
+	return 0;
 }
 
-static void rtl_hex_dump(struct seq_file *m, const char *prefix, int dump_type,
-			 int row, int group, const void *data_void, long size,
-			 bool ascii)
+static int rtw_debugfs_get_rsvd_page(struct seq_file *m, void *v)
 {
-	long i;
-	const u8 *data = data_void;
-	bool last_ch_nl = false;
-
-	seq_printf(m, "%s:\n", prefix);
-
-	for (i = 0; i < size; i++) {
-
-		if ((i % row) == 0)
-			seq_printf(m, "%08lX ", i);
+	struct rtw_debugfs_priv *debugfs_priv = m->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	u8 page_size = rtwdev->chip->page_size;
+	u32 buf_size = debugfs_priv->rsvd_page.page_num * page_size;
+	u32 offset = debugfs_priv->rsvd_page.page_offset * page_size;
+	u8 *buf;
+	int i;
+	int ret;
 
-		seq_printf(m, "%02X ", *data++);
-		last_ch_nl = false;
+	buf = vzalloc(buf_size);
+	if (!buf)
+		return -ENOMEM;
 
-		if ((i % row) == (row - 1)) {
-			seq_puts(m, "\n");
-			last_ch_nl = true;
-		}
+	ret = rtw_dump_drv_rsvd_page(rtwdev, offset, buf_size, (u32 *)buf);
+	if (ret) {
+		rtw_err(rtwdev, "failed to dump rsvd page\n");
+		vfree(buf);
+		return ret;
 	}
 
-	if (last_ch_nl)
-		seq_puts(m, "\n");
-	else
-		seq_puts(m, "\n\n");
-}
-
-static int rtl_debug_get_txpwr(struct seq_file *m, void *v)
-{
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-	struct rtl_phy *rtlphy = &rtlpriv->phy;
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
-
-	/* show regulartory */
-	seq_printf(m, "rtlefuse->eeprom_regulatory=%d\n",
-		   rtlefuse->eeprom_regulatory);
-	seq_printf(m, "\t(%c) != 2: use tx power by rate\n",
-		   rtlefuse->eeprom_regulatory != 2 ? 'O' : 'X');
-	seq_printf(m, "\t(%c) == 1: use tx power limit\n\n",
-		   rtlefuse->eeprom_regulatory == 1 ? 'O' : 'X');
-
-	/* dump tx pwr array */
-#define TXPWR_HEX_DUMP(_x)	\
-	rtl_hex_dump(m, "" #_x, DUMP_PREFIX_NONE,	\
-		     16, 64, _x,	\
-		     sizeof(_x),	\
-		     0)
-
-	/* efuse map */
-	TXPWR_HEX_DUMP(rtlefuse->efuse_map[0]);
-
-	/* tx power base (2.4G) */
-	TXPWR_HEX_DUMP(rtlefuse->txpwrlevel_cck);
-	TXPWR_HEX_DUMP(rtlefuse->txpwrlevel_ht40_1s);
-
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_cckdiff);
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_legacyhtdiff);
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_ht20diff);
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_ht40diff);
-
-	/* tx power base (5G) */
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_5g_bw40base);
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_5g_bw80base);
-
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_5g_ofdmdiff);
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_5g_bw20diff);
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_5g_bw40diff);
-	TXPWR_HEX_DUMP(rtlefuse->txpwr_5g_bw80diff);
-
-	/* tx power by rate */
-	TXPWR_HEX_DUMP(rtlphy->tx_power_by_rate_offset);
-	TXPWR_HEX_DUMP(rtlphy->txpwr_by_rate_base_24g);
-	TXPWR_HEX_DUMP(rtlphy->txpwr_by_rate_base_5g);
-
-	/* tx power limit */
-	TXPWR_HEX_DUMP(rtlphy->txpwr_limit_2_4g);
-	TXPWR_HEX_DUMP(rtlphy->txpwr_limit_5g);
-
-#undef TXPWR_HEX_DUMP
-
-	/* dump txpower index */
-	dump_tx_power_index(rtlpriv, m);
+	for (i = 0 ; i < buf_size ; i += 8) {
+		if (i % page_size == 0)
+			seq_printf(m, "PAGE %d\n", (i + offset) / page_size);
+		seq_printf(m, "%2.2x %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x\n",
+			   *(buf + i), *(buf + i + 1),
+			   *(buf + i + 2), *(buf + i + 3),
+			   *(buf + i + 4), *(buf + i + 5),
+			   *(buf + i + 6), *(buf + i + 7));
+	}
+	vfree(buf);
 
 	return 0;
 }
 
-static int dl_debug_open_txpwr(struct inode *inode, struct file *file)
+static ssize_t rtw_debugfs_set_rsvd_page(struct file *filp,
+					 const char __user *buffer,
+					 size_t count, loff_t *loff)
 {
-	return single_open(file, rtl_debug_get_txpwr,
-			   inode->i_private);
-}
-
-static struct rtl_debugfs_priv rtl_debug_priv_txpwr = {
-	.cb_read = rtl_debug_get_txpwr,
-	.cb_data = 0,
-};
+	struct seq_file *seqpriv = (struct seq_file *)filp->private_data;
+	struct rtw_debugfs_priv *debugfs_priv = seqpriv->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	char tmp[32 + 1];
+	u32 offset, page_num;
+	int num;
 
-static const struct file_operations file_ops_txpwr = {
-	.open = dl_debug_open_txpwr,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = seq_release,
-};
+	rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 2);
 
-static int rtl_debug_get_btcoex(struct seq_file *m, void *v)
-{
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
+	num = sscanf(tmp, "%d %d", &offset, &page_num);
 
-	if (rtlpriv->cfg->ops->get_btc_status())
-		rtlpriv->btcoexist.btc_ops->btc_display_bt_coex_info(rtlpriv,
-								     m);
+	if (num != 2) {
+		rtw_warn(rtwdev, "invalid arguments\n");
+		return num;
+	}
 
-	seq_puts(m, "\n");
+	debugfs_priv->rsvd_page.page_offset = offset;
+	debugfs_priv->rsvd_page.page_num = page_num;
 
-	return 0;
+	return count;
 }
 
-static struct rtl_debugfs_priv rtl_debug_priv_btcoex = {
-	.cb_read = rtl_debug_get_btcoex,
-	.cb_data = 0,
-};
-
-static int rtl_dump_sta_info(struct seq_file *m, void *v)
+static ssize_t rtw_debugfs_set_single_input(struct file *filp,
+					    const char __user *buffer,
+					    size_t count, loff_t *loff)
 {
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-	struct rtl_sta_info *sta = rtlpriv->sta;
-
-	rtlpriv->phydm.ops->phydm_dump_sta_info(rtlpriv, m, sta);
+	struct seq_file *seqpriv = (struct seq_file *)filp->private_data;
+	struct rtw_debugfs_priv *debugfs_priv = seqpriv->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	char tmp[32 + 1];
+	u32 input;
+	int num;
 
-	return 0;
-}
+	rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 1);
 
-static struct rtl_debugfs_priv rtl_debug_priv_dump_sta_info = {
-	.cb_read = rtl_dump_sta_info,
-	.cb_data = 0,
-};
+	num = kstrtoint(tmp, 0, &input);
 
-static int rtl_debug_get_rsvd(struct seq_file *m, void *v)
-{
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-	u32 /*addr = 0, size = 0,*/ count = 0;
-	u32 page_size = 128, data_low = 0, data_high = 0;
-	u16 txbndy = 0, offset = 0;
-	u8 i = 0, j;
-	u8 *data_raw;
-	u32 page_offset = 0;
-	u32 buffer_size = 1280;
-
-#define REG_TDECTRL						0x0208
-#define REG_PKT_BUFF_ACCESS_CTRL		0x0106
-#define REG_PKTBUF_DBG_CTRL			0x0140
-#define REG_PKTBUF_DBG_DATA_L			0x0144
-#define REG_PKTBUF_DBG_DATA_H		0x0148
-
-	txbndy = rtl_read_byte(rtlpriv, REG_TDECTRL + 1);
-
-	offset = (txbndy + page_offset) * page_size / 8;
-	count = (buffer_size / 8);
-
-	rtl_write_byte(rtlpriv, REG_PKT_BUFF_ACCESS_CTRL, 0x69);
-
-	for (i = 0 ; i < count ; i++) {
-		rtl_write_dword(rtlpriv, REG_PKTBUF_DBG_CTRL, offset + i);
-		data_low = rtl_read_dword(rtlpriv, REG_PKTBUF_DBG_DATA_L);
-		data_high = rtl_read_dword(rtlpriv, REG_PKTBUF_DBG_DATA_H);
-
-		if ((i & 0x1) == 0)
-			seq_printf(m, "0x%04X: ", i * 8);
-
-		data_raw = (u8 *)&data_low;
-		for (j = 0; j < 4; j++)
-			seq_printf(m, "%02X ", *(data_raw + j));
-
-		data_raw = (u8 *)&data_high;
-		for (j = 0; j < 4; j++)
-			seq_printf(m, "%02X ", *(data_raw + j));
-
-		if (i & 0x1)
-			seq_puts(m, "\n");
+	if (num) {
+		rtw_warn(rtwdev, "kstrtoint failed\n");
+		return num;
 	}
-	rtl_write_byte(rtlpriv, REG_PKT_BUFF_ACCESS_CTRL, 0x0);
 
-	seq_puts(m, "\n");
+	debugfs_priv->cb_data = input;
 
-	return 0;
+	return count;
 }
 
-static struct rtl_debugfs_priv rtl_debug_priv_rsvd = {
-	.cb_read = rtl_debug_get_rsvd,
-	.cb_data = 0,
-};
-
-static ssize_t rtl_debugfs_set_write_reg(struct file *filp,
+static ssize_t rtw_debugfs_set_write_reg(struct file *filp,
 					 const char __user *buffer,
 					 size_t count, loff_t *loff)
 {
-	struct rtl_debugfs_priv *debugfs_priv = filp->private_data;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
+	struct rtw_debugfs_priv *debugfs_priv = filp->private_data;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
 	char tmp[32 + 1];
-	int tmp_len;
 	u32 addr, val, len;
 	int num;
 
-	if (count < 3)
-		return -EFAULT;
-
-	tmp_len = (count > sizeof(tmp) - 1 ? sizeof(tmp) - 1 : count);
-
-	if (!buffer || copy_from_user(tmp, buffer, tmp_len))
-		return count;
-
-	tmp[tmp_len] = '\0';
+	rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 3);
 
 	/* write BB/MAC register */
 	num = sscanf(tmp, "%x %x %x", &addr, &val, &len);
@@ -2003,351 +320,430 @@ static ssize_t rtl_debugfs_set_write_reg
 
 	switch (len) {
 	case 1:
-		rtl_write_byte(rtlpriv, addr, (u8)val);
+		rtw_dbg(rtwdev, RTW_DBG_DEBUGFS,
+			"reg write8 0x%03x: 0x%08x\n", addr, val);
+		rtw_write8(rtwdev, addr, (u8)val);
 		break;
 	case 2:
-		rtl_write_word(rtlpriv, addr, (u16)val);
+		rtw_dbg(rtwdev, RTW_DBG_DEBUGFS,
+			"reg write16 0x%03x: 0x%08x\n", addr, val);
+		rtw_write16(rtwdev, addr, (u16)val);
 		break;
 	case 4:
-		rtl_write_dword(rtlpriv, addr, val);
+		rtw_dbg(rtwdev, RTW_DBG_DEBUGFS,
+			"reg write32 0x%03x: 0x%08x\n", addr, val);
+		rtw_write32(rtwdev, addr, (u32)val);
 		break;
 	default:
-		/*printk("error write length=%d", len);*/
+		rtw_dbg(rtwdev, RTW_DBG_DEBUGFS,
+			"error write length = %d\n", len);
 		break;
 	}
 
 	return count;
 }
 
-static struct rtl_debugfs_priv rtl_debug_priv_write_reg = {
-	.cb_write = rtl_debugfs_set_write_reg,
-};
-
-static ssize_t rtl_debugfs_set_write_h2c(struct file *filp,
-					 const char __user *buffer,
-					 size_t count, loff_t *loff)
+static ssize_t rtw_debugfs_set_rf_write(struct file *filp,
+					const char __user *buffer,
+					size_t count, loff_t *loff)
 {
-	struct rtl_debugfs_priv *debugfs_priv = filp->private_data;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-	struct ieee80211_hw *hw = rtlpriv->hw;
+	struct rtw_debugfs_priv *debugfs_priv = filp->private_data;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
 	char tmp[32 + 1];
-	int tmp_len;
-	u8 h2c_len, h2c_data_packed[8];
-	int h2c_data[8];	/* idx 0: cmd */
-	int i;
-
-	if (count < 3)
-		return -EFAULT;
-
-	tmp_len = (count > sizeof(tmp) - 1 ? sizeof(tmp) - 1 : count);
-
-	if (!buffer || copy_from_user(tmp, buffer, tmp_len))
-		return count;
+	u32 path, addr, mask, val;
+	int num;
 
-	tmp[tmp_len] = '\0';
+	rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 4);
 
-	h2c_len = sscanf(tmp, "%X %X %X %X %X %X %X %X",
-			 &h2c_data[0], &h2c_data[1],
-			 &h2c_data[2], &h2c_data[3],
-			 &h2c_data[4], &h2c_data[5],
-			 &h2c_data[6], &h2c_data[7]);
+	num = sscanf(tmp, "%x %x %x %x", &path, &addr, &mask, &val);
 
-	if (h2c_len <= 0)
+	if (num !=  4) {
+		rtw_warn(rtwdev, "invalid args, [path] [addr] [mask] [val]\n");
 		return count;
+	}
 
-	for (i = 0; i < h2c_len; i++)
-		h2c_data_packed[i] = (u8)h2c_data[i];
-
-	rtlpriv->cfg->ops->fill_h2c_cmd(hw, h2c_data_packed[0],
-					h2c_len - 1,
-					&h2c_data_packed[1]);
+	rtw_write_rf(rtwdev, path, addr, mask, val);
+	rtw_dbg(rtwdev, RTW_DBG_DEBUGFS,
+		"write_rf path:%d addr:0x%08x mask:0x%08x, val:0x%08x\n",
+		path, addr, mask, val);
 
 	return count;
 }
 
-static struct rtl_debugfs_priv rtl_debug_priv_write_h2c = {
-	.cb_write = rtl_debugfs_set_write_h2c,
-};
-
-static ssize_t rtl_debugfs_set_write_rfreg(struct file *filp,
-					   const char __user *buffer,
-					    size_t count, loff_t *loff)
-{
-	struct rtl_debugfs_priv *debugfs_priv = filp->private_data;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-	struct ieee80211_hw *hw = rtlpriv->hw;
+static ssize_t rtw_debugfs_set_rf_read(struct file *filp,
+				       const char __user *buffer,
+				       size_t count, loff_t *loff)
+{
+	struct seq_file *seqpriv = (struct seq_file *)filp->private_data;
+	struct rtw_debugfs_priv *debugfs_priv = seqpriv->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
 	char tmp[32 + 1];
-	int tmp_len;
+	u32 path, addr, mask;
 	int num;
-	int path;
-	u32 addr, bitmask, data;
-
-	if (count < 3)
-		return -EFAULT;
-
-	tmp_len = (count > sizeof(tmp) - 1 ? sizeof(tmp) - 1 : count);
-
-	if (!buffer || copy_from_user(tmp, buffer, tmp_len))
-		return count;
 
-	tmp[tmp_len] = '\0';
+	rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 3);
 
-	num = sscanf(tmp, "%X %X %X %X",
-		     &path, &addr, &bitmask, &data);
+	num = sscanf(tmp, "%x %x %x", &path, &addr, &mask);
 
-	if (num != 4) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_DMESG,
-			 "Format is <path> <addr> <mask> <data>\n");
+	if (num !=  3) {
+		rtw_warn(rtwdev, "invalid args, [path] [addr] [mask] [val]\n");
 		return count;
 	}
 
-	rtl_set_rfreg(hw, path, addr, bitmask, data);
+	debugfs_priv->rf_path = path;
+	debugfs_priv->rf_addr = addr;
+	debugfs_priv->rf_mask = mask;
 
 	return count;
 }
 
-static struct rtl_debugfs_priv rtl_debug_priv_write_rfreg = {
-	.cb_write = rtl_debugfs_set_write_rfreg,
-};
-
-static int rtl_debugfs_close(struct inode *inode, struct file *filp)
+static int rtw_debug_get_mac_page(struct seq_file *m, void *v)
 {
+	struct rtw_debugfs_priv *debugfs_priv = m->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	u32 val;
+	u32 page = debugfs_priv->cb_data;
+	int i, n;
+	int max = 0xff;
+
+	val = rtw_read32(rtwdev, debugfs_priv->cb_data);
+	for (n = 0; n <= max; ) {
+		seq_printf(m, "\n%8.8x  ", n + page);
+		for (i = 0; i < 4 && n <= max; i++, n += 4)
+			seq_printf(m, "%8.8x    ",
+				   rtw_read32(rtwdev, (page | n)));
+	}
+	seq_puts(m, "\n");
 	return 0;
 }
 
-static ssize_t rtl_debugfs_common_write(struct file *filp,
-					const char __user *buffer,
-					size_t count, loff_t *loff)
+static int rtw_debug_get_bb_page(struct seq_file *m, void *v)
 {
-	struct rtl_debugfs_priv *debugfs_priv = filp->private_data;
+	struct rtw_debugfs_priv *debugfs_priv = m->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	u32 val;
+	u32 page = debugfs_priv->cb_data;
+	int i, n;
+	int max = 0xff;
 
-	return debugfs_priv->cb_write(filp, buffer, count, loff);
+	val = rtw_read32(rtwdev, debugfs_priv->cb_data);
+	for (n = 0; n <= max; ) {
+		seq_printf(m, "\n%8.8x  ", n + page);
+		for (i = 0; i < 4 && n <= max; i++, n += 4)
+			seq_printf(m, "%8.8x    ",
+				   rtw_read32(rtwdev, (page | n)));
+	}
+	seq_puts(m, "\n");
+	return 0;
 }
 
-static const struct file_operations file_ops_common_write = {
-	.owner = THIS_MODULE,
-	.write = rtl_debugfs_common_write,
-	.open = simple_open,
-	.release = rtl_debugfs_close,
-};
-
-static ssize_t rtl_debugfs_phydm_cmd(struct file *filp,
-				     const char __user *buffer,
-				     size_t count, loff_t *loff)
+static int rtw_debug_get_rf_dump(struct seq_file *m, void *v)
 {
-	struct rtl_debugfs_priv *debugfs_priv = filp->private_data;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-
-	char tmp[64];
-
-	if (!rtlpriv->dbg.msg_buf)
-		return -ENOMEM;
-
-	if (!rtlpriv->phydm.ops)
-		return -EFAULT;
-
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
-		tmp[count] = '\0';
-
-		rtlpriv->phydm.ops->phydm_debug_cmd(rtlpriv, tmp, count,
-						    rtlpriv->dbg.msg_buf,
-						    80 * 25);
+	struct rtw_debugfs_priv *debugfs_priv = m->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	u32 addr, offset, data;
+	u8 path;
+
+	for (path = 0; path < rtwdev->hal.rf_path_num; path++) {
+		seq_printf(m, "RF path:%d\n", path);
+		for (addr = 0; addr < 0x100; addr += 4) {
+			seq_printf(m, "%8.8x  ", addr);
+			for (offset = 0; offset < 4; offset++) {
+				data = rtw_read_rf(rtwdev, path, addr + offset,
+						   0xffffffff);
+				seq_printf(m, "%8.8x    ", data);
+			}
+			seq_puts(m, "\n");
+		}
+		seq_puts(m, "\n");
 	}
 
-	return count;
+	return 0;
 }
 
-static int rtl_debug_get_phydm_cmd(struct seq_file *m, void *v)
+static void rtw_print_cck_rate_txt(struct seq_file *m, u8 rate)
 {
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
-
-	if (rtlpriv->dbg.msg_buf)
-		seq_puts(m, rtlpriv->dbg.msg_buf);
+	static const char * const
+	cck_rate[] = {"1M", "2M", "5.5M", "11M"};
+	u8 idx = rate - DESC_RATE1M;
 
-	return 0;
+	seq_printf(m, "%5s%-5s", "CCK_", cck_rate[idx]);
 }
 
-static int rtl_debugfs_open_rw(struct inode *inode, struct file *filp)
+static void rtw_print_ofdm_rate_txt(struct seq_file *m, u8 rate)
 {
-	if (filp->f_mode & FMODE_READ)
-		single_open(filp, rtl_debug_get_common, inode->i_private);
-	else
-		filp->private_data = inode->i_private;
+	static const char * const
+	ofdm_rate[] = {"6M", "9M", "12M", "18M", "24M", "36M", "48M", "54M"};
+	u8 idx = rate - DESC_RATE6M;
 
-	return 0;
+	seq_printf(m, "%6s%-4s", "OFDM_", ofdm_rate[idx]);
 }
 
-static int rtl_debugfs_close_rw(struct inode *inode, struct file *filp)
+static void rtw_print_ht_rate_txt(struct seq_file *m, u8 rate)
 {
-	if (filp->f_mode == FMODE_READ)
-		seq_release(inode, filp);
+	u8 mcs_n = rate - DESC_RATEMCS0;
 
-	return 0;
+	seq_printf(m, "%4s%-6u", "MCS", mcs_n);
 }
 
-static struct rtl_debugfs_priv rtl_debug_priv_phydm_cmd = {
-	.cb_read = rtl_debug_get_phydm_cmd,
-	.cb_write = rtl_debugfs_phydm_cmd,
-	.cb_data = 0,
-};
+static void rtw_print_vht_rate_txt(struct seq_file *m, u8 rate)
+{
+	u8 idx = rate - DESC_RATEVHT1SS_MCS0;
+	u8 n_ss, mcs_n;
 
-static const struct file_operations file_ops_common_rw = {
-	.owner = THIS_MODULE,
-	.open = rtl_debugfs_open_rw,
-	.release = rtl_debugfs_close_rw,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.write = rtl_debugfs_common_write,
-};
+	/* n spatial stream */
+	n_ss = 1 + idx / 10;
+	/* MCS n */
+	mcs_n = idx % 10;
+	seq_printf(m, "%4s%u%s%u", "VHT", n_ss, "SMCS", mcs_n);
+}
 
-static ssize_t rtl_debugfs_dis_turboedca(struct file *filp,
-					 const char __user *buffer,
-					 size_t count, loff_t *loff)
+static int rtw_debugfs_get_tx_pwr_tbl(struct seq_file *m, void *v)
 {
-	struct rtl_debugfs_priv *debugfs_priv = filp->private_data;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
+	struct rtw_debugfs_priv *debugfs_priv = m->private;
+	struct rtw_dev *rtwdev = debugfs_priv->rtwdev;
+	struct rtw_hal *hal = &rtwdev->hal;
+	void (*print_rate)(struct seq_file *, u8) = NULL;
+	u8 path, rate;
+	struct rtw_power_params pwr_param = {0};
+	u8 bw = hal->current_band_width;
+	u8 ch = hal->current_channel;
+	u8 regd = rtwdev->regd.txpwr_regd;
 
-	unsigned long val;
+	seq_printf(m, "%-4s %-10s %-3s%6s %-4s %4s (%-4s %-4s)\n",
+		   "path", "rate", "pwr", "", "base", "", "byr", "lmt");
 
-	if (count > 2 || !buffer)
-		return -EFAULT;
+	mutex_lock(&hal->tx_power_mutex);
+	for (path = RF_PATH_A; path <= RF_PATH_B; path++) {
+		/* there is no CCK rates used in 5G */
+		if (hal->current_band_type == RTW_BAND_5G)
+			rate = DESC_RATE6M;
+		else
+			rate = DESC_RATE1M;
 
-	if (kstrtoul_from_user(buffer, count, 16, &val))
-		return count;
+		/* now, not support vht 3ss and vht 4ss*/
+		for (; rate <= DESC_RATEVHT2SS_MCS9; rate++) {
+			/* now, not support ht 3ss and ht 4ss*/
+			if (rate > DESC_RATEMCS15 &&
+			    rate < DESC_RATEVHT1SS_MCS0)
+				continue;
 
-	rtlpriv->dm.dis_turboedca = (val ? true : false);
+			switch (rate) {
+			case DESC_RATE1M...DESC_RATE11M:
+				print_rate = rtw_print_cck_rate_txt;
+				break;
+			case DESC_RATE6M...DESC_RATE54M:
+				print_rate = rtw_print_ofdm_rate_txt;
+				break;
+			case DESC_RATEMCS0...DESC_RATEMCS15:
+				print_rate = rtw_print_ht_rate_txt;
+				break;
+			case DESC_RATEVHT1SS_MCS0...DESC_RATEVHT2SS_MCS9:
+				print_rate = rtw_print_vht_rate_txt;
+				break;
+			default:
+				print_rate = NULL;
+				break;
+			}
 
-	return count;
-}
+			rtw_get_tx_power_params(rtwdev, path, rate, bw,
+						ch, regd, &pwr_param);
 
-static int rtl_debug_get_dis_turboedca(struct seq_file *m, void *v)
-{
-	struct rtl_debugfs_priv *debugfs_priv = m->private;
-	struct rtl_priv *rtlpriv = debugfs_priv->rtlpriv;
+			seq_printf(m, "%4c ", path + 'A');
+			if (print_rate)
+				print_rate(m, rate);
+			seq_printf(m, " %3u(0x%02x) %4u %4d (%4d %4d)\n",
+				   hal->tx_pwr_tbl[path][rate],
+				   hal->tx_pwr_tbl[path][rate],
+				   pwr_param.pwr_base,
+				   min_t(s8, pwr_param.pwr_offset,
+					 pwr_param.pwr_limit),
+				   pwr_param.pwr_offset, pwr_param.pwr_limit);
+		}
+	}
 
-	seq_printf(m, "Turbo EDCA is %s\n",
-		   rtlpriv->dm.dis_turboedca ? "Disable" : "Enable");
+	mutex_unlock(&hal->tx_power_mutex);
 
 	return 0;
 }
 
-static struct rtl_debugfs_priv rtl_debug_priv_dis_turboedca = {
-	.cb_read = rtl_debug_get_dis_turboedca,
-	.cb_write = rtl_debugfs_dis_turboedca,
-	.cb_data = 0,
+#define rtw_debug_impl_mac(page, addr)				\
+static struct rtw_debugfs_priv rtw_debug_priv_mac_ ##page = {	\
+	.cb_read = rtw_debug_get_mac_page,			\
+	.cb_data = addr,					\
+}
+
+rtw_debug_impl_mac(0, 0x0000);
+rtw_debug_impl_mac(1, 0x0100);
+rtw_debug_impl_mac(2, 0x0200);
+rtw_debug_impl_mac(3, 0x0300);
+rtw_debug_impl_mac(4, 0x0400);
+rtw_debug_impl_mac(5, 0x0500);
+rtw_debug_impl_mac(6, 0x0600);
+rtw_debug_impl_mac(7, 0x0700);
+rtw_debug_impl_mac(10, 0x1000);
+rtw_debug_impl_mac(11, 0x1100);
+rtw_debug_impl_mac(12, 0x1200);
+rtw_debug_impl_mac(13, 0x1300);
+rtw_debug_impl_mac(14, 0x1400);
+rtw_debug_impl_mac(15, 0x1500);
+rtw_debug_impl_mac(16, 0x1600);
+rtw_debug_impl_mac(17, 0x1700);
+
+#define rtw_debug_impl_bb(page, addr)			\
+static struct rtw_debugfs_priv rtw_debug_priv_bb_ ##page = {	\
+	.cb_read = rtw_debug_get_bb_page,			\
+	.cb_data = addr,					\
+}
+
+rtw_debug_impl_bb(8, 0x0800);
+rtw_debug_impl_bb(9, 0x0900);
+rtw_debug_impl_bb(a, 0x0a00);
+rtw_debug_impl_bb(b, 0x0b00);
+rtw_debug_impl_bb(c, 0x0c00);
+rtw_debug_impl_bb(d, 0x0d00);
+rtw_debug_impl_bb(e, 0x0e00);
+rtw_debug_impl_bb(f, 0x0f00);
+rtw_debug_impl_bb(18, 0x1800);
+rtw_debug_impl_bb(19, 0x1900);
+rtw_debug_impl_bb(1a, 0x1a00);
+rtw_debug_impl_bb(1b, 0x1b00);
+rtw_debug_impl_bb(1c, 0x1c00);
+rtw_debug_impl_bb(1d, 0x1d00);
+rtw_debug_impl_bb(1e, 0x1e00);
+rtw_debug_impl_bb(1f, 0x1f00);
+rtw_debug_impl_bb(2c, 0x2c00);
+rtw_debug_impl_bb(2d, 0x2d00);
+rtw_debug_impl_bb(40, 0x4000);
+rtw_debug_impl_bb(41, 0x4100);
+
+static struct rtw_debugfs_priv rtw_debug_priv_rf_dump = {
+	.cb_read = rtw_debug_get_rf_dump,
 };
 
-#define RTL_DEBUGFS_ADD_CORE(name, mode, fopname)			   \
-	do {								   \
-		rtl_debug_priv_ ##name.rtlpriv = rtlpriv;		   \
-		if (!debugfs_create_file(#name, mode,			   \
-					 parent, &rtl_debug_priv_ ##name,  \
-					 &file_ops_ ##fopname))		   \
-			pr_err("Unable to initialize debugfs:%s/%s\n",	   \
-			       rtlpriv->dbg.debugfs_name,		   \
-			       #name);					   \
-	} while (0)
+static struct rtw_debugfs_priv rtw_debug_priv_tx_pwr_tbl = {
+	.cb_read = rtw_debugfs_get_tx_pwr_tbl,
+};
 
-#define RTL_DEBUGFS_ADD(name)						   \
-		RTL_DEBUGFS_ADD_CORE(name, S_IFREG | 0444, common)
-#define RTL_DEBUGFS_ADD_W(name)						   \
-		RTL_DEBUGFS_ADD_CORE(name, S_IFREG | 0222, common_write)
-#define RTL_DEBUGFS_ADD_RW(name)					   \
-		RTL_DEBUGFS_ADD_CORE(name, S_IFREG | 0666, common_rw)
-
-void rtl_debug_add_one(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	struct dentry *parent;
-
-	rtlpriv->dbg.msg_buf = vzalloc(80 * 25);
-
-	snprintf(rtlpriv->dbg.debugfs_name, 18, "%pMF", rtlefuse->dev_addr);
-
-	rtlpriv->dbg.debugfs_dir =
-		debugfs_create_dir(rtlpriv->dbg.debugfs_name, debugfs_topdir);
-	if (!rtlpriv->dbg.debugfs_dir) {
-		pr_err("Unable to init debugfs:/%s/%s\n", rtlpriv->cfg->name,
-		       rtlpriv->dbg.debugfs_name);
-		return;
-	}
+static struct rtw_debugfs_priv rtw_debug_priv_write_reg = {
+	.cb_write = rtw_debugfs_set_write_reg,
+};
 
-	parent = rtlpriv->dbg.debugfs_dir;
+static struct rtw_debugfs_priv rtw_debug_priv_rf_write = {
+	.cb_write = rtw_debugfs_set_rf_write,
+};
 
-	RTL_DEBUGFS_ADD(mac_0);
-	RTL_DEBUGFS_ADD(mac_1);
-	RTL_DEBUGFS_ADD(mac_2);
-	RTL_DEBUGFS_ADD(mac_3);
-	RTL_DEBUGFS_ADD(mac_4);
-	RTL_DEBUGFS_ADD(mac_5);
-	RTL_DEBUGFS_ADD(mac_6);
-	RTL_DEBUGFS_ADD(mac_7);
-	RTL_DEBUGFS_ADD(bb_8);
-	RTL_DEBUGFS_ADD(bb_9);
-	RTL_DEBUGFS_ADD(bb_a);
-	RTL_DEBUGFS_ADD(bb_b);
-	RTL_DEBUGFS_ADD(bb_c);
-	RTL_DEBUGFS_ADD(bb_d);
-	RTL_DEBUGFS_ADD(bb_e);
-	RTL_DEBUGFS_ADD(bb_f);
-	RTL_DEBUGFS_ADD(mac_10);
-	RTL_DEBUGFS_ADD(mac_11);
-	RTL_DEBUGFS_ADD(mac_12);
-	RTL_DEBUGFS_ADD(mac_13);
-	RTL_DEBUGFS_ADD(mac_14);
-	RTL_DEBUGFS_ADD(mac_15);
-	RTL_DEBUGFS_ADD(mac_16);
-	RTL_DEBUGFS_ADD(mac_17);
-	RTL_DEBUGFS_ADD(bb_18);
-	RTL_DEBUGFS_ADD(bb_19);
-	RTL_DEBUGFS_ADD(bb_1a);
-	RTL_DEBUGFS_ADD(bb_1b);
-	RTL_DEBUGFS_ADD(bb_1c);
-	RTL_DEBUGFS_ADD(bb_1d);
-	RTL_DEBUGFS_ADD(bb_1e);
-	RTL_DEBUGFS_ADD(bb_1f);
-	RTL_DEBUGFS_ADD(rf_a);
-	RTL_DEBUGFS_ADD(rf_b);
-
-	RTL_DEBUGFS_ADD(cam_1);
-	RTL_DEBUGFS_ADD(cam_2);
-	RTL_DEBUGFS_ADD(cam_3);
-
-	RTL_DEBUGFS_ADD(txpwr);
-	RTL_DEBUGFS_ADD(btcoex);
-	RTL_DEBUGFS_ADD(dump_sta_info);
-	RTL_DEBUGFS_ADD(rsvd);
-
-	RTL_DEBUGFS_ADD_W(write_reg);
-	RTL_DEBUGFS_ADD_W(write_h2c);
-	RTL_DEBUGFS_ADD_W(write_rfreg);
-
-	RTL_DEBUGFS_ADD_RW(phydm_cmd);
-	RTL_DEBUGFS_ADD_RW(dis_turboedca);
-}
-EXPORT_SYMBOL_GPL(rtl_debug_add_one);
-
-void rtl_debug_remove_one(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	debugfs_remove_recursive(rtlpriv->dbg.debugfs_dir);
-	rtlpriv->dbg.debugfs_dir = NULL;
-
-	vfree(rtlpriv->dbg.msg_buf);
-}
-EXPORT_SYMBOL_GPL(rtl_debug_remove_one);
-
-void rtl_debugfs_add_topdir(void)
-{
-	debugfs_topdir = debugfs_create_dir("rtlwifi", NULL);
-}
+static struct rtw_debugfs_priv rtw_debug_priv_rf_read = {
+	.cb_write = rtw_debugfs_set_rf_read,
+	.cb_read = rtw_debugfs_get_rf_read,
+};
+
+static struct rtw_debugfs_priv rtw_debug_priv_read_reg = {
+	.cb_write = rtw_debugfs_set_read_reg,
+	.cb_read = rtw_debugfs_get_read_reg,
+};
 
-void rtl_debugfs_remove_topdir(void)
+static struct rtw_debugfs_priv rtw_debug_priv_dump_cam = {
+	.cb_write = rtw_debugfs_set_single_input,
+	.cb_read = rtw_debugfs_get_dump_cam,
+};
+
+static struct rtw_debugfs_priv rtw_debug_priv_rsvd_page = {
+	.cb_write = rtw_debugfs_set_rsvd_page,
+	.cb_read = rtw_debugfs_get_rsvd_page,
+};
+
+#define rtw_debugfs_add_core(name, mode, fopname, parent)		\
+	do {								\
+		rtw_debug_priv_ ##name.rtwdev = rtwdev;			\
+		if (!debugfs_create_file(#name, mode,			\
+					 parent, &rtw_debug_priv_ ##name,\
+					 &file_ops_ ##fopname))		\
+			pr_debug("Unable to initialize debugfs:%s\n",	\
+			       #name);					\
+	} while (0)
+
+#define rtw_debugfs_add_w(name)						\
+	rtw_debugfs_add_core(name, S_IFREG | 0222, common_write, debugfs_topdir)
+#define rtw_debugfs_add_rw(name)					\
+	rtw_debugfs_add_core(name, S_IFREG | 0666, single_rw, debugfs_topdir)
+#define rtw_debugfs_add_r(name)						\
+	rtw_debugfs_add_core(name, S_IFREG | 0444, single_r, debugfs_topdir)
+
+void rtw_debugfs_init(struct rtw_dev *rtwdev)
+{
+	struct dentry *debugfs_topdir = rtwdev->debugfs;
+
+	debugfs_topdir = debugfs_create_dir("rtw88",
+					    rtwdev->hw->wiphy->debugfsdir);
+	rtw_debugfs_add_w(write_reg);
+	rtw_debugfs_add_rw(read_reg);
+	rtw_debugfs_add_w(rf_write);
+	rtw_debugfs_add_rw(rf_read);
+	rtw_debugfs_add_rw(dump_cam);
+	rtw_debugfs_add_rw(rsvd_page);
+	rtw_debugfs_add_r(mac_0);
+	rtw_debugfs_add_r(mac_1);
+	rtw_debugfs_add_r(mac_2);
+	rtw_debugfs_add_r(mac_3);
+	rtw_debugfs_add_r(mac_4);
+	rtw_debugfs_add_r(mac_5);
+	rtw_debugfs_add_r(mac_6);
+	rtw_debugfs_add_r(mac_7);
+	rtw_debugfs_add_r(bb_8);
+	rtw_debugfs_add_r(bb_9);
+	rtw_debugfs_add_r(bb_a);
+	rtw_debugfs_add_r(bb_b);
+	rtw_debugfs_add_r(bb_c);
+	rtw_debugfs_add_r(bb_d);
+	rtw_debugfs_add_r(bb_e);
+	rtw_debugfs_add_r(bb_f);
+	rtw_debugfs_add_r(mac_10);
+	rtw_debugfs_add_r(mac_11);
+	rtw_debugfs_add_r(mac_12);
+	rtw_debugfs_add_r(mac_13);
+	rtw_debugfs_add_r(mac_14);
+	rtw_debugfs_add_r(mac_15);
+	rtw_debugfs_add_r(mac_16);
+	rtw_debugfs_add_r(mac_17);
+	rtw_debugfs_add_r(bb_18);
+	rtw_debugfs_add_r(bb_19);
+	rtw_debugfs_add_r(bb_1a);
+	rtw_debugfs_add_r(bb_1b);
+	rtw_debugfs_add_r(bb_1c);
+	rtw_debugfs_add_r(bb_1d);
+	rtw_debugfs_add_r(bb_1e);
+	rtw_debugfs_add_r(bb_1f);
+	if (rtwdev->chip->id == RTW_CHIP_TYPE_8822C) {
+		rtw_debugfs_add_r(bb_2c);
+		rtw_debugfs_add_r(bb_2d);
+		rtw_debugfs_add_r(bb_40);
+		rtw_debugfs_add_r(bb_41);
+	}
+	rtw_debugfs_add_r(rf_dump);
+	rtw_debugfs_add_r(tx_pwr_tbl);
+}
+
+#endif /* CONFIG_RTW88_DEBUGFS */
+
+#ifdef CONFIG_RTW88_DEBUG
+
+void __rtw_dbg(struct rtw_dev *rtwdev, enum rtw_debug_mask mask,
+	       const char *fmt, ...)
 {
-	debugfs_remove_recursive(debugfs_topdir);
+	struct va_format vaf = {
+		.fmt = fmt,
+	};
+	va_list args;
+
+	va_start(args, fmt);
+	vaf.va = &args;
+
+	if (rtw_debug_mask & mask)
+		dev_printk(KERN_DEBUG, rtwdev->dev, "%pV", &vaf);
+
+	va_end(args);
 }
+EXPORT_SYMBOL(__rtw_dbg);
 
-#endif
+#endif /* CONFIG_RTW88_DEBUG */
diff -upr /home/finger/rtlwifi_new1/debug.h drivers/net/wireless/realtek/rtw88/debug.h
--- /home/finger/rtlwifi_new1/debug.h	2019-06-14 10:13:19.898404584 -0500
+++ drivers/net/wireless/realtek/rtw88/debug.h	2019-05-29 10:27:03.755295149 -0500
@@ -1,241 +1,52 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *****************************************************************************/
-
-#ifndef __RTL_DEBUG_H__
-#define __RTL_DEBUG_H__
-
-/*--------------------------------------------------------------
-			Debug level
---------------------------------------------------------------*/
-/*
- *Fatal bug.
- *For example, Tx/Rx/IO locked up,
- *memory access violation,
- *resource allocation failed,
- *unexpected HW behavior, HW BUG
- *and so on.
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright(c) 2018-2019  Realtek Corporation
  */
-/*#define DBG_EMERG			0 */
 
-/*
- *Abnormal, rare, or unexpeted cases.
- *For example, Packet/IO Ctl canceled,
- *device suprisely unremoved and so on.
- */
-#define	DBG_WARNING			2
-
-/*
- *Normal case driver developer should
- *open, we can see link status like
- *assoc/AddBA/DHCP/adapter start and
- *so on basic and useful infromations.
- */
-#define DBG_DMESG			3
-
-/*
- *Normal case with useful information
- *about current SW or HW state.
- *For example, Tx/Rx descriptor to fill,
- *Tx/Rx descriptor completed status,
- *SW protocol state change, dynamic
- *mechanism state change and so on.
- */
-#define DBG_LOUD			4
-
-/*
- *Normal case with detail execution
- *flow or information.
- */
-#define	DBG_TRACE			5
+#ifndef __RTW_DEBUG_H
+#define __RTW_DEBUG_H
 
-#ifndef BIT_ULL
-#define BIT_ULL(nr)              (1ULL << (nr))
-#endif
+enum rtw_debug_mask {
+	RTW_DBG_PCI		= 0x00000001,
+	RTW_DBG_TX		= 0x00000002,
+	RTW_DBG_RX		= 0x00000004,
+	RTW_DBG_PHY		= 0x00000008,
+	RTW_DBG_FW		= 0x00000010,
+	RTW_DBG_EFUSE		= 0x00000020,
+	RTW_DBG_COEX		= 0x00000040,
+	RTW_DBG_RFK		= 0x00000080,
+	RTW_DBG_REGD		= 0x00000100,
+	RTW_DBG_DEBUGFS		= 0x00000200,
 
-/*--------------------------------------------------------------
-		Define the rt_trace components
---------------------------------------------------------------*/
-#define COMP_ERR			BIT(0)
-#define COMP_FW				BIT(1)
-#define COMP_INIT			BIT(2)	/*For init/deinit */
-#define COMP_RECV			BIT(3)	/*For Rx. */
-#define COMP_SEND			BIT(4)	/*For Tx. */
-#define COMP_MLME			BIT(5)	/*For MLME. */
-#define COMP_SCAN			BIT(6)	/*For Scan. */
-#define COMP_INTR			BIT(7)	/*For interrupt Related. */
-#define COMP_LED			BIT(8)	/*For LED. */
-#define COMP_SEC			BIT(9)	/*For sec. */
-#define COMP_BEACON			BIT(10)	/*For beacon. */
-#define COMP_RATE			BIT(11)	/*For rate. */
-#define COMP_RXDESC			BIT(12)	/*For rx desc. */
-#define COMP_DIG			BIT(13)	/*For DIG */
-#define COMP_TXAGC			BIT(14)	/*For Tx power */
-#define COMP_HIPWR			BIT(15)	/*For High Power Mechanism */
-#define COMP_POWER			BIT(16)	/*For lps/ips/aspm. */
-#define COMP_POWER_TRACKING	BIT(17)	/*For TX POWER TRACKING */
-#define COMP_BB_POWERSAVING	BIT(18)
-#define COMP_SWAS			BIT(19)	/*For SW Antenna Switch */
-#define COMP_RF				BIT(20)	/*For RF. */
-#define COMP_TURBO			BIT(21)	/*For EDCA TURBO. */
-#define COMP_RATR			BIT(22)
-#define COMP_CMD			BIT(23)
-#define COMP_EFUSE			BIT(24)
-#define COMP_QOS			BIT(25)
-#define COMP_MAC80211		BIT(26)
-#define COMP_REGD			BIT(27)
-#define COMP_CHAN			BIT(28)
-#define COMP_USB			BIT(29)
-#define COMP_EASY_CONCURRENT	COMP_USB /* reuse of this bit is OK */
-#define COMP_BT_COEXIST			BIT(30)
-#define COMP_IQK			BIT(31)
-#define COMP_TX_REPORT			BIT_ULL(32)
-#define COMP_VENDOR_CMD			BIT_ULL(33)
-#define COMP_HALMAC			BIT_ULL(34)
-#define COMP_PHYDM			BIT_ULL(35)
-
-/*--------------------------------------------------------------
-		Define the rt_print components
---------------------------------------------------------------*/
-/* Define EEPROM and EFUSE  check module bit*/
-#define EEPROM_W			BIT(0)
-#define EFUSE_PG			BIT(1)
-#define EFUSE_READ_ALL			BIT(2)
-
-/* Define init check for module bit*/
-#define	INIT_EEPROM			BIT(0)
-#define	INIT_TXPOWER			BIT(1)
-#define	INIT_IQK			BIT(2)
-#define	INIT_RF				BIT(3)
-
-/* Define PHY-BB/RF/MAC check module bit */
-#define	PHY_BBR				BIT(0)
-#define	PHY_BBW				BIT(1)
-#define	PHY_RFR				BIT(2)
-#define	PHY_RFW				BIT(3)
-#define	PHY_MACR			BIT(4)
-#define	PHY_MACW			BIT(5)
-#define	PHY_ALLR			BIT(6)
-#define	PHY_ALLW			BIT(7)
-#define	PHY_TXPWR			BIT(8)
-#define	PHY_PWRDIFF			BIT(9)
-
-/* Define Dynamic Mechanism check module bit --> FDM */
-#define WA_IOT				BIT(0)
-#define DM_PWDB				BIT(1)
-#define DM_MONITOR			BIT(2)
-#define DM_DIG				BIT(3)
-#define DM_EDCA_TURBO			BIT(4)
-
-#define DM_PWDB				BIT(1)
-
-enum dbgp_flag_e {
-	FQOS = 0,
-	FTX = 1,
-	FRX = 2,
-	FSEC = 3,
-	FMGNT = 4,
-	FMLME = 5,
-	FRESOURCE = 6,
-	FBEACON = 7,
-	FISR = 8,
-	FPHY = 9,
-	FMP = 10,
-	FEEPROM = 11,
-	FPWR = 12,
-	FDM = 13,
-	FDBGCtrl = 14,
-	FC2H = 15,
-	FBT = 16,
-	FINIT = 17,
-	FIOCTL = 18,
-	DBGP_TYPE_MAX
+	RTW_DBG_ALL		= 0xffffffff
 };
 
-#ifdef CONFIG_RTLWIFI_DEBUG
+#ifdef CONFIG_RTW88_DEBUGFS
 
-struct rtl_priv;
+void rtw_debugfs_init(struct rtw_dev *rtwdev);
 
-__printf(4, 5)
-void _rtl_dbg_trace(struct rtl_priv *rtlpriv, u64 comp, int level,
-		    const char *fmt, ...);
+#else
 
-__printf(4, 5)
-void _rtl_dbg_print(struct rtl_priv *rtlpriv, u64 comp, int level,
-		    const char *fmt, ...);
+static inline void rtw_debugfs_init(struct rtw_dev *rtwdev) {}
 
-void _rtl_dbg_print_data(struct rtl_priv *rtlpriv, u64 comp, int level,
-			 const char *titlestring,
-			 const void *hexdata, int hexdatalen);
+#endif /* CONFIG_RTW88_DEBUGFS */
 
-#define RT_TRACE(rtlpriv, comp, level, fmt, ...)			\
-	_rtl_dbg_trace(rtlpriv, comp, level,				\
-		       fmt, ##__VA_ARGS__)
+#ifdef CONFIG_RTW88_DEBUG
 
-#define RTPRINT(rtlpriv, dbgtype, dbgflag, fmt, ...)			\
-	_rtl_dbg_print(rtlpriv, dbgtype, dbgflag, fmt, ##__VA_ARGS__)
+__printf(3, 4)
+void __rtw_dbg(struct rtw_dev *rtwdev, enum rtw_debug_mask mask,
+	       const char *fmt, ...);
 
-#define RT_PRINT_DATA(rtlpriv, _comp, _level, _titlestring, _hexdata,	\
-		      _hexdatalen)					\
-	_rtl_dbg_print_data(rtlpriv, _comp, _level,			\
-			    _titlestring, _hexdata, _hexdatalen)
+#define rtw_dbg(rtwdev, a...) __rtw_dbg(rtwdev, ##a)
 
 #else
 
-struct rtl_priv;
+static inline void rtw_dbg(struct rtw_dev *rtwdev, enum rtw_debug_mask mask,
+			   const char *fmt, ...) {}
 
-__printf(4, 5)
-static inline void RT_TRACE(struct rtl_priv *rtlpriv,
-			    u64 comp, int level,
-			    const char *fmt, ...)
-{
-}
-
-__printf(4, 5)
-static inline void RTPRINT(struct rtl_priv *rtlpriv,
-			   int dbgtype, int dbgflag,
-			   const char *fmt, ...)
-{
-}
-
-static inline void RT_PRINT_DATA(struct rtl_priv *rtlpriv,
-				 u64 comp, int level,
-				 const char *titlestring,
-				 const void *hexdata, size_t hexdatalen)
-{
-}
+#endif /* CONFIG_RTW88_DEBUG */
 
-#endif
+#define rtw_info(rtwdev, a...) dev_info(rtwdev->dev, ##a)
+#define rtw_warn(rtwdev, a...) dev_warn(rtwdev->dev, ##a)
+#define rtw_err(rtwdev, a...) dev_err(rtwdev->dev, ##a)
 
-#ifdef CONFIG_RTLWIFI_DEBUG
-void rtl_debug_add_one(struct ieee80211_hw *hw);
-void rtl_debug_remove_one(struct ieee80211_hw *hw);
-void rtl_debugfs_add_topdir(void);
-void rtl_debugfs_remove_topdir(void);
-#else
-#define rtl_debug_add_one(hw)
-#define rtl_debug_remove_one(hw)
-#define rtl_debugfs_add_topdir()
-#define rtl_debugfs_remove_topdir()
-#endif
 #endif
Only in drivers/net/wireless/realtek/rtw88/: debug.o
Only in drivers/net/wireless/realtek/rtw88/: .debug.o.cmd
diff -upr /home/finger/rtlwifi_new1/.debug.o.d drivers/net/wireless/realtek/rtw88/.debug.o.d
--- /home/finger/rtlwifi_new1/.debug.o.d	2019-06-14 10:01:32.607249404 -0500
+++ drivers/net/wireless/realtek/rtw88/.debug.o.d	2019-06-14 20:50:58.122333861 -0500
@@ -1,13 +1,14 @@
-debug.o: /home/finger/rtlwifi_new1/debug.c include/linux/kconfig.h \
- include/generated/autoconf.h include/linux/compiler_types.h \
- include/linux/compiler_attributes.h include/linux/compiler-gcc.h \
- include/linux/debugfs.h include/linux/fs.h include/linux/linkage.h \
- include/linux/compiler_types.h include/linux/stringify.h \
- include/linux/export.h arch/x86/include/asm/linkage.h \
- include/linux/wait_bit.h include/linux/wait.h include/linux/list.h \
- include/linux/types.h include/uapi/linux/types.h \
- arch/x86/include/uapi/asm/types.h include/uapi/asm-generic/types.h \
- include/asm-generic/int-ll64.h include/uapi/asm-generic/int-ll64.h \
+debug.o: drivers/net/wireless/realtek/rtw88/debug.c \
+ include/linux/kconfig.h include/generated/autoconf.h \
+ include/linux/compiler_types.h include/linux/compiler_attributes.h \
+ include/linux/compiler-gcc.h include/linux/debugfs.h include/linux/fs.h \
+ include/linux/linkage.h include/linux/compiler_types.h \
+ include/linux/stringify.h include/linux/export.h \
+ arch/x86/include/asm/linkage.h include/linux/wait_bit.h \
+ include/linux/wait.h include/linux/list.h include/linux/types.h \
+ include/uapi/linux/types.h arch/x86/include/uapi/asm/types.h \
+ include/uapi/asm-generic/types.h include/asm-generic/int-ll64.h \
+ include/uapi/asm-generic/int-ll64.h \
  arch/x86/include/uapi/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h include/uapi/asm-generic/bitsperlong.h \
  include/uapi/linux/posix_types.h include/linux/stddef.h \
@@ -66,17 +67,11 @@ debug.o: /home/finger/rtlwifi_new1/debug
  arch/x86/include/uapi/asm/processor-flags.h \
  arch/x86/include/asm/math_emu.h arch/x86/include/asm/ptrace.h \
  arch/x86/include/asm/segment.h arch/x86/include/uapi/asm/ptrace.h \
- arch/x86/include/uapi/asm/ptrace-abi.h \
- arch/x86/include/asm/paravirt_types.h arch/x86/include/asm/desc_defs.h \
- arch/x86/include/asm/kmap_types.h include/asm-generic/kmap_types.h \
+ arch/x86/include/uapi/asm/ptrace-abi.h include/asm-generic/ptrace.h \
+ arch/x86/include/uapi/asm/sigcontext.h \
  arch/x86/include/asm/pgtable_types.h \
  arch/x86/include/asm/pgtable_64_types.h arch/x86/include/asm/sparsemem.h \
- include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/nospec-branch.h \
- include/linux/static_key.h arch/x86/include/asm/alternative-asm.h \
- arch/x86/include/asm/msr-index.h arch/x86/include/asm/spinlock_types.h \
- include/asm-generic/qspinlock_types.h \
- include/asm-generic/qrwlock_types.h include/asm-generic/ptrace.h \
- arch/x86/include/uapi/asm/sigcontext.h arch/x86/include/asm/msr.h \
+ include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/msr.h \
  arch/x86/include/asm/msr-index.h arch/x86/include/uapi/asm/errno.h \
  include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
  arch/x86/include/asm/cpumask.h include/linux/cpumask.h \
@@ -88,34 +83,38 @@ debug.o: /home/finger/rtlwifi_new1/debug
  include/asm-generic/atomic-instrumented.h \
  include/linux/tracepoint-defs.h include/linux/atomic.h \
  include/linux/atomic-fallback.h include/asm-generic/atomic-long.h \
- include/linux/errno.h include/uapi/linux/errno.h \
+ include/linux/static_key.h include/linux/errno.h \
+ include/uapi/linux/errno.h arch/x86/include/asm/desc_defs.h \
  arch/x86/include/asm/special_insns.h arch/x86/include/asm/fpu/types.h \
  arch/x86/include/asm/unwind_hints.h arch/x86/include/asm/orc_types.h \
  include/linux/personality.h include/uapi/linux/personality.h \
  include/linux/err.h include/linux/irqflags.h \
- arch/x86/include/asm/irqflags.h include/linux/bottom_half.h \
- arch/x86/include/generated/asm/mmiowb.h include/asm-generic/mmiowb.h \
- include/linux/spinlock_types.h include/linux/lockdep.h \
+ arch/x86/include/asm/irqflags.h arch/x86/include/asm/nospec-branch.h \
+ arch/x86/include/asm/alternative-asm.h arch/x86/include/asm/msr-index.h \
+ include/linux/bottom_half.h arch/x86/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h include/linux/spinlock_types.h \
+ arch/x86/include/asm/spinlock_types.h \
+ include/asm-generic/qspinlock_types.h \
+ include/asm-generic/qrwlock_types.h include/linux/lockdep.h \
  include/linux/rwlock_types.h arch/x86/include/asm/spinlock.h \
- arch/x86/include/asm/paravirt.h arch/x86/include/asm/frame.h \
- arch/x86/include/asm/qspinlock.h include/asm-generic/qspinlock.h \
- arch/x86/include/asm/qrwlock.h include/asm-generic/qrwlock.h \
- include/linux/rwlock.h include/linux/spinlock_api_smp.h \
- include/linux/rwlock_api_smp.h include/uapi/linux/wait.h \
- include/linux/kdev_t.h include/uapi/linux/kdev_t.h \
- include/linux/dcache.h include/linux/rculist.h include/linux/rcupdate.h \
- include/linux/rcutree.h include/linux/rculist_bl.h \
- include/linux/list_bl.h include/linux/bit_spinlock.h \
- include/linux/seqlock.h include/linux/lockref.h \
- include/generated/bounds.h include/linux/stringhash.h \
- include/linux/hash.h include/linux/path.h include/linux/stat.h \
- arch/x86/include/uapi/asm/stat.h include/uapi/linux/stat.h \
- include/linux/time.h include/linux/time32.h include/linux/timex.h \
- include/uapi/linux/timex.h include/uapi/linux/param.h \
- arch/x86/include/uapi/asm/param.h include/asm-generic/param.h \
- include/uapi/asm-generic/param.h arch/x86/include/asm/timex.h \
- arch/x86/include/asm/tsc.h include/linux/uidgid.h \
- include/linux/highuid.h include/linux/list_lru.h \
+ arch/x86/include/asm/paravirt.h arch/x86/include/asm/qspinlock.h \
+ include/asm-generic/qspinlock.h arch/x86/include/asm/qrwlock.h \
+ include/asm-generic/qrwlock.h include/linux/rwlock.h \
+ include/linux/spinlock_api_smp.h include/linux/rwlock_api_smp.h \
+ include/uapi/linux/wait.h include/linux/kdev_t.h \
+ include/uapi/linux/kdev_t.h include/linux/dcache.h \
+ include/linux/rculist.h include/linux/rcupdate.h include/linux/rcutree.h \
+ include/linux/rculist_bl.h include/linux/list_bl.h \
+ include/linux/bit_spinlock.h include/linux/seqlock.h \
+ include/linux/lockref.h include/generated/bounds.h \
+ include/linux/stringhash.h include/linux/hash.h include/linux/path.h \
+ include/linux/stat.h arch/x86/include/uapi/asm/stat.h \
+ include/uapi/linux/stat.h include/linux/time.h include/linux/time32.h \
+ include/linux/timex.h include/uapi/linux/timex.h \
+ include/uapi/linux/param.h arch/x86/include/uapi/asm/param.h \
+ include/asm-generic/param.h include/uapi/asm-generic/param.h \
+ arch/x86/include/asm/timex.h arch/x86/include/asm/tsc.h \
+ include/linux/uidgid.h include/linux/highuid.h include/linux/list_lru.h \
  include/linux/nodemask.h include/linux/numa.h include/linux/shrinker.h \
  include/linux/llist.h include/linux/radix-tree.h include/linux/xarray.h \
  include/linux/gfp.h include/linux/mmdebug.h include/linux/mmzone.h \
@@ -125,15 +124,15 @@ debug.o: /home/finger/rtlwifi_new1/debug
  include/uapi/linux/auxvec.h arch/x86/include/uapi/asm/auxvec.h \
  include/linux/rbtree.h include/linux/rwsem.h include/linux/osq_lock.h \
  include/linux/completion.h include/linux/uprobes.h \
+ arch/x86/include/asm/uprobes.h include/linux/notifier.h \
+ include/linux/mutex.h include/linux/debug_locks.h include/linux/srcu.h \
  include/linux/workqueue.h include/linux/timer.h include/linux/ktime.h \
  include/linux/jiffies.h include/generated/timeconst.h \
  include/linux/timekeeping.h include/linux/timekeeping32.h \
- include/linux/debugobjects.h arch/x86/include/asm/mmu.h \
- include/linux/mutex.h include/linux/debug_locks.h \
- include/linux/page-flags.h include/linux/memory_hotplug.h \
- include/linux/notifier.h include/linux/srcu.h \
- include/linux/rcu_segcblist.h include/linux/srcutree.h \
- include/linux/rcu_node_tree.h arch/x86/include/asm/mmzone.h \
+ include/linux/debugobjects.h include/linux/rcu_segcblist.h \
+ include/linux/srcutree.h include/linux/rcu_node_tree.h \
+ arch/x86/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h arch/x86/include/asm/mmzone.h \
  arch/x86/include/asm/mmzone_64.h arch/x86/include/asm/smp.h \
  arch/x86/include/asm/mpspec.h arch/x86/include/asm/mpspec_def.h \
  arch/x86/include/asm/x86_init.h arch/x86/include/asm/apicdef.h \
@@ -193,10 +192,9 @@ debug.o: /home/finger/rtlwifi_new1/debug
  include/linux/seq_file.h include/linux/cred.h include/linux/key.h \
  include/linux/sysctl.h include/uapi/linux/sysctl.h \
  include/linux/assoc_array.h include/linux/sched/user.h \
- include/linux/ratelimit.h /home/finger/rtlwifi_new1/main.h \
- include/generated/uapi/linux/version.h include/net/mac80211.h \
- include/linux/if_ether.h include/linux/skbuff.h include/linux/socket.h \
- arch/x86/include/generated/uapi/asm/socket.h \
+ include/linux/ratelimit.h drivers/net/wireless/realtek/rtw88/main.h \
+ include/net/mac80211.h include/linux/if_ether.h include/linux/skbuff.h \
+ include/linux/socket.h arch/x86/include/generated/uapi/asm/socket.h \
  include/uapi/asm-generic/socket.h \
  arch/x86/include/generated/uapi/asm/sockios.h \
  include/uapi/asm-generic/sockios.h include/uapi/linux/sockios.h \
@@ -277,9 +275,8 @@ debug.o: /home/finger/rtlwifi_new1/debug
  include/linux/cgroup-defs.h include/linux/bpf-cgroup.h \
  include/linux/bpf.h include/uapi/linux/bpf.h \
  include/uapi/linux/bpf_common.h include/linux/file.h \
- include/linux/rbtree_latch.h include/linux/bpf_types.h \
- include/linux/psi_types.h include/linux/kthread.h \
- include/linux/cgroup_subsys.h include/net/xdp.h \
+ include/linux/rbtree_latch.h include/linux/psi_types.h \
+ include/linux/kthread.h include/linux/cgroup_subsys.h include/net/xdp.h \
  include/uapi/linux/neighbour.h include/linux/netlink.h include/net/scm.h \
  include/linux/security.h include/linux/sched/signal.h \
  include/linux/signal.h include/linux/sched/jobctl.h \
@@ -304,13 +301,11 @@ debug.o: /home/finger/rtlwifi_new1/debug
  include/linux/vmpressure.h include/linux/eventfd.h \
  include/linux/writeback.h include/linux/flex_proportions.h \
  include/linux/backing-dev-defs.h include/linux/blk_types.h \
- include/linux/bvec.h include/linux/bio.h include/linux/highmem.h \
- arch/x86/include/asm/cacheflush.h include/asm-generic/cacheflush.h \
- include/linux/mempool.h include/linux/filter.h \
- include/linux/cryptohash.h include/linux/set_memory.h \
- arch/x86/include/asm/set_memory.h include/asm-generic/set_memory.h \
- include/linux/kallsyms.h include/linux/module.h include/linux/kmod.h \
- include/linux/umh.h include/linux/elf.h arch/x86/include/asm/elf.h \
+ include/linux/bvec.h include/linux/filter.h include/linux/cryptohash.h \
+ include/linux/set_memory.h arch/x86/include/asm/set_memory.h \
+ include/asm-generic/set_memory.h include/linux/kallsyms.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/x86/include/asm/elf.h \
  arch/x86/include/asm/fsgsbase.h arch/x86/include/asm/vdso.h \
  include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
  include/linux/moduleparam.h include/linux/error-injection.h \
@@ -332,6 +327,9 @@ debug.o: /home/finger/rtlwifi_new1/debug
  include/uapi/linux/tcp.h include/linux/udp.h include/uapi/linux/udp.h \
  include/net/ieee80211_radiotap.h include/linux/firmware.h \
  include/linux/average.h include/linux/bitfield.h \
- /home/finger/rtlwifi_new1/util.h /home/finger/rtlwifi_new1/hci.h \
- /home/finger/rtlwifi_new1/sec.h /home/finger/rtlwifi_new1/fw.h \
- /home/finger/rtlwifi_new1/debug.h
+ drivers/net/wireless/realtek/rtw88/util.h \
+ drivers/net/wireless/realtek/rtw88/hci.h \
+ drivers/net/wireless/realtek/rtw88/sec.h \
+ drivers/net/wireless/realtek/rtw88/fw.h \
+ drivers/net/wireless/realtek/rtw88/debug.h \
+ drivers/net/wireless/realtek/rtw88/phy.h
Only in /home/finger/rtlwifi_new1/: dkms.conf
diff -upr /home/finger/rtlwifi_new1/efuse.c drivers/net/wireless/realtek/rtw88/efuse.c
--- /home/finger/rtlwifi_new1/efuse.c	2019-06-14 10:13:19.898404584 -0500
+++ drivers/net/wireless/realtek/rtw88/efuse.c	2019-05-29 10:27:03.755295149 -0500
@@ -1,1382 +1,160 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * Tmis program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * Tmis program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * Tme full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#include "wifi.h"
-#include "efuse.h"
-#include "pci.h"
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-#include <linux/export.h>
-#endif
-
-static const u8 MAX_PGPKT_SIZE = 9;
-static const u8 PGPKT_DATA_SIZE = 8;
-static const int EFUSE_MAX_SIZE = 512;
-
-#define START_ADDRESS		0x1000
-#define REG_MCUFWDL		0x0080
-
-static const struct efuse_map RTL8712_SDIO_EFUSE_TABLE[] = {
-	{0, 0, 0, 2},
-	{0, 1, 0, 2},
-	{0, 2, 0, 2},
-	{1, 0, 0, 1},
-	{1, 0, 1, 1},
-	{1, 1, 0, 1},
-	{1, 1, 1, 3},
-	{1, 3, 0, 17},
-	{3, 3, 1, 48},
-	{10, 0, 0, 6},
-	{10, 3, 0, 1},
-	{10, 3, 1, 1},
-	{11, 0, 0, 28}
-};
-
-static const struct rtl_efuse_ops efuse_ops = {
-	.efuse_onebyte_read = efuse_one_byte_read,
-	.efuse_logical_map_read = efuse_shadow_read,
-};
-
-static void efuse_shadow_read_1byte(struct ieee80211_hw *hw, u16 offset,
-				    u8 *value);
-static void efuse_shadow_read_2byte(struct ieee80211_hw *hw, u16 offset,
-				    u16 *value);
-static void efuse_shadow_read_4byte(struct ieee80211_hw *hw, u16 offset,
-				    u32 *value);
-static void efuse_shadow_write_1byte(struct ieee80211_hw *hw, u16 offset,
-				     u8 value);
-static void efuse_shadow_write_2byte(struct ieee80211_hw *hw, u16 offset,
-				     u16 value);
-static void efuse_shadow_write_4byte(struct ieee80211_hw *hw, u16 offset,
-				     u32 value);
-static int efuse_one_byte_write(struct ieee80211_hw *hw, u16 addr,
-				u8 data);
-static void efuse_read_all_map(struct ieee80211_hw *hw, u8 *efuse);
-static int efuse_pg_packet_read(struct ieee80211_hw *hw, u8 offset,
-				u8 *data);
-static int efuse_pg_packet_write(struct ieee80211_hw *hw, u8 offset,
-				 u8 word_en, u8 *data);
-static void efuse_word_enable_data_read(u8 word_en, u8 *sourdata,
-					u8 *targetdata);
-static u8 enable_efuse_data_write(struct ieee80211_hw *hw,
-				  u16 efuse_addr, u8 word_en, u8 *data);
-static u16 efuse_get_current_size(struct ieee80211_hw *hw);
-static u8 efuse_calculate_word_cnts(u8 word_en);
-
-void efuse_initialize(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u8 bytetemp;
-	u8 temp;
-
-	bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[SYS_FUNC_EN] + 1);
-	temp = bytetemp | 0x20;
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[SYS_FUNC_EN] + 1, temp);
-
-	bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[SYS_ISO_CTRL] + 1);
-	temp = bytetemp & 0xFE;
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[SYS_ISO_CTRL] + 1, temp);
-
-	bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST] + 3);
-	temp = bytetemp | 0x80;
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST] + 3, temp);
-
-	rtl_write_byte(rtlpriv, 0x2F8, 0x3);
-
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3, 0x72);
-
-}
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/* Copyright(c) 2018-2019  Realtek Corporation
+ */
 
-u8 efuse_read_1byte(struct ieee80211_hw *hw, u16 address)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u8 data;
-	u8 bytetemp;
-	u8 temp;
-	u32 k = 0;
-	const u32 efuse_len =
-		rtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];
-
-	if (address < efuse_len) {
-		temp = address & 0xFF;
-		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,
-			       temp);
-		bytetemp = rtl_read_byte(rtlpriv,
-					 rtlpriv->cfg->maps[EFUSE_CTRL] + 2);
-		temp = ((address >> 8) & 0x03) | (bytetemp & 0xFC);
-		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,
-			       temp);
-
-		bytetemp = rtl_read_byte(rtlpriv,
-					 rtlpriv->cfg->maps[EFUSE_CTRL] + 3);
-		temp = bytetemp & 0x7F;
-		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3,
-			       temp);
-
-		bytetemp = rtl_read_byte(rtlpriv,
-					 rtlpriv->cfg->maps[EFUSE_CTRL] + 3);
-		while (!(bytetemp & 0x80)) {
-			bytetemp = rtl_read_byte(rtlpriv,
-						 rtlpriv->cfg->
-						 maps[EFUSE_CTRL] + 3);
-			k++;
-			if (k == 1000) {
-				k = 0;
-				break;
-			}
-		}
-		data = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
-		return data;
-	} else
-		return 0xFF;
+#include "main.h"
+#include "efuse.h"
+#include "reg.h"
+#include "debug.h"
 
-}
-EXPORT_SYMBOL(efuse_read_1byte);
+#define RTW_EFUSE_BANK_WIFI		0x0
 
-void efuse_write_1byte(struct ieee80211_hw *hw, u16 address, u8 value)
+static void switch_efuse_bank(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u8 bytetemp;
-	u8 temp;
-	u32 k = 0;
-	const u32 efuse_len =
-		rtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];
-
-	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "Addr=%x Data =%x\n",
-		 address, value);
-
-	if (address < efuse_len) {
-		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL], value);
-
-		temp = address & 0xFF;
-		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,
-			       temp);
-		bytetemp = rtl_read_byte(rtlpriv,
-					 rtlpriv->cfg->maps[EFUSE_CTRL] + 2);
-
-		temp = ((address >> 8) & 0x03) | (bytetemp & 0xFC);
-		rtl_write_byte(rtlpriv,
-			       rtlpriv->cfg->maps[EFUSE_CTRL] + 2, temp);
-
-		bytetemp = rtl_read_byte(rtlpriv,
-					 rtlpriv->cfg->maps[EFUSE_CTRL] + 3);
-		temp = bytetemp | 0x80;
-		rtl_write_byte(rtlpriv,
-			       rtlpriv->cfg->maps[EFUSE_CTRL] + 3, temp);
-
-		bytetemp = rtl_read_byte(rtlpriv,
-					 rtlpriv->cfg->maps[EFUSE_CTRL] + 3);
-
-		while (bytetemp & 0x80) {
-			bytetemp = rtl_read_byte(rtlpriv,
-						 rtlpriv->cfg->
-						 maps[EFUSE_CTRL] + 3);
-			k++;
-			if (k == 100) {
-				k = 0;
-				break;
-			}
+	rtw_write32_mask(rtwdev, REG_LDO_EFUSE_CTRL, BIT_MASK_EFUSE_BANK_SEL,
+			 RTW_EFUSE_BANK_WIFI);
+}
+
+#define invalid_efuse_header(hdr1, hdr2) \
+	((hdr1) == 0xff || (((hdr1) & 0x1f) == 0xf && (hdr2) == 0xff))
+#define invalid_efuse_content(word_en, i) \
+	(((word_en) & BIT(i)) != 0x0)
+#define get_efuse_blk_idx_2_byte(hdr1, hdr2) \
+	((((hdr2) & 0xf0) >> 1) | (((hdr1) >> 5) & 0x07))
+#define get_efuse_blk_idx_1_byte(hdr1) \
+	(((hdr1) & 0xf0) >> 4)
+#define block_idx_to_logical_idx(blk_idx, i) \
+	(((blk_idx) << 3) + ((i) << 1))
+
+/* efuse header format
+ *
+ * | 7        5   4    0 | 7        4   3          0 | 15  8  7   0 |
+ *   block[2:0]   0 1111   block[6:3]   word_en[3:0]   byte0  byte1
+ * | header 1 (optional) |          header 2         |    word N    |
+ *
+ * word_en: 4 bits each word. 0 -> write; 1 -> not write
+ * N: 1~4, depends on word_en
+ */
+static int rtw_dump_logical_efuse_map(struct rtw_dev *rtwdev, u8 *phy_map,
+				      u8 *log_map)
+{
+	u32 physical_size = rtwdev->efuse.physical_size;
+	u32 protect_size = rtwdev->efuse.protect_size;
+	u32 logical_size = rtwdev->efuse.logical_size;
+	u32 phy_idx, log_idx;
+	u8 hdr1, hdr2;
+	u8 blk_idx;
+	u8 word_en;
+	int i;
+
+	for (phy_idx = 0; phy_idx < physical_size - protect_size;) {
+		hdr1 = phy_map[phy_idx];
+		hdr2 = phy_map[phy_idx + 1];
+		if (invalid_efuse_header(hdr1, hdr2))
+			break;
+
+		if ((hdr1 & 0x1f) == 0xf) {
+			/* 2-byte header format */
+			blk_idx = get_efuse_blk_idx_2_byte(hdr1, hdr2);
+			word_en = hdr2 & 0xf;
+			phy_idx += 2;
+		} else {
+			/* 1-byte header format */
+			blk_idx = get_efuse_blk_idx_1_byte(hdr1);
+			word_en = hdr1 & 0xf;
+			phy_idx += 1;
 		}
-	}
-
-}
-
-void read_efuse_byte(struct ieee80211_hw *hw, u16 _offset, u8 *pbuf)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u32 value32;
-	u8 readbyte;
-	u16 retry;
-
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,
-		       (_offset & 0xff));
-	readbyte = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2);
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,
-		       ((_offset >> 8) & 0x03) | (readbyte & 0xfc));
-
-	readbyte = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3);
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3,
-		       (readbyte & 0x7f));
-
-	retry = 0;
-	value32 = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
-	while (!(((value32 >> 24) & 0xff) & 0x80) && (retry < 10000)) {
-		value32 = rtl_read_dword(rtlpriv,
-					 rtlpriv->cfg->maps[EFUSE_CTRL]);
-		retry++;
-	}
-
-	udelay(50);
-	value32 = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
-
-	*pbuf = (u8) (value32 & 0xff);
-}
-EXPORT_SYMBOL_GPL(read_efuse_byte);
-
-void read_efuse(struct ieee80211_hw *hw, u16 _offset, u16 _size_byte, u8 *pbuf)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	u8 *efuse_tbl;
-	u8 rtemp8[1];
-	u16 efuse_addr = 0;
-	u8 offset, wren;
-	u8 u1temp = 0;
-	u16 i;
-	u16 j;
-	const u16 efuse_max_section =
-		rtlpriv->cfg->maps[EFUSE_MAX_SECTION_MAP];
-	const u32 efuse_len =
-		rtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];
-	u16 **efuse_word;
-	u16 efuse_utilized = 0;
-	u8 efuse_usage;
-
-	if ((_offset + _size_byte) > rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]) {
-		RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,
-			 "read_efuse(): Invalid offset(%#x) with read bytes(%#x)!!\n",
-			 _offset, _size_byte);
-		return;
-	}
 
-	/* allocate memory for efuse_tbl and efuse_word */
-	efuse_tbl = kzalloc(rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE] *
-			    sizeof(u8), GFP_ATOMIC);
-	if (!efuse_tbl)
-		return;
-	efuse_word = kcalloc(EFUSE_MAX_WORD_UNIT, sizeof(u16 *), GFP_ATOMIC);
-	if (!efuse_word)
-		goto out;
-	for (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {
-		efuse_word[i] = kcalloc(efuse_max_section, sizeof(u16), GFP_ATOMIC);
-		if (!efuse_word[i])
-			goto done;
-	}
-
-	for (i = 0; i < efuse_max_section; i++)
-		for (j = 0; j < EFUSE_MAX_WORD_UNIT; j++)
-			efuse_word[j][i] = 0xFFFF;
-
-	read_efuse_byte(hw, efuse_addr, rtemp8);
-	if (*rtemp8 != 0xFF) {
-		efuse_utilized++;
-		RTPRINT(rtlpriv, FEEPROM, EFUSE_READ_ALL,
-			"Addr=%d\n", efuse_addr);
-		efuse_addr++;
-	}
-
-	while ((*rtemp8 != 0xFF) && (efuse_addr < efuse_len)) {
-		/*  Check PG header for section num.  */
-		if ((*rtemp8 & 0x1F) == 0x0F) {/* extended header */
-			u1temp = ((*rtemp8 & 0xE0) >> 5);
-			read_efuse_byte(hw, efuse_addr, rtemp8);
-
-			if ((*rtemp8 & 0x0F) == 0x0F) {
-				efuse_addr++;
-				read_efuse_byte(hw, efuse_addr, rtemp8);
-
-				if (*rtemp8 != 0xFF &&
-				    (efuse_addr < efuse_len)) {
-					efuse_addr++;
-				}
+		for (i = 0; i < 4; i++) {
+			if (invalid_efuse_content(word_en, i))
 				continue;
-			} else {
-				offset = ((*rtemp8 & 0xF0) >> 1) | u1temp;
-				wren = (*rtemp8 & 0x0F);
-				efuse_addr++;
-			}
-		} else {
-			offset = ((*rtemp8 >> 4) & 0x0f);
-			wren = (*rtemp8 & 0x0f);
-		}
-
-		if (offset < efuse_max_section) {
-			RTPRINT(rtlpriv, FEEPROM, EFUSE_READ_ALL,
-				"offset-%d Worden=%x\n", offset, wren);
-
-			for (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {
-				if (!(wren & 0x01)) {
-					RTPRINT(rtlpriv, FEEPROM,
-						EFUSE_READ_ALL,
-						"Addr=%d\n", efuse_addr);
-
-					read_efuse_byte(hw, efuse_addr, rtemp8);
-					efuse_addr++;
-					efuse_utilized++;
-					efuse_word[i][offset] =
-							 (*rtemp8 & 0xff);
-
-					if (efuse_addr >= efuse_len)
-						break;
-
-					RTPRINT(rtlpriv, FEEPROM,
-						EFUSE_READ_ALL,
-						"Addr=%d\n", efuse_addr);
-
-					read_efuse_byte(hw, efuse_addr, rtemp8);
-					efuse_addr++;
-					efuse_utilized++;
-					efuse_word[i][offset] |=
-					    (((u16)*rtemp8 << 8) & 0xff00);
-
-					if (efuse_addr >= efuse_len)
-						break;
-				}
-
-				wren >>= 1;
-			}
-		}
-
-		RTPRINT(rtlpriv, FEEPROM, EFUSE_READ_ALL,
-			"Addr=%d\n", efuse_addr);
-		read_efuse_byte(hw, efuse_addr, rtemp8);
-		if (*rtemp8 != 0xFF && (efuse_addr < efuse_len)) {
-			efuse_utilized++;
-			efuse_addr++;
-		}
-	}
-
-	for (i = 0; i < efuse_max_section; i++) {
-		for (j = 0; j < EFUSE_MAX_WORD_UNIT; j++) {
-			efuse_tbl[(i * 8) + (j * 2)] =
-			    (efuse_word[j][i] & 0xff);
-			efuse_tbl[(i * 8) + ((j * 2) + 1)] =
-			    ((efuse_word[j][i] >> 8) & 0xff);
-		}
-	}
-
-	for (i = 0; i < _size_byte; i++)
-		pbuf[i] = efuse_tbl[_offset + i];
-
-	rtlefuse->efuse_usedbytes = efuse_utilized;
-	efuse_usage = (u8) ((efuse_utilized * 100) / efuse_len);
-	rtlefuse->efuse_usedpercentage = efuse_usage;
-	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_EFUSE_BYTES,
-				      (u8 *)&efuse_utilized);
-	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_EFUSE_USAGE,
-				      &efuse_usage);
-done:
-	for (i = 0; i < EFUSE_MAX_WORD_UNIT; i++)
-		kfree(efuse_word[i]);
-	kfree(efuse_word);
-out:
-	kfree(efuse_tbl);
-}
-
-bool efuse_shadow_update_chk(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	u8 section_idx, i, Base;
-	u16 words_need = 0, hdr_num = 0, totalbytes, efuse_used;
-	bool wordchanged, result = true;
-
-	for (section_idx = 0; section_idx < 16; section_idx++) {
-		Base = section_idx * 8;
-		wordchanged = false;
-
-		for (i = 0; i < 8; i = i + 2) {
-			if ((rtlefuse->efuse_map[EFUSE_INIT_MAP][Base + i] !=
-			     rtlefuse->efuse_map[EFUSE_MODIFY_MAP][Base + i]) ||
-			    (rtlefuse->efuse_map[EFUSE_INIT_MAP][Base + i + 1] !=
-			     rtlefuse->efuse_map[EFUSE_MODIFY_MAP][Base + i +
-								   1])) {
-				words_need++;
-				wordchanged = true;
-			}
-		}
-
-		if (wordchanged)
-			hdr_num++;
-	}
-
-	totalbytes = hdr_num + words_need * 2;
-	efuse_used = rtlefuse->efuse_usedbytes;
-
-	if ((totalbytes + efuse_used) >=
-	    (EFUSE_MAX_SIZE - rtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN]))
-		result = false;
-
-	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,
-		 "efuse_shadow_update_chk(): totalbytes(%#x), hdr_num(%#x), words_need(%#x), efuse_used(%d)\n",
-		 totalbytes, hdr_num, words_need, efuse_used);
-
-	return result;
-}
-
-void efuse_shadow_read(struct ieee80211_hw *hw, u8 type,
-		       u16 offset, u32 *value)
-{
-	if (type == 1)
-		efuse_shadow_read_1byte(hw, offset, (u8 *)value);
-	else if (type == 2)
-		efuse_shadow_read_2byte(hw, offset, (u16 *)value);
-	else if (type == 4)
-		efuse_shadow_read_4byte(hw, offset, value);
-
-}
-EXPORT_SYMBOL(efuse_shadow_read);
-
-void efuse_shadow_write(struct ieee80211_hw *hw, u8 type, u16 offset,
-				u32 value)
-{
-	if (type == 1)
-		efuse_shadow_write_1byte(hw, offset, (u8) value);
-	else if (type == 2)
-		efuse_shadow_write_2byte(hw, offset, (u16) value);
-	else if (type == 4)
-		efuse_shadow_write_4byte(hw, offset, value);
-
-}
-
-bool efuse_shadow_update(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	u16 i, offset, base;
-	u8 word_en = 0x0F;
-	u8 first_pg = false;
-
-	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "\n");
-
-	if (!efuse_shadow_update_chk(hw)) {
-		efuse_read_all_map(hw, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0]);
-		memcpy(&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][0],
-		       &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],
-		       rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);
-
-		RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,
-			 "efuse out of capacity!!\n");
-		return false;
-	}
-	efuse_power_switch(hw, true, true);
-
-	for (offset = 0; offset < 16; offset++) {
-
-		word_en = 0x0F;
-		base = offset * 8;
-
-		for (i = 0; i < 8; i++) {
-			if (first_pg) {
-				word_en &= ~(BIT(i / 2));
-
-				rtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] =
-				    rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i];
-			} else {
-
-				if (rtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] !=
-				    rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i]) {
-					word_en &= ~(BIT(i / 2));
-
-					rtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] =
-					    rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i];
-				}
-			}
-		}
-
-		if (word_en != 0x0F) {
-			u8 tmpdata[8];
-			memcpy(tmpdata,
-			       &rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base],
-			       8);
-			RT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_LOUD,
-				      "U-efuse\n", tmpdata, 8);
-
-			if (!efuse_pg_packet_write(hw, (u8) offset, word_en,
-						   tmpdata)) {
-				RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-					 "PG section(%#x) fail!!\n", offset);
-				break;
-			}
-		}
-
-	}
-
-	efuse_power_switch(hw, true, false);
-	efuse_read_all_map(hw, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0]);
-
-	memcpy(&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][0],
-	       &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],
-	       rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);
-
-	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "\n");
-	return true;
-}
-
-void rtl_efuse_shadow_map_update(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-
-	if (rtlefuse->autoload_failflag)
-		memset((&rtlefuse->efuse_map[EFUSE_INIT_MAP][0]),
-		       0xFF, rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);
-	else
-		efuse_read_all_map(hw, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0]);
-
-	memcpy(&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][0],
-			&rtlefuse->efuse_map[EFUSE_INIT_MAP][0],
-			rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);
-
-}
-EXPORT_SYMBOL(rtl_efuse_shadow_map_update);
-
-void efuse_force_write_vendor_Id(struct ieee80211_hw *hw)
-{
-	u8 tmpdata[8] = { 0xFF, 0xFF, 0xEC, 0x10, 0xFF, 0xFF, 0xFF, 0xFF };
-
-	efuse_power_switch(hw, true, true);
-
-	efuse_pg_packet_write(hw, 1, 0xD, tmpdata);
-
-	efuse_power_switch(hw, true, false);
-
-}
-
-void efuse_re_pg_section(struct ieee80211_hw *hw, u8 section_idx)
-{
-}
-
-static void efuse_shadow_read_1byte(struct ieee80211_hw *hw,
-				    u16 offset, u8 *value)
-{
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	*value = rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset];
-}
-
-static void efuse_shadow_read_2byte(struct ieee80211_hw *hw,
-				    u16 offset, u16 *value)
-{
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-
-	*value = rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset];
-	*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] << 8;
-
-}
-
-static void efuse_shadow_read_4byte(struct ieee80211_hw *hw,
-				    u16 offset, u32 *value)
-{
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-
-	*value = rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset];
-	*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] << 8;
-	*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 2] << 16;
-	*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 3] << 24;
-}
-
-static void efuse_shadow_write_1byte(struct ieee80211_hw *hw,
-				     u16 offset, u8 value)
-{
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-
-	rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset] = value;
-}
-
-static void efuse_shadow_write_2byte(struct ieee80211_hw *hw,
-				     u16 offset, u16 value)
-{
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-
-	rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset] = value & 0x00FF;
-	rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] = value >> 8;
-
-}
-
-static void efuse_shadow_write_4byte(struct ieee80211_hw *hw,
-				     u16 offset, u32 value)
-{
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-
-	rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset] =
-	    (u8) (value & 0x000000FF);
-	rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] =
-	    (u8) ((value >> 8) & 0x0000FF);
-	rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 2] =
-	    (u8) ((value >> 16) & 0x00FF);
-	rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 3] =
-	    (u8) ((value >> 24) & 0xFF);
-
-}
-
-int efuse_one_byte_read(struct ieee80211_hw *hw, u16 addr, u8 *data)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u8 tmpidx = 0;
-	int result;
-
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,
-		       (u8) (addr & 0xff));
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,
-		       ((u8) ((addr >> 8) & 0x03)) |
-		       (rtl_read_byte(rtlpriv,
-				      rtlpriv->cfg->maps[EFUSE_CTRL] + 2) &
-			0xFC));
-
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3, 0x72);
-
-	while (!(0x80 & rtl_read_byte(rtlpriv,
-				      rtlpriv->cfg->maps[EFUSE_CTRL] + 3))
-	       && (tmpidx < 100)) {
-		tmpidx++;
-	}
-
-	if (tmpidx < 100) {
-		*data = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
-		result = true;
-	} else {
-		*data = 0xff;
-		result = false;
-	}
-	return result;
-}
-EXPORT_SYMBOL(efuse_one_byte_read);
-
-static int efuse_one_byte_write(struct ieee80211_hw *hw, u16 addr, u8 data)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u8 tmpidx = 0;
-
-	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,
-		 "Addr = %x Data=%x\n", addr, data);
-
-	rtl_write_byte(rtlpriv,
-		       rtlpriv->cfg->maps[EFUSE_CTRL] + 1, (u8) (addr & 0xff));
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,
-		       (rtl_read_byte(rtlpriv,
-			 rtlpriv->cfg->maps[EFUSE_CTRL] +
-			 2) & 0xFC) | (u8) ((addr >> 8) & 0x03));
-
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL], data);
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3, 0xF2);
-
-	while ((0x80 & rtl_read_byte(rtlpriv,
-				     rtlpriv->cfg->maps[EFUSE_CTRL] + 3))
-	       && (tmpidx < 100)) {
-		tmpidx++;
-	}
 
-	if (tmpidx < 100)
-		return true;
-	return false;
-}
-
-static void efuse_read_all_map(struct ieee80211_hw *hw, u8 *efuse)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	efuse_power_switch(hw, false, true);
-	read_efuse(hw, 0, rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE], efuse);
-	efuse_power_switch(hw, false, false);
-}
-
-static void efuse_read_data_case1(struct ieee80211_hw *hw, u16 *efuse_addr,
-				u8 efuse_data, u8 offset, u8 *tmpdata,
-				u8 *readstate)
-{
-	bool dataempty = true;
-	u8 hoffset;
-	u8 tmpidx;
-	u8 hworden;
-	u8 word_cnts;
-
-	hoffset = (efuse_data >> 4) & 0x0F;
-	hworden = efuse_data & 0x0F;
-	word_cnts = efuse_calculate_word_cnts(hworden);
-
-	if (hoffset == offset) {
-		for (tmpidx = 0; tmpidx < word_cnts * 2; tmpidx++) {
-			if (efuse_one_byte_read(hw, *efuse_addr + 1 + tmpidx,
-						&efuse_data)) {
-				tmpdata[tmpidx] = efuse_data;
-				if (efuse_data != 0xff)
-					dataempty = false;
-			}
+			log_idx = block_idx_to_logical_idx(blk_idx, i);
+			if (phy_idx + 1 > physical_size - protect_size ||
+			    log_idx + 1 > logical_size)
+				return -EINVAL;
+
+			log_map[log_idx] = phy_map[phy_idx];
+			log_map[log_idx + 1] = phy_map[phy_idx + 1];
+			phy_idx += 2;
 		}
-
-		if (!dataempty) {
-			*readstate = PG_STATE_DATA;
-		} else {
-			*efuse_addr = *efuse_addr + (word_cnts * 2) + 1;
-			*readstate = PG_STATE_HEADER;
-		}
-
-	} else {
-		*efuse_addr = *efuse_addr + (word_cnts * 2) + 1;
-		*readstate = PG_STATE_HEADER;
-	}
-}
-
-static int efuse_pg_packet_read(struct ieee80211_hw *hw, u8 offset, u8 *data)
-{
-	u8 readstate = PG_STATE_HEADER;
-
-	bool continual = true;
-
-	u8 efuse_data, word_cnts = 0;
-	u16 efuse_addr = 0;
-	u8 tmpdata[8];
-
-	if (data == NULL)
-		return false;
-	if (offset > 15)
-		return false;
-
-	memset(data, 0xff, PGPKT_DATA_SIZE * sizeof(u8));
-	memset(tmpdata, 0xff, PGPKT_DATA_SIZE * sizeof(u8));
-
-	while (continual && (efuse_addr < EFUSE_MAX_SIZE)) {
-		if (readstate & PG_STATE_HEADER) {
-			if (efuse_one_byte_read(hw, efuse_addr, &efuse_data)
-			    && (efuse_data != 0xFF))
-				efuse_read_data_case1(hw, &efuse_addr,
-						      efuse_data, offset,
-						      tmpdata, &readstate);
-			else
-				continual = false;
-		} else if (readstate & PG_STATE_DATA) {
-			efuse_word_enable_data_read(0, tmpdata, data);
-			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
-			readstate = PG_STATE_HEADER;
-		}
-
 	}
-
-	if ((data[0] == 0xff) && (data[1] == 0xff) &&
-	    (data[2] == 0xff) && (data[3] == 0xff) &&
-	    (data[4] == 0xff) && (data[5] == 0xff) &&
-	    (data[6] == 0xff) && (data[7] == 0xff))
-		return false;
-	else
-		return true;
-
-}
-
-static void efuse_write_data_case1(struct ieee80211_hw *hw, u16 *efuse_addr,
-				   u8 efuse_data, u8 offset,
-				   int *continual, u8 *write_state,
-				   struct pgpkt_struct *target_pkt,
-				   int *repeat_times, int *result, u8 word_en)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct pgpkt_struct tmp_pkt;
-	int dataempty = true;
-	u8 originaldata[8 * sizeof(u8)];
-	u8 badworden = 0x0F;
-	u8 match_word_en, tmp_word_en;
-	u8 tmpindex;
-	u8 tmp_header = efuse_data;
-	u8 tmp_word_cnts;
-
-	tmp_pkt.offset = (tmp_header >> 4) & 0x0F;
-	tmp_pkt.word_en = tmp_header & 0x0F;
-	tmp_word_cnts = efuse_calculate_word_cnts(tmp_pkt.word_en);
-
-	if (tmp_pkt.offset != target_pkt->offset) {
-		*efuse_addr = *efuse_addr + (tmp_word_cnts * 2) + 1;
-		*write_state = PG_STATE_HEADER;
-	} else {
-		for (tmpindex = 0; tmpindex < (tmp_word_cnts * 2); tmpindex++) {
-			if (efuse_one_byte_read(hw,
-						(*efuse_addr + 1 + tmpindex),
-						&efuse_data) &&
-			    (efuse_data != 0xFF))
-				dataempty = false;
-		}
-
-		if (!dataempty) {
-			*efuse_addr = *efuse_addr + (tmp_word_cnts * 2) + 1;
-			*write_state = PG_STATE_HEADER;
-		} else {
-			match_word_en = 0x0F;
-			if (!((target_pkt->word_en & BIT(0)) |
-			    (tmp_pkt.word_en & BIT(0))))
-				match_word_en &= (~BIT(0));
-
-			if (!((target_pkt->word_en & BIT(1)) |
-			    (tmp_pkt.word_en & BIT(1))))
-				match_word_en &= (~BIT(1));
-
-			if (!((target_pkt->word_en & BIT(2)) |
-			    (tmp_pkt.word_en & BIT(2))))
-				match_word_en &= (~BIT(2));
-
-			if (!((target_pkt->word_en & BIT(3)) |
-			    (tmp_pkt.word_en & BIT(3))))
-				match_word_en &= (~BIT(3));
-
-			if ((match_word_en & 0x0F) != 0x0F) {
-				badworden =
-				  enable_efuse_data_write(hw,
-							  *efuse_addr + 1,
-							  tmp_pkt.word_en,
-							  target_pkt->data);
-
-				if (0x0F != (badworden & 0x0F))	{
-					u8 reorg_offset = offset;
-					u8 reorg_worden = badworden;
-					efuse_pg_packet_write(hw, reorg_offset,
-							      reorg_worden,
-							      originaldata);
-				}
-
-				tmp_word_en = 0x0F;
-				if ((target_pkt->word_en & BIT(0)) ^
-				    (match_word_en & BIT(0)))
-					tmp_word_en &= (~BIT(0));
-
-				if ((target_pkt->word_en & BIT(1)) ^
-				    (match_word_en & BIT(1)))
-					tmp_word_en &= (~BIT(1));
-
-				if ((target_pkt->word_en & BIT(2)) ^
-				    (match_word_en & BIT(2)))
-					tmp_word_en &= (~BIT(2));
-
-				if ((target_pkt->word_en & BIT(3)) ^
-				    (match_word_en & BIT(3)))
-					tmp_word_en &= (~BIT(3));
-
-				if ((tmp_word_en & 0x0F) != 0x0F) {
-					*efuse_addr = efuse_get_current_size(hw);
-					target_pkt->offset = offset;
-					target_pkt->word_en = tmp_word_en;
-				} else {
-					*continual = false;
-				}
-				*write_state = PG_STATE_HEADER;
-				*repeat_times += 1;
-				if (*repeat_times > EFUSE_REPEAT_THRESHOLD_) {
-					*continual = false;
-					*result = false;
-				}
-			} else {
-				*efuse_addr += (2 * tmp_word_cnts) + 1;
-				target_pkt->offset = offset;
-				target_pkt->word_en = word_en;
-				*write_state = PG_STATE_HEADER;
-			}
-		}
-	}
-	RTPRINT(rtlpriv, FEEPROM, EFUSE_PG, "efuse PG_STATE_HEADER-1\n");
-}
-
-static void efuse_write_data_case2(struct ieee80211_hw *hw, u16 *efuse_addr,
-				   int *continual, u8 *write_state,
-				   struct pgpkt_struct target_pkt,
-				   int *repeat_times, int *result)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct pgpkt_struct tmp_pkt;
-	u8 pg_header;
-	u8 tmp_header;
-	u8 originaldata[8 * sizeof(u8)];
-	u8 tmp_word_cnts;
-	u8 badworden = 0x0F;
-
-	pg_header = ((target_pkt.offset << 4) & 0xf0) | target_pkt.word_en;
-	efuse_one_byte_write(hw, *efuse_addr, pg_header);
-	efuse_one_byte_read(hw, *efuse_addr, &tmp_header);
-
-	if (tmp_header == pg_header) {
-		*write_state = PG_STATE_DATA;
-	} else if (tmp_header == 0xFF) {
-		*write_state = PG_STATE_HEADER;
-		*repeat_times += 1;
-		if (*repeat_times > EFUSE_REPEAT_THRESHOLD_) {
-			*continual = false;
-			*result = false;
-		}
-	} else {
-		tmp_pkt.offset = (tmp_header >> 4) & 0x0F;
-		tmp_pkt.word_en = tmp_header & 0x0F;
-
-		tmp_word_cnts = efuse_calculate_word_cnts(tmp_pkt.word_en);
-
-		memset(originaldata, 0xff,  8 * sizeof(u8));
-
-		if (efuse_pg_packet_read(hw, tmp_pkt.offset, originaldata)) {
-			badworden = enable_efuse_data_write(hw,
-							    *efuse_addr + 1,
-							    tmp_pkt.word_en,
-							    originaldata);
-
-			if (0x0F != (badworden & 0x0F)) {
-				u8 reorg_offset = tmp_pkt.offset;
-				u8 reorg_worden = badworden;
-				efuse_pg_packet_write(hw, reorg_offset,
-						      reorg_worden,
-						      originaldata);
-				*efuse_addr = efuse_get_current_size(hw);
-			} else {
-				*efuse_addr = *efuse_addr +
-					      (tmp_word_cnts * 2) + 1;
-			}
-		} else {
-			*efuse_addr = *efuse_addr + (tmp_word_cnts * 2) + 1;
-		}
-
-		*write_state = PG_STATE_HEADER;
-		*repeat_times += 1;
-		if (*repeat_times > EFUSE_REPEAT_THRESHOLD_) {
-			*continual = false;
-			*result = false;
-		}
-
-		RTPRINT(rtlpriv, FEEPROM, EFUSE_PG,
-			"efuse PG_STATE_HEADER-2\n");
-	}
-}
-
-static int efuse_pg_packet_write(struct ieee80211_hw *hw,
-				 u8 offset, u8 word_en, u8 *data)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct pgpkt_struct target_pkt;
-	u8 write_state = PG_STATE_HEADER;
-	int continual = true, dataempty = true, result = true;
-	u16 efuse_addr = 0;
-	u8 efuse_data;
-	u8 target_word_cnts = 0;
-	u8 badworden = 0x0F;
-	static int repeat_times;
-
-	if (efuse_get_current_size(hw) >= (EFUSE_MAX_SIZE -
-		rtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN])) {
-		RTPRINT(rtlpriv, FEEPROM, EFUSE_PG,
-			"efuse_pg_packet_write error\n");
-		return false;
-	}
-
-	target_pkt.offset = offset;
-	target_pkt.word_en = word_en;
-
-	memset(target_pkt.data, 0xFF,  8 * sizeof(u8));
-
-	efuse_word_enable_data_read(word_en, data, target_pkt.data);
-	target_word_cnts = efuse_calculate_word_cnts(target_pkt.word_en);
-
-	RTPRINT(rtlpriv, FEEPROM, EFUSE_PG, "efuse Power ON\n");
-
-	while (continual && (efuse_addr < (EFUSE_MAX_SIZE -
-		rtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN]))) {
-
-		if (write_state == PG_STATE_HEADER) {
-			dataempty = true;
-			badworden = 0x0F;
-			RTPRINT(rtlpriv, FEEPROM, EFUSE_PG,
-				"efuse PG_STATE_HEADER\n");
-
-			if (efuse_one_byte_read(hw, efuse_addr, &efuse_data) &&
-			    (efuse_data != 0xFF))
-				efuse_write_data_case1(hw, &efuse_addr,
-						       efuse_data, offset,
-						       &continual,
-						       &write_state,
-						       &target_pkt,
-						       &repeat_times, &result,
-						       word_en);
-			else
-				efuse_write_data_case2(hw, &efuse_addr,
-						       &continual,
-						       &write_state,
-						       target_pkt,
-						       &repeat_times,
-						       &result);
-
-		} else if (write_state == PG_STATE_DATA) {
-			RTPRINT(rtlpriv, FEEPROM, EFUSE_PG,
-				"efuse PG_STATE_DATA\n");
-			badworden = 0x0f;
-			badworden =
-			    enable_efuse_data_write(hw, efuse_addr + 1,
-						    target_pkt.word_en,
-						    target_pkt.data);
-
-			if ((badworden & 0x0F) == 0x0F) {
-				continual = false;
-			} else {
-				efuse_addr =
-				    efuse_addr + (2 * target_word_cnts) + 1;
-
-				target_pkt.offset = offset;
-				target_pkt.word_en = badworden;
-				target_word_cnts =
-				    efuse_calculate_word_cnts(target_pkt.
-							      word_en);
-				write_state = PG_STATE_HEADER;
-				repeat_times++;
-				if (repeat_times > EFUSE_REPEAT_THRESHOLD_) {
-					continual = false;
-					result = false;
-				}
-				RTPRINT(rtlpriv, FEEPROM, EFUSE_PG,
-					"efuse PG_STATE_HEADER-3\n");
-			}
-		}
-	}
-
-	if (efuse_addr >= (EFUSE_MAX_SIZE -
-		rtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN])) {
-		RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,
-			 "efuse_addr(%#x) Out of size!!\n", efuse_addr);
-	}
-
-	return true;
-}
-
-static void efuse_word_enable_data_read(u8 word_en, u8 *sourdata,
-					u8 *targetdata)
-{
-	if (!(word_en & BIT(0))) {
-		targetdata[0] = sourdata[0];
-		targetdata[1] = sourdata[1];
-	}
-
-	if (!(word_en & BIT(1))) {
-		targetdata[2] = sourdata[2];
-		targetdata[3] = sourdata[3];
-	}
-
-	if (!(word_en & BIT(2))) {
-		targetdata[4] = sourdata[4];
-		targetdata[5] = sourdata[5];
-	}
-
-	if (!(word_en & BIT(3))) {
-		targetdata[6] = sourdata[6];
-		targetdata[7] = sourdata[7];
-	}
-}
-
-static u8 enable_efuse_data_write(struct ieee80211_hw *hw,
-				  u16 efuse_addr, u8 word_en, u8 *data)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u16 tmpaddr;
-	u16 start_addr = efuse_addr;
-	u8 badworden = 0x0F;
-	u8 tmpdata[8];
-
-	memset(tmpdata, 0xff, PGPKT_DATA_SIZE);
-	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD,
-		 "word_en = %x efuse_addr=%x\n", word_en, efuse_addr);
-
-	if (!(word_en & BIT(0))) {
-		tmpaddr = start_addr;
-		efuse_one_byte_write(hw, start_addr++, data[0]);
-		efuse_one_byte_write(hw, start_addr++, data[1]);
-
-		efuse_one_byte_read(hw, tmpaddr, &tmpdata[0]);
-		efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[1]);
-		if ((data[0] != tmpdata[0]) || (data[1] != tmpdata[1]))
-			badworden &= (~BIT(0));
-	}
-
-	if (!(word_en & BIT(1))) {
-		tmpaddr = start_addr;
-		efuse_one_byte_write(hw, start_addr++, data[2]);
-		efuse_one_byte_write(hw, start_addr++, data[3]);
-
-		efuse_one_byte_read(hw, tmpaddr, &tmpdata[2]);
-		efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[3]);
-		if ((data[2] != tmpdata[2]) || (data[3] != tmpdata[3]))
-			badworden &= (~BIT(1));
-	}
-
-	if (!(word_en & BIT(2))) {
-		tmpaddr = start_addr;
-		efuse_one_byte_write(hw, start_addr++, data[4]);
-		efuse_one_byte_write(hw, start_addr++, data[5]);
-
-		efuse_one_byte_read(hw, tmpaddr, &tmpdata[4]);
-		efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[5]);
-		if ((data[4] != tmpdata[4]) || (data[5] != tmpdata[5]))
-			badworden &= (~BIT(2));
-	}
-
-	if (!(word_en & BIT(3))) {
-		tmpaddr = start_addr;
-		efuse_one_byte_write(hw, start_addr++, data[6]);
-		efuse_one_byte_write(hw, start_addr++, data[7]);
-
-		efuse_one_byte_read(hw, tmpaddr, &tmpdata[6]);
-		efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[7]);
-		if ((data[6] != tmpdata[6]) || (data[7] != tmpdata[7]))
-			badworden &= (~BIT(3));
-	}
-
-	return badworden;
+	return 0;
 }
 
-void efuse_power_switch(struct ieee80211_hw *hw, u8 write, u8 pwrstate)
+static int rtw_dump_physical_efuse_map(struct rtw_dev *rtwdev, u8 *map)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	u8 tempval;
-	u16 tmpV16;
-
-	if (pwrstate && (rtlhal->hw_type != HARDWARE_TYPE_RTL8192SE)) {
-
-		if (rtlhal->hw_type != HARDWARE_TYPE_RTL8192CE &&
-		    rtlhal->hw_type != HARDWARE_TYPE_RTL8192DE) {
-			rtl_write_byte(rtlpriv,
-				       rtlpriv->cfg->maps[EFUSE_ACCESS], 0x69);
-		} else {
-			tmpV16 =
-			  rtl_read_word(rtlpriv,
-					rtlpriv->cfg->maps[SYS_ISO_CTRL]);
-			if (!(tmpV16 & rtlpriv->cfg->maps[EFUSE_PWC_EV12V])) {
-				tmpV16 |= rtlpriv->cfg->maps[EFUSE_PWC_EV12V];
-				rtl_write_word(rtlpriv,
-					       rtlpriv->cfg->maps[SYS_ISO_CTRL],
-					       tmpV16);
-			}
-		}
-		tmpV16 = rtl_read_word(rtlpriv,
-				       rtlpriv->cfg->maps[SYS_FUNC_EN]);
-		if (!(tmpV16 & rtlpriv->cfg->maps[EFUSE_FEN_ELDR])) {
-			tmpV16 |= rtlpriv->cfg->maps[EFUSE_FEN_ELDR];
-			rtl_write_word(rtlpriv,
-				       rtlpriv->cfg->maps[SYS_FUNC_EN], tmpV16);
-		}
-
-		tmpV16 = rtl_read_word(rtlpriv, rtlpriv->cfg->maps[SYS_CLK]);
-		if ((!(tmpV16 & rtlpriv->cfg->maps[EFUSE_LOADER_CLK_EN])) ||
-		    (!(tmpV16 & rtlpriv->cfg->maps[EFUSE_ANA8M]))) {
-			tmpV16 |= (rtlpriv->cfg->maps[EFUSE_LOADER_CLK_EN] |
-				   rtlpriv->cfg->maps[EFUSE_ANA8M]);
-			rtl_write_word(rtlpriv,
-				       rtlpriv->cfg->maps[SYS_CLK], tmpV16);
-		}
-	}
-
-	if (pwrstate) {
-		if (write) {
-			tempval = rtl_read_byte(rtlpriv,
-						rtlpriv->cfg->maps[EFUSE_TEST] +
-						3);
-
-			if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {
-				tempval &= ~(BIT(3) | BIT(4) | BIT(5) | BIT(6));
-				tempval |= (VOLTAGE_V25 << 3);
-			} else if (rtlhal->hw_type != HARDWARE_TYPE_RTL8192SE) {
-				tempval &= 0x0F;
-				tempval |= (VOLTAGE_V25 << 4);
-			}
-
-			rtl_write_byte(rtlpriv,
-				       rtlpriv->cfg->maps[EFUSE_TEST] + 3,
-				       (tempval | 0x80));
-		}
-
-		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE) {
-			rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CLK],
-				       0x03);
-		}
-	} else {
-		if (rtlhal->hw_type != HARDWARE_TYPE_RTL8192CE &&
-		    rtlhal->hw_type != HARDWARE_TYPE_RTL8192DE)
-			rtl_write_byte(rtlpriv,
-				       rtlpriv->cfg->maps[EFUSE_ACCESS], 0);
-
-		if (write) {
-			tempval = rtl_read_byte(rtlpriv,
-						rtlpriv->cfg->maps[EFUSE_TEST] +
-						3);
-			rtl_write_byte(rtlpriv,
-				       rtlpriv->cfg->maps[EFUSE_TEST] + 3,
-				       (tempval & 0x7F));
-		}
-
-		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE) {
-			rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CLK],
-				       0x02);
-		}
-	}
-}
-EXPORT_SYMBOL(efuse_power_switch);
+	struct rtw_chip_info *chip = rtwdev->chip;
+	u32 size = rtwdev->efuse.physical_size;
+	u32 efuse_ctl;
+	u32 addr;
+	u32 cnt;
+
+	switch_efuse_bank(rtwdev);
+
+	/* disable 2.5V LDO */
+	chip->ops->cfg_ldo25(rtwdev, false);
+
+	efuse_ctl = rtw_read32(rtwdev, REG_EFUSE_CTRL);
+
+	for (addr = 0; addr < size; addr++) {
+		efuse_ctl &= ~(BIT_MASK_EF_DATA | BITS_EF_ADDR);
+		efuse_ctl |= (addr & BIT_MASK_EF_ADDR) << BIT_SHIFT_EF_ADDR;
+		rtw_write32(rtwdev, REG_EFUSE_CTRL, efuse_ctl & (~BIT_EF_FLAG));
+
+		cnt = 1000000;
+		do {
+			udelay(1);
+			efuse_ctl = rtw_read32(rtwdev, REG_EFUSE_CTRL);
+			if (--cnt == 0)
+				return -EBUSY;
+		} while (!(efuse_ctl & BIT_EF_FLAG));
 
-static u16 efuse_get_current_size(struct ieee80211_hw *hw)
-{
-	int continual = true;
-	u16 efuse_addr = 0;
-	u8 hoffset, hworden;
-	u8 efuse_data, word_cnts;
-
-	while (continual && efuse_one_byte_read(hw, efuse_addr, &efuse_data) &&
-	       (efuse_addr < EFUSE_MAX_SIZE)) {
-		if (efuse_data != 0xFF) {
-			hoffset = (efuse_data >> 4) & 0x0F;
-			hworden = efuse_data & 0x0F;
-			word_cnts = efuse_calculate_word_cnts(hworden);
-			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
-		} else {
-			continual = false;
-		}
+		*(map + addr) = (u8)(efuse_ctl & BIT_MASK_EF_DATA);
 	}
 
-	return efuse_addr;
+	return 0;
 }
 
-static u8 efuse_calculate_word_cnts(u8 word_en)
+int rtw_parse_efuse_map(struct rtw_dev *rtwdev)
 {
-	u8 word_cnts = 0;
-	if (!(word_en & BIT(0)))
-		word_cnts++;
-	if (!(word_en & BIT(1)))
-		word_cnts++;
-	if (!(word_en & BIT(2)))
-		word_cnts++;
-	if (!(word_en & BIT(3)))
-		word_cnts++;
-	return word_cnts;
-}
+	struct rtw_chip_info *chip = rtwdev->chip;
+	struct rtw_efuse *efuse = &rtwdev->efuse;
+	u32 phy_size = efuse->physical_size;
+	u32 log_size = efuse->logical_size;
+	u8 *phy_map = NULL;
+	u8 *log_map = NULL;
+	int ret = 0;
 
-int rtl_get_hwinfo(struct ieee80211_hw *hw, struct rtl_priv *rtlpriv,
-		   int max_size, u8 *hwinfo, int *params)
-{
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	struct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);
-	struct device *dev = &rtlpcipriv->dev.pdev->dev;
-	u16 eeprom_id;
-	u16 i, usvalue;
-
-	switch (rtlefuse->epromtype) {
-	case EEPROM_BOOT_EFUSE:
-		rtl_efuse_shadow_map_update(hw);
-		break;
-
-	case EEPROM_93C46:
-		pr_err("RTL8XXX did not boot from eeprom, check it !!\n");
-		return 1;
-
-	default:
-		dev_warn(dev, "no efuse data\n");
-		return 1;
+	phy_map = kmalloc(phy_size, GFP_KERNEL);
+	log_map = kmalloc(log_size, GFP_KERNEL);
+	if (!phy_map || !log_map) {
+		ret = -ENOMEM;
+		goto out_free;
 	}
 
-	memcpy(hwinfo, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0], max_size);
-
-	RT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_DMESG, "MAP",
-		      hwinfo, max_size);
-
-	eeprom_id = *((u16 *)&hwinfo[0]);
-	if (eeprom_id != params[0]) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-			 "EEPROM ID(%#x) is invalid!!\n", eeprom_id);
-		rtlefuse->autoload_failflag = true;
-	} else {
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n");
-		rtlefuse->autoload_failflag = false;
+	ret = rtw_dump_physical_efuse_map(rtwdev, phy_map);
+	if (ret) {
+		rtw_err(rtwdev, "failed to dump efuse physical map\n");
+		goto out_free;
 	}
 
-	if (rtlefuse->autoload_failflag)
-		return 1;
-
-	rtlefuse->eeprom_vid = *(u16 *)&hwinfo[params[1]];
-	rtlefuse->eeprom_did = *(u16 *)&hwinfo[params[2]];
-	rtlefuse->eeprom_svid = *(u16 *)&hwinfo[params[3]];
-	rtlefuse->eeprom_smid = *(u16 *)&hwinfo[params[4]];
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-		 "EEPROMId = 0x%4x\n", eeprom_id);
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-		 "EEPROM VID = 0x%4x\n", rtlefuse->eeprom_vid);
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-		 "EEPROM DID = 0x%4x\n", rtlefuse->eeprom_did);
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-		 "EEPROM SVID = 0x%4x\n", rtlefuse->eeprom_svid);
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-		 "EEPROM SMID = 0x%4x\n", rtlefuse->eeprom_smid);
-
-	for (i = 0; i < 6; i += 2) {
-		usvalue = *(u16 *)&hwinfo[params[5] + i];
-		*((u16 *)(&rtlefuse->dev_addr[i])) = usvalue;
+	memset(log_map, 0xff, log_size);
+	ret = rtw_dump_logical_efuse_map(rtwdev, phy_map, log_map);
+	if (ret) {
+		rtw_err(rtwdev, "failed to dump efuse logical map\n");
+		goto out_free;
 	}
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "%pM\n", rtlefuse->dev_addr);
-
-	rtlefuse->eeprom_channelplan = *&hwinfo[params[6]];
-	rtlefuse->eeprom_version = *(u16 *)&hwinfo[params[7]];
-	rtlefuse->txpwr_fromeprom = true;
-	rtlefuse->eeprom_oemid = *&hwinfo[params[8]];
-
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-		 "EEPROM Customer ID: 0x%2x\n", rtlefuse->eeprom_oemid);
-
-	/* set channel plan to world wide 13 */
-	rtlefuse->channel_plan = params[9];
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(rtl_get_hwinfo);
-
-void rtl_fw_block_write(struct ieee80211_hw *hw, const u8 *buffer, u32 size)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u8 *pu4byteptr = (u8 *)buffer;
-	u32 i;
-
-	for (i = 0; i < size; i++)
-		rtl_write_byte(rtlpriv, (START_ADDRESS + i), *(pu4byteptr + i));
-}
-EXPORT_SYMBOL_GPL(rtl_fw_block_write);
-
-void rtl_fw_page_write(struct ieee80211_hw *hw, u32 page, const u8 *buffer,
-		       u32 size)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u8 value8;
-	u8 u8page = (u8)(page & 0x07);
-
-	value8 = (rtl_read_byte(rtlpriv, REG_MCUFWDL + 2) & 0xF8) | u8page;
-
-	rtl_write_byte(rtlpriv, (REG_MCUFWDL + 2), value8);
-	rtl_fw_block_write(hw, buffer, size);
-}
-EXPORT_SYMBOL_GPL(rtl_fw_page_write);
 
-void rtl_fill_dummy(u8 *pfwbuf, u32 *pfwlen)
-{
-	u32 fwlen = *pfwlen;
-	u8 remain = (u8)(fwlen % 4);
-
-	remain = (remain == 0) ? 0 : (4 - remain);
-
-	while (remain > 0) {
-		pfwbuf[fwlen] = 0;
-		fwlen++;
-		remain--;
+	ret = chip->ops->read_efuse(rtwdev, log_map);
+	if (ret) {
+		rtw_err(rtwdev, "failed to read efuse map\n");
+		goto out_free;
 	}
 
-	*pfwlen = fwlen;
-}
-EXPORT_SYMBOL_GPL(rtl_fill_dummy);
-
-void rtl_efuse_ops_init(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+out_free:
+	kfree(log_map);
+	kfree(phy_map);
 
-	rtlpriv->efuse.efuse_ops = &efuse_ops;
+	return ret;
 }
-EXPORT_SYMBOL_GPL(rtl_efuse_ops_init);
-
-
diff -upr /home/finger/rtlwifi_new1/efuse.h drivers/net/wireless/realtek/rtw88/efuse.h
--- /home/finger/rtlwifi_new1/efuse.h	2019-06-14 10:13:19.898404584 -0500
+++ drivers/net/wireless/realtek/rtw88/efuse.h	2019-05-29 10:27:03.755295149 -0500
@@ -1,120 +1,26 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright(c) 2018-2019  Realtek Corporation
+ */
+
+#ifndef __RTW_EFUSE_H__
+#define __RTW_EFUSE_H__
+
+#define EFUSE_HW_CAP_IGNORE		0
+#define EFUSE_HW_CAP_PTCL_VHT		3
+#define EFUSE_HW_CAP_SUPP_BW80		7
+#define EFUSE_HW_CAP_SUPP_BW40		6
+
+#define GET_EFUSE_HW_CAP_HCI(hw_cap)					       \
+	le32_get_bits(*((__le32 *)(hw_cap) + 0x01), GENMASK(3, 0))
+#define GET_EFUSE_HW_CAP_BW(hw_cap)					       \
+	le32_get_bits(*((__le32 *)(hw_cap) + 0x01), GENMASK(18, 16))
+#define GET_EFUSE_HW_CAP_NSS(hw_cap)					       \
+	le32_get_bits(*((__le32 *)(hw_cap) + 0x01), GENMASK(20, 19))
+#define GET_EFUSE_HW_CAP_ANT_NUM(hw_cap)				       \
+	le32_get_bits(*((__le32 *)(hw_cap) + 0x01), GENMASK(23, 21))
+#define GET_EFUSE_HW_CAP_PTCL(hw_cap)					       \
+	le32_get_bits(*((__le32 *)(hw_cap) + 0x01), GENMASK(27, 26))
 
-#ifndef __RTL_EFUSE_H_
-#define __RTL_EFUSE_H_
+int rtw_parse_efuse_map(struct rtw_dev *rtwdev);
 
-#define EFUSE_IC_ID_OFFSET		506
-
-#define EFUSE_MAX_WORD_UNIT		4
-
-#define EFUSE_INIT_MAP			0
-#define EFUSE_MODIFY_MAP		1
-
-#define PG_STATE_HEADER			0x01
-#define PG_STATE_WORD_0			0x02
-#define PG_STATE_WORD_1			0x04
-#define PG_STATE_WORD_2			0x08
-#define PG_STATE_WORD_3			0x10
-#define PG_STATE_DATA			0x20
-
-#define EFUSE_REPEAT_THRESHOLD_		3
-#define EFUSE_ERROE_HANDLE		1
-
-struct efuse_map {
-	u8 offset;
-	u8 word_start;
-	u8 byte_start;
-	u8 byte_cnts;
-};
-
-struct pgpkt_struct {
-	u8 offset;
-	u8 word_en;
-	u8 data[8];
-};
-
-enum efuse_data_item {
-	EFUSE_CHIP_ID = 0,
-	EFUSE_LDO_SETTING,
-	EFUSE_CLK_SETTING,
-	EFUSE_SDIO_SETTING,
-	EFUSE_CCCR,
-	EFUSE_SDIO_MODE,
-	EFUSE_OCR,
-	EFUSE_F0CIS,
-	EFUSE_F1CIS,
-	EFUSE_MAC_ADDR,
-	EFUSE_EEPROM_VER,
-	EFUSE_CHAN_PLAN,
-	EFUSE_TXPW_TAB
-};
-
-enum {
-	VOLTAGE_V25 = 0x03,
-	LDOE25_SHIFT = 28,
-};
-
-struct efuse_priv {
-	u8 id[2];
-	u8 ldo_setting[2];
-	u8 clk_setting[2];
-	u8 cccr;
-	u8 sdio_mode;
-	u8 ocr[3];
-	u8 cis0[17];
-	u8 cis1[48];
-	u8 mac_addr[6];
-	u8 eeprom_verno;
-	u8 channel_plan;
-	u8 tx_power_b[14];
-	u8 tx_power_g[14];
-};
-
-void read_efuse_byte(struct ieee80211_hw *hw, u16 _offset, u8 *pbuf);
-void efuse_initialize(struct ieee80211_hw *hw);
-u8 efuse_read_1byte(struct ieee80211_hw *hw, u16 address);
-int efuse_one_byte_read(struct ieee80211_hw *hw, u16 addr, u8 *data);
-void efuse_write_1byte(struct ieee80211_hw *hw, u16 address, u8 value);
-void read_efuse(struct ieee80211_hw *hw, u16 _offset,
-		u16 _size_byte, u8 *pbuf);
-void efuse_shadow_read(struct ieee80211_hw *hw, u8 type,
-		       u16 offset, u32 *value);
-void efuse_shadow_write(struct ieee80211_hw *hw, u8 type,
-			u16 offset, u32 value);
-bool efuse_shadow_update(struct ieee80211_hw *hw);
-bool efuse_shadow_update_chk(struct ieee80211_hw *hw);
-void rtl_efuse_shadow_map_update(struct ieee80211_hw *hw);
-void efuse_force_write_vendor_Id(struct ieee80211_hw *hw);
-void efuse_re_pg_section(struct ieee80211_hw *hw, u8 section_idx);
-void efuse_power_switch(struct ieee80211_hw *hw, u8 write, u8 pwrstate);
-int rtl_get_hwinfo(struct ieee80211_hw *hw, struct rtl_priv *rtlpriv,
-		   int max_size, u8 *hwinfo, int *params);
-void rtl_fill_dummy(u8 *pfwbuf, u32 *pfwlen);
-void rtl_fw_page_write(struct ieee80211_hw *hw, u32 page, const u8 *buffer,
-		       u32 size);
-void rtl_fw_block_write(struct ieee80211_hw *hw, const u8 *buffer, u32 size);
-void rtl_efuse_ops_init(struct ieee80211_hw *hw);
 #endif
Only in drivers/net/wireless/realtek/rtw88/: efuse.o
Only in drivers/net/wireless/realtek/rtw88/: .efuse.o.cmd
Only in /home/finger/rtlwifi_new1/: firmware
Only in drivers/net/wireless/realtek/rtw88/: fw.c
Only in drivers/net/wireless/realtek/rtw88/: fw.h
Only in drivers/net/wireless/realtek/rtw88/: fw.o
Only in drivers/net/wireless/realtek/rtw88/: .fw.o.cmd
Only in /home/finger/rtlwifi_new1/: .git
Only in /home/finger/rtlwifi_new1/: .gitignore
Only in /home/finger/rtlwifi_new1/: halmac
Only in drivers/net/wireless/realtek/rtw88/: hci.h
Only in drivers/net/wireless/realtek/rtw88/: Kconfig
Only in drivers/net/wireless/realtek/rtw88/: mac80211.c
Only in drivers/net/wireless/realtek/rtw88/: mac80211.o
Only in drivers/net/wireless/realtek/rtw88/: .mac80211.o.cmd
diff -upr /home/finger/rtlwifi_new1/.mac80211.o.d drivers/net/wireless/realtek/rtw88/.mac80211.o.d
--- /home/finger/rtlwifi_new1/.mac80211.o.d	2019-06-14 10:01:31.779245709 -0500
+++ drivers/net/wireless/realtek/rtw88/.mac80211.o.d	2019-06-14 20:50:56.734326606 -0500
@@ -1,7 +1,7 @@
-mac80211.o: /home/finger/rtlwifi_new1/mac80211.c include/linux/kconfig.h \
- include/generated/autoconf.h include/linux/compiler_types.h \
- include/linux/compiler_attributes.h include/linux/compiler-gcc.h \
- /home/finger/rtlwifi_new1/main.h include/generated/uapi/linux/version.h \
+mac80211.o: drivers/net/wireless/realtek/rtw88/mac80211.c \
+ include/linux/kconfig.h include/generated/autoconf.h \
+ include/linux/compiler_types.h include/linux/compiler_attributes.h \
+ include/linux/compiler-gcc.h drivers/net/wireless/realtek/rtw88/main.h \
  include/net/mac80211.h include/linux/bug.h arch/x86/include/asm/bug.h \
  include/linux/stringify.h include/asm-generic/bug.h \
  include/linux/compiler.h include/linux/compiler_types.h \
@@ -69,17 +69,11 @@ mac80211.o: /home/finger/rtlwifi_new1/ma
  arch/x86/include/uapi/asm/processor-flags.h \
  arch/x86/include/asm/math_emu.h arch/x86/include/asm/ptrace.h \
  arch/x86/include/asm/segment.h arch/x86/include/uapi/asm/ptrace.h \
- arch/x86/include/uapi/asm/ptrace-abi.h \
- arch/x86/include/asm/paravirt_types.h arch/x86/include/asm/desc_defs.h \
- arch/x86/include/asm/kmap_types.h include/asm-generic/kmap_types.h \
+ arch/x86/include/uapi/asm/ptrace-abi.h include/asm-generic/ptrace.h \
+ arch/x86/include/uapi/asm/sigcontext.h \
  arch/x86/include/asm/pgtable_types.h \
  arch/x86/include/asm/pgtable_64_types.h arch/x86/include/asm/sparsemem.h \
- include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/nospec-branch.h \
- include/linux/static_key.h arch/x86/include/asm/alternative-asm.h \
- arch/x86/include/asm/msr-index.h arch/x86/include/asm/spinlock_types.h \
- include/asm-generic/qspinlock_types.h \
- include/asm-generic/qrwlock_types.h include/asm-generic/ptrace.h \
- arch/x86/include/uapi/asm/sigcontext.h arch/x86/include/asm/msr.h \
+ include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/msr.h \
  arch/x86/include/asm/msr-index.h arch/x86/include/uapi/asm/errno.h \
  include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
  arch/x86/include/asm/cpumask.h include/linux/cpumask.h \
@@ -91,21 +85,25 @@ mac80211.o: /home/finger/rtlwifi_new1/ma
  include/asm-generic/atomic-instrumented.h \
  include/linux/tracepoint-defs.h include/linux/atomic.h \
  include/linux/atomic-fallback.h include/asm-generic/atomic-long.h \
- include/linux/errno.h include/uapi/linux/errno.h \
+ include/linux/static_key.h include/linux/errno.h \
+ include/uapi/linux/errno.h arch/x86/include/asm/desc_defs.h \
  arch/x86/include/asm/special_insns.h arch/x86/include/asm/fpu/types.h \
  arch/x86/include/asm/unwind_hints.h arch/x86/include/asm/orc_types.h \
  include/linux/personality.h include/uapi/linux/personality.h \
  include/linux/err.h include/linux/irqflags.h \
- arch/x86/include/asm/irqflags.h include/linux/bottom_half.h \
- arch/x86/include/generated/asm/mmiowb.h include/asm-generic/mmiowb.h \
- include/linux/spinlock_types.h include/linux/lockdep.h \
+ arch/x86/include/asm/irqflags.h arch/x86/include/asm/nospec-branch.h \
+ arch/x86/include/asm/alternative-asm.h arch/x86/include/asm/msr-index.h \
+ include/linux/bottom_half.h arch/x86/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h include/linux/spinlock_types.h \
+ arch/x86/include/asm/spinlock_types.h \
+ include/asm-generic/qspinlock_types.h \
+ include/asm-generic/qrwlock_types.h include/linux/lockdep.h \
  include/linux/rwlock_types.h arch/x86/include/asm/spinlock.h \
- arch/x86/include/asm/paravirt.h arch/x86/include/asm/frame.h \
- arch/x86/include/asm/qspinlock.h include/asm-generic/qspinlock.h \
- arch/x86/include/asm/qrwlock.h include/asm-generic/qrwlock.h \
- include/linux/rwlock.h include/linux/spinlock_api_smp.h \
- include/linux/rwlock_api_smp.h include/linux/time32.h \
- include/linux/timex.h include/uapi/linux/timex.h \
+ arch/x86/include/asm/paravirt.h arch/x86/include/asm/qspinlock.h \
+ include/asm-generic/qspinlock.h arch/x86/include/asm/qrwlock.h \
+ include/asm-generic/qrwlock.h include/linux/rwlock.h \
+ include/linux/spinlock_api_smp.h include/linux/rwlock_api_smp.h \
+ include/linux/time32.h include/linux/timex.h include/uapi/linux/timex.h \
  include/uapi/linux/param.h arch/x86/include/uapi/asm/param.h \
  include/asm-generic/param.h include/uapi/asm-generic/param.h \
  arch/x86/include/asm/timex.h arch/x86/include/asm/tsc.h \
@@ -124,24 +122,24 @@ mac80211.o: /home/finger/rtlwifi_new1/ma
  include/linux/auxvec.h include/uapi/linux/auxvec.h \
  arch/x86/include/uapi/asm/auxvec.h include/linux/rwsem.h \
  include/linux/osq_lock.h include/linux/completion.h \
- include/linux/uprobes.h include/linux/workqueue.h include/linux/timer.h \
- include/linux/ktime.h include/linux/jiffies.h \
- include/generated/timeconst.h include/linux/timekeeping.h \
- include/linux/timekeeping32.h include/linux/debugobjects.h \
- arch/x86/include/asm/mmu.h include/linux/mutex.h \
- include/linux/debug_locks.h include/linux/page-flags.h \
- include/linux/memory_hotplug.h include/linux/notifier.h \
- include/linux/srcu.h include/linux/rcu_segcblist.h \
+ include/linux/uprobes.h arch/x86/include/asm/uprobes.h \
+ include/linux/notifier.h include/linux/mutex.h \
+ include/linux/debug_locks.h include/linux/srcu.h \
+ include/linux/workqueue.h include/linux/timer.h include/linux/ktime.h \
+ include/linux/jiffies.h include/generated/timeconst.h \
+ include/linux/timekeeping.h include/linux/timekeeping32.h \
+ include/linux/debugobjects.h include/linux/rcu_segcblist.h \
  include/linux/srcutree.h include/linux/rcu_node_tree.h \
- arch/x86/include/asm/mmzone.h arch/x86/include/asm/mmzone_64.h \
- arch/x86/include/asm/smp.h arch/x86/include/asm/mpspec.h \
- arch/x86/include/asm/mpspec_def.h arch/x86/include/asm/x86_init.h \
- arch/x86/include/asm/apicdef.h arch/x86/include/asm/apic.h \
- arch/x86/include/asm/fixmap.h arch/x86/include/asm/acpi.h \
- include/acpi/pdc_intel.h arch/x86/include/asm/numa.h \
- arch/x86/include/asm/topology.h include/asm-generic/topology.h \
- arch/x86/include/asm/realmode.h arch/x86/include/asm/io.h \
- arch/x86/include/generated/asm/early_ioremap.h \
+ arch/x86/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h arch/x86/include/asm/mmzone.h \
+ arch/x86/include/asm/mmzone_64.h arch/x86/include/asm/smp.h \
+ arch/x86/include/asm/mpspec.h arch/x86/include/asm/mpspec_def.h \
+ arch/x86/include/asm/x86_init.h arch/x86/include/asm/apicdef.h \
+ arch/x86/include/asm/apic.h arch/x86/include/asm/fixmap.h \
+ arch/x86/include/asm/acpi.h include/acpi/pdc_intel.h \
+ arch/x86/include/asm/numa.h arch/x86/include/asm/topology.h \
+ include/asm-generic/topology.h arch/x86/include/asm/realmode.h \
+ arch/x86/include/asm/io.h arch/x86/include/generated/asm/early_ioremap.h \
  include/asm-generic/early_ioremap.h include/asm-generic/iomap.h \
  include/asm-generic/pci_iomap.h include/asm-generic/io.h \
  include/linux/logic_pio.h include/linux/fwnode.h include/linux/vmalloc.h \
@@ -281,9 +279,8 @@ mac80211.o: /home/finger/rtlwifi_new1/ma
  include/linux/cgroup-defs.h include/linux/bpf-cgroup.h \
  include/linux/bpf.h include/uapi/linux/bpf.h \
  include/uapi/linux/bpf_common.h include/linux/file.h \
- include/linux/rbtree_latch.h include/linux/bpf_types.h \
- include/linux/psi_types.h include/linux/kthread.h \
- include/linux/cgroup_subsys.h include/net/xdp.h \
+ include/linux/rbtree_latch.h include/linux/psi_types.h \
+ include/linux/kthread.h include/linux/cgroup_subsys.h include/net/xdp.h \
  include/uapi/linux/neighbour.h include/linux/netlink.h include/net/scm.h \
  include/linux/security.h include/linux/sched/signal.h \
  include/linux/signal.h include/linux/sched/jobctl.h \
@@ -308,13 +305,11 @@ mac80211.o: /home/finger/rtlwifi_new1/ma
  include/linux/vmpressure.h include/linux/eventfd.h \
  include/linux/writeback.h include/linux/flex_proportions.h \
  include/linux/backing-dev-defs.h include/linux/blk_types.h \
- include/linux/bvec.h include/linux/bio.h include/linux/highmem.h \
- arch/x86/include/asm/cacheflush.h include/asm-generic/cacheflush.h \
- include/linux/mempool.h include/linux/filter.h \
- include/linux/cryptohash.h include/linux/set_memory.h \
- arch/x86/include/asm/set_memory.h include/asm-generic/set_memory.h \
- include/linux/kallsyms.h include/linux/module.h include/linux/kmod.h \
- include/linux/umh.h include/linux/elf.h arch/x86/include/asm/elf.h \
+ include/linux/bvec.h include/linux/filter.h include/linux/cryptohash.h \
+ include/linux/set_memory.h arch/x86/include/asm/set_memory.h \
+ include/asm-generic/set_memory.h include/linux/kallsyms.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/x86/include/asm/elf.h \
  arch/x86/include/asm/fsgsbase.h arch/x86/include/asm/vdso.h \
  include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
  include/linux/moduleparam.h include/linux/error-injection.h \
@@ -336,8 +331,12 @@ mac80211.o: /home/finger/rtlwifi_new1/ma
  include/uapi/linux/tcp.h include/linux/udp.h include/uapi/linux/udp.h \
  include/net/ieee80211_radiotap.h include/linux/firmware.h \
  include/linux/average.h include/linux/bitfield.h \
- /home/finger/rtlwifi_new1/util.h /home/finger/rtlwifi_new1/hci.h \
- /home/finger/rtlwifi_new1/sec.h /home/finger/rtlwifi_new1/tx.h \
- /home/finger/rtlwifi_new1/fw.h /home/finger/rtlwifi_new1/mac.h \
- /home/finger/rtlwifi_new1/ps.h /home/finger/rtlwifi_new1/reg.h \
- /home/finger/rtlwifi_new1/debug.h
+ drivers/net/wireless/realtek/rtw88/util.h \
+ drivers/net/wireless/realtek/rtw88/hci.h \
+ drivers/net/wireless/realtek/rtw88/sec.h \
+ drivers/net/wireless/realtek/rtw88/tx.h \
+ drivers/net/wireless/realtek/rtw88/fw.h \
+ drivers/net/wireless/realtek/rtw88/mac.h \
+ drivers/net/wireless/realtek/rtw88/ps.h \
+ drivers/net/wireless/realtek/rtw88/reg.h \
+ drivers/net/wireless/realtek/rtw88/debug.h
Only in drivers/net/wireless/realtek/rtw88/: mac.c
Only in drivers/net/wireless/realtek/rtw88/: mac.h
Only in drivers/net/wireless/realtek/rtw88/: mac.o
Only in drivers/net/wireless/realtek/rtw88/: .mac.o.cmd
Only in drivers/net/wireless/realtek/rtw88/: main.c
Only in drivers/net/wireless/realtek/rtw88/: main.h
Only in drivers/net/wireless/realtek/rtw88/: main.o
Only in drivers/net/wireless/realtek/rtw88/: .main.o.cmd
diff -upr /home/finger/rtlwifi_new1/.main.o.d drivers/net/wireless/realtek/rtw88/.main.o.d
--- /home/finger/rtlwifi_new1/.main.o.d	2019-06-14 10:01:32.003246709 -0500
+++ drivers/net/wireless/realtek/rtw88/.main.o.d	2019-06-14 20:50:55.974322634 -0500
@@ -1,13 +1,12 @@
-main.o: /home/finger/rtlwifi_new1/main.c include/linux/kconfig.h \
+main.o: drivers/net/wireless/realtek/rtw88/main.c include/linux/kconfig.h \
  include/generated/autoconf.h include/linux/compiler_types.h \
  include/linux/compiler_attributes.h include/linux/compiler-gcc.h \
- /home/finger/rtlwifi_new1/main.h include/generated/uapi/linux/version.h \
- include/net/mac80211.h include/linux/bug.h arch/x86/include/asm/bug.h \
- include/linux/stringify.h include/asm-generic/bug.h \
- include/linux/compiler.h include/linux/compiler_types.h \
- include/uapi/linux/types.h arch/x86/include/uapi/asm/types.h \
- include/uapi/asm-generic/types.h include/asm-generic/int-ll64.h \
- include/uapi/asm-generic/int-ll64.h \
+ drivers/net/wireless/realtek/rtw88/main.h include/net/mac80211.h \
+ include/linux/bug.h arch/x86/include/asm/bug.h include/linux/stringify.h \
+ include/asm-generic/bug.h include/linux/compiler.h \
+ include/linux/compiler_types.h include/uapi/linux/types.h \
+ arch/x86/include/uapi/asm/types.h include/uapi/asm-generic/types.h \
+ include/asm-generic/int-ll64.h include/uapi/asm-generic/int-ll64.h \
  arch/x86/include/uapi/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h include/uapi/asm-generic/bitsperlong.h \
  include/uapi/linux/posix_types.h include/linux/stddef.h \
@@ -69,17 +68,11 @@ main.o: /home/finger/rtlwifi_new1/main.c
  arch/x86/include/uapi/asm/processor-flags.h \
  arch/x86/include/asm/math_emu.h arch/x86/include/asm/ptrace.h \
  arch/x86/include/asm/segment.h arch/x86/include/uapi/asm/ptrace.h \
- arch/x86/include/uapi/asm/ptrace-abi.h \
- arch/x86/include/asm/paravirt_types.h arch/x86/include/asm/desc_defs.h \
- arch/x86/include/asm/kmap_types.h include/asm-generic/kmap_types.h \
+ arch/x86/include/uapi/asm/ptrace-abi.h include/asm-generic/ptrace.h \
+ arch/x86/include/uapi/asm/sigcontext.h \
  arch/x86/include/asm/pgtable_types.h \
  arch/x86/include/asm/pgtable_64_types.h arch/x86/include/asm/sparsemem.h \
- include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/nospec-branch.h \
- include/linux/static_key.h arch/x86/include/asm/alternative-asm.h \
- arch/x86/include/asm/msr-index.h arch/x86/include/asm/spinlock_types.h \
- include/asm-generic/qspinlock_types.h \
- include/asm-generic/qrwlock_types.h include/asm-generic/ptrace.h \
- arch/x86/include/uapi/asm/sigcontext.h arch/x86/include/asm/msr.h \
+ include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/msr.h \
  arch/x86/include/asm/msr-index.h arch/x86/include/uapi/asm/errno.h \
  include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
  arch/x86/include/asm/cpumask.h include/linux/cpumask.h \
@@ -91,21 +84,25 @@ main.o: /home/finger/rtlwifi_new1/main.c
  include/asm-generic/atomic-instrumented.h \
  include/linux/tracepoint-defs.h include/linux/atomic.h \
  include/linux/atomic-fallback.h include/asm-generic/atomic-long.h \
- include/linux/errno.h include/uapi/linux/errno.h \
+ include/linux/static_key.h include/linux/errno.h \
+ include/uapi/linux/errno.h arch/x86/include/asm/desc_defs.h \
  arch/x86/include/asm/special_insns.h arch/x86/include/asm/fpu/types.h \
  arch/x86/include/asm/unwind_hints.h arch/x86/include/asm/orc_types.h \
  include/linux/personality.h include/uapi/linux/personality.h \
  include/linux/err.h include/linux/irqflags.h \
- arch/x86/include/asm/irqflags.h include/linux/bottom_half.h \
- arch/x86/include/generated/asm/mmiowb.h include/asm-generic/mmiowb.h \
- include/linux/spinlock_types.h include/linux/lockdep.h \
+ arch/x86/include/asm/irqflags.h arch/x86/include/asm/nospec-branch.h \
+ arch/x86/include/asm/alternative-asm.h arch/x86/include/asm/msr-index.h \
+ include/linux/bottom_half.h arch/x86/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h include/linux/spinlock_types.h \
+ arch/x86/include/asm/spinlock_types.h \
+ include/asm-generic/qspinlock_types.h \
+ include/asm-generic/qrwlock_types.h include/linux/lockdep.h \
  include/linux/rwlock_types.h arch/x86/include/asm/spinlock.h \
- arch/x86/include/asm/paravirt.h arch/x86/include/asm/frame.h \
- arch/x86/include/asm/qspinlock.h include/asm-generic/qspinlock.h \
- arch/x86/include/asm/qrwlock.h include/asm-generic/qrwlock.h \
- include/linux/rwlock.h include/linux/spinlock_api_smp.h \
- include/linux/rwlock_api_smp.h include/linux/time32.h \
- include/linux/timex.h include/uapi/linux/timex.h \
+ arch/x86/include/asm/paravirt.h arch/x86/include/asm/qspinlock.h \
+ include/asm-generic/qspinlock.h arch/x86/include/asm/qrwlock.h \
+ include/asm-generic/qrwlock.h include/linux/rwlock.h \
+ include/linux/spinlock_api_smp.h include/linux/rwlock_api_smp.h \
+ include/linux/time32.h include/linux/timex.h include/uapi/linux/timex.h \
  include/uapi/linux/param.h arch/x86/include/uapi/asm/param.h \
  include/asm-generic/param.h include/uapi/asm-generic/param.h \
  arch/x86/include/asm/timex.h arch/x86/include/asm/tsc.h \
@@ -124,24 +121,24 @@ main.o: /home/finger/rtlwifi_new1/main.c
  include/linux/auxvec.h include/uapi/linux/auxvec.h \
  arch/x86/include/uapi/asm/auxvec.h include/linux/rwsem.h \
  include/linux/osq_lock.h include/linux/completion.h \
- include/linux/uprobes.h include/linux/workqueue.h include/linux/timer.h \
- include/linux/ktime.h include/linux/jiffies.h \
- include/generated/timeconst.h include/linux/timekeeping.h \
- include/linux/timekeeping32.h include/linux/debugobjects.h \
- arch/x86/include/asm/mmu.h include/linux/mutex.h \
- include/linux/debug_locks.h include/linux/page-flags.h \
- include/linux/memory_hotplug.h include/linux/notifier.h \
- include/linux/srcu.h include/linux/rcu_segcblist.h \
+ include/linux/uprobes.h arch/x86/include/asm/uprobes.h \
+ include/linux/notifier.h include/linux/mutex.h \
+ include/linux/debug_locks.h include/linux/srcu.h \
+ include/linux/workqueue.h include/linux/timer.h include/linux/ktime.h \
+ include/linux/jiffies.h include/generated/timeconst.h \
+ include/linux/timekeeping.h include/linux/timekeeping32.h \
+ include/linux/debugobjects.h include/linux/rcu_segcblist.h \
  include/linux/srcutree.h include/linux/rcu_node_tree.h \
- arch/x86/include/asm/mmzone.h arch/x86/include/asm/mmzone_64.h \
- arch/x86/include/asm/smp.h arch/x86/include/asm/mpspec.h \
- arch/x86/include/asm/mpspec_def.h arch/x86/include/asm/x86_init.h \
- arch/x86/include/asm/apicdef.h arch/x86/include/asm/apic.h \
- arch/x86/include/asm/fixmap.h arch/x86/include/asm/acpi.h \
- include/acpi/pdc_intel.h arch/x86/include/asm/numa.h \
- arch/x86/include/asm/topology.h include/asm-generic/topology.h \
- arch/x86/include/asm/realmode.h arch/x86/include/asm/io.h \
- arch/x86/include/generated/asm/early_ioremap.h \
+ arch/x86/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h arch/x86/include/asm/mmzone.h \
+ arch/x86/include/asm/mmzone_64.h arch/x86/include/asm/smp.h \
+ arch/x86/include/asm/mpspec.h arch/x86/include/asm/mpspec_def.h \
+ arch/x86/include/asm/x86_init.h arch/x86/include/asm/apicdef.h \
+ arch/x86/include/asm/apic.h arch/x86/include/asm/fixmap.h \
+ arch/x86/include/asm/acpi.h include/acpi/pdc_intel.h \
+ arch/x86/include/asm/numa.h arch/x86/include/asm/topology.h \
+ include/asm-generic/topology.h arch/x86/include/asm/realmode.h \
+ arch/x86/include/asm/io.h arch/x86/include/generated/asm/early_ioremap.h \
  include/asm-generic/early_ioremap.h include/asm-generic/iomap.h \
  include/asm-generic/pci_iomap.h include/asm-generic/io.h \
  include/linux/logic_pio.h include/linux/fwnode.h include/linux/vmalloc.h \
@@ -281,9 +278,8 @@ main.o: /home/finger/rtlwifi_new1/main.c
  include/linux/cgroup-defs.h include/linux/bpf-cgroup.h \
  include/linux/bpf.h include/uapi/linux/bpf.h \
  include/uapi/linux/bpf_common.h include/linux/file.h \
- include/linux/rbtree_latch.h include/linux/bpf_types.h \
- include/linux/psi_types.h include/linux/kthread.h \
- include/linux/cgroup_subsys.h include/net/xdp.h \
+ include/linux/rbtree_latch.h include/linux/psi_types.h \
+ include/linux/kthread.h include/linux/cgroup_subsys.h include/net/xdp.h \
  include/uapi/linux/neighbour.h include/linux/netlink.h include/net/scm.h \
  include/linux/security.h include/linux/sched/signal.h \
  include/linux/signal.h include/linux/sched/jobctl.h \
@@ -308,13 +304,11 @@ main.o: /home/finger/rtlwifi_new1/main.c
  include/linux/vmpressure.h include/linux/eventfd.h \
  include/linux/writeback.h include/linux/flex_proportions.h \
  include/linux/backing-dev-defs.h include/linux/blk_types.h \
- include/linux/bvec.h include/linux/bio.h include/linux/highmem.h \
- arch/x86/include/asm/cacheflush.h include/asm-generic/cacheflush.h \
- include/linux/mempool.h include/linux/filter.h \
- include/linux/cryptohash.h include/linux/set_memory.h \
- arch/x86/include/asm/set_memory.h include/asm-generic/set_memory.h \
- include/linux/kallsyms.h include/linux/module.h include/linux/kmod.h \
- include/linux/umh.h include/linux/elf.h arch/x86/include/asm/elf.h \
+ include/linux/bvec.h include/linux/filter.h include/linux/cryptohash.h \
+ include/linux/set_memory.h arch/x86/include/asm/set_memory.h \
+ include/asm-generic/set_memory.h include/linux/kallsyms.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/x86/include/asm/elf.h \
  arch/x86/include/asm/fsgsbase.h arch/x86/include/asm/vdso.h \
  include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
  include/linux/moduleparam.h include/linux/error-injection.h \
@@ -336,9 +330,14 @@ main.o: /home/finger/rtlwifi_new1/main.c
  include/uapi/linux/tcp.h include/linux/udp.h include/uapi/linux/udp.h \
  include/net/ieee80211_radiotap.h include/linux/firmware.h \
  include/linux/average.h include/linux/bitfield.h \
- /home/finger/rtlwifi_new1/util.h /home/finger/rtlwifi_new1/hci.h \
- /home/finger/rtlwifi_new1/regd.h /home/finger/rtlwifi_new1/fw.h \
- /home/finger/rtlwifi_new1/ps.h /home/finger/rtlwifi_new1/sec.h \
- /home/finger/rtlwifi_new1/mac.h /home/finger/rtlwifi_new1/phy.h \
- /home/finger/rtlwifi_new1/debug.h /home/finger/rtlwifi_new1/reg.h \
- /home/finger/rtlwifi_new1/efuse.h
+ drivers/net/wireless/realtek/rtw88/util.h \
+ drivers/net/wireless/realtek/rtw88/hci.h \
+ drivers/net/wireless/realtek/rtw88/regd.h \
+ drivers/net/wireless/realtek/rtw88/fw.h \
+ drivers/net/wireless/realtek/rtw88/ps.h \
+ drivers/net/wireless/realtek/rtw88/sec.h \
+ drivers/net/wireless/realtek/rtw88/mac.h \
+ drivers/net/wireless/realtek/rtw88/phy.h \
+ drivers/net/wireless/realtek/rtw88/debug.h \
+ drivers/net/wireless/realtek/rtw88/reg.h \
+ drivers/net/wireless/realtek/rtw88/efuse.h
diff -upr /home/finger/rtlwifi_new1/Makefile drivers/net/wireless/realtek/rtw88/Makefile
--- /home/finger/rtlwifi_new1/Makefile	2019-06-14 10:13:19.882404512 -0500
+++ drivers/net/wireless/realtek/rtw88/Makefile	2019-05-29 10:27:03.755295149 -0500
@@ -1,187 +1,22 @@
-# SPDX-License-Identifier: GPL-2.0
-SHELL := /bin/sh
-CC = gcc
-KVER  := $(shell uname -r)
-#KVER  :=
-KSRC := /lib/modules/$(KVER)/build
-#KSRC := /work/linux-src/linux-stable
-FIRMWAREDIR := /lib/firmware/
-PWD := $(shell pwd)
-CLR_MODULE_FILES := *.mod.c *.mod *.o .*.cmd *.ko *~ .tmp_versions* modules.order Module.symvers
-SYMBOL_FILE := Module.symvers
-# Handle the move of the entire rtlwifi tree
-ifneq ("","$(wildcard /lib/modules/$(KVER)/kernel/drivers/net/wireless/realtek)")
-MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/realtek/rtlwifi
-else
-MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/rtlwifi
-endif
+# SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
 
-#Handle the compression option for modules in 3.18+
-ifneq ("","$(wildcard $(MODDESTDIR)/*.ko.gz)")
-COMPRESS_GZIP := y
-endif
-ifneq ("","$(wildcard $(MODDESTDIR)/*.ko.xz)")
-COMPRESS_XZ := y
-endif
+obj-$(CONFIG_RTW88_CORE)	+= rtw88.o
+rtw88-y += main.o \
+	   mac80211.o \
+	   util.o \
+	   debug.o \
+	   tx.o \
+	   rx.o \
+	   mac.o \
+	   phy.o \
+	   efuse.o \
+	   fw.o \
+	   ps.o \
+	   sec.o \
+	   regd.o
 
-ccflags-y += -O2
+rtw88-$(CONFIG_RTW88_8822BE)	+= rtw8822b.o rtw8822b_table.o
+rtw88-$(CONFIG_RTW88_8822CE)	+= rtw8822c.o rtw8822c_table.o
 
-obj-m		+= rtlwifi.o
-rtlwifi-objs	:=		\
-		base.o		\
-		cam.o		\
-		core.o		\
-		debug.o		\
-		efuse.o		\
-		ps.o		\
-		rc.o		\
-		regd.o		\
-		stats.o
-
-rtl8192c_common-objs +=		\
-
-obj-m				+= rtl_pci.o
-rtl_pci-objs	:=		pci.o
-
-obj-m				+= rtl_usb.o
-rtl_usb-objs	:=		usb.o
-
-obj-m				+= rtl8192c/
-obj-m				+= rtl8192ce/
-obj-m				+= rtl8192cu/
-obj-m				+= rtl8192se/
-obj-m				+= rtl8192de/
-obj-m				+= rtl8723ae/
-obj-m				+= rtl8723be/
-obj-m				+= rtl8723de/
-obj-m				+= rtl8188ee/
-obj-m				+= btcoexist/
-obj-m				+= halmac/
-obj-m				+= phydm/
-obj-m				+= rtl8723com/
-obj-m				+= rtl8821ae/
-obj-m				+= rtl8822be/
-obj-m				+= rtl8192ee/
-
-ccflags-y += -D__CHECK_ENDIAN__
-#subdir-ccflags-y += -Werror
-ccflags-y += -DCONFIG_RTLWIFI_DEBUG
-subdir-ccflags-y += -DCONFIG_RTLWIFI_DEBUG
-
-ifeq ("$(KVER)", $(filter "$(KVER)", "3.14.35-031435-generic" "3.14.35-031435-lowlatency"))
-ccflags-y += -D_ieee80211_is_robust_mgmt_frame=ieee80211_is_robust_mgmt_frame
-subdir-ccflags-y += -D_ieee80211_is_robust_mgmt_frame=ieee80211_is_robust_mgmt_frame
-endif
-
-# for uncooked code
-uncooked_ccflags-y += -DBT_SUPPORT=1
-uncooked_ccflags-y += -DCOEX_SUPPORT=1
-uncooked_ccflags-y += -DRTL8822B_SUPPORT=1
-uncooked_ccflags-y += -DRTL8723D_SUPPORT=1
-ccflags-y += $(uncooked_ccflags-y)
-subdir-ccflags-y += $(uncooked_ccflags-y)
-
-CHECKFLAGS += -D__CHECK_ENDIAN__
-
-all:
-	$(MAKE) -C $(KSRC) M=$(PWD) modules
-install: all
-ifeq (,$(wildcard ./backup_drivers.tar))
-	@echo Making backups
-	@tar cPf backup_drivers.tar $(MODDESTDIR)
-endif
-
-	@mkdir -p $(MODDESTDIR)/btcoexist
-	@mkdir -p $(MODDESTDIR)/halmac
-	@mkdir -p $(MODDESTDIR)/phydm
-	@mkdir -p $(MODDESTDIR)/rtl8188ee
-	@mkdir -p $(MODDESTDIR)/rtl8192c
-	@mkdir -p $(MODDESTDIR)/rtl8192ce
-	@mkdir -p $(MODDESTDIR)/rtl8192cu
-	@mkdir -p $(MODDESTDIR)/rtl8192de
-	@mkdir -p $(MODDESTDIR)/rtl8192ee
-	@mkdir -p $(MODDESTDIR)/rtl8192se
-	@mkdir -p $(MODDESTDIR)/rtl8723ae
-	@mkdir -p $(MODDESTDIR)/rtl8723be
-	@mkdir -p $(MODDESTDIR)/rtl8723de
-	@mkdir -p $(MODDESTDIR)/rtl8723com
-	@mkdir -p $(MODDESTDIR)/rtl8821ae
-	@mkdir -p $(MODDESTDIR)/rtl8822be
-	@install -p -D -m 644 rtl_pci.ko $(MODDESTDIR)
-	@install -p -D -m 644 rtl_usb.ko $(MODDESTDIR)
-	@install -p -D -m 644 rtlwifi.ko $(MODDESTDIR)
-	@install -p -D -m 644 ./btcoexist/btcoexist.ko $(MODDESTDIR)/btcoexist
-	@install -p -D -m 644 ./halmac/halmac.ko $(MODDESTDIR)/halmac
-	@install -p -D -m 644 ./phydm/phydm_mod.ko $(MODDESTDIR)/phydm
-	@install -p -D -m 644 ./rtl8188ee/rtl8188ee.ko $(MODDESTDIR)/rtl8188ee
-	@install -p -D -m 644 ./rtl8192c/rtl8192c-common.ko $(MODDESTDIR)/rtl8192c
-	@install -p -D -m 644 ./rtl8192ce/rtl8192ce.ko $(MODDESTDIR)/rtl8192ce
-	@install -p -D -m 644 ./rtl8192cu/rtl8192cu.ko $(MODDESTDIR)/rtl8192cu
-	@install -p -D -m 644 ./rtl8192de/rtl8192de.ko $(MODDESTDIR)/rtl8192de
-	@install -p -D -m 644 ./rtl8192ee/rtl8192ee.ko $(MODDESTDIR)/rtl8192ee
-	@install -p -D -m 644 ./rtl8192se/rtl8192se.ko $(MODDESTDIR)/rtl8192se
-	@install -p -D -m 644 ./rtl8723ae/rtl8723ae.ko $(MODDESTDIR)/rtl8723ae
-	@install -p -D -m 644 ./rtl8723be/rtl8723be.ko $(MODDESTDIR)/rtl8723be
-	@install -p -D -m 644 ./rtl8723de/rtl8723de.ko $(MODDESTDIR)/rtl8723de
-	@install -p -D -m 644 ./rtl8821ae/rtl8821ae.ko $(MODDESTDIR)/rtl8821ae
-	@install -p -D -m 644 ./rtl8822be/rtl8822be.ko $(MODDESTDIR)/rtl8822be
-	@install -p -D -m 644 ./rtl8723com/rtl8723-common.ko $(MODDESTDIR)/rtl8723com
-ifeq ($(COMPRESS_GZIP), y)
-	@gzip -f $(MODDESTDIR)/*.ko
-	@gzip -f $(MODDESTDIR)/btcoexist/*.ko
-	@gzip -f $(MODDESTDIR)/rtl8*/*.ko
-	@gzip -f $(MODDESTDIR)/halmac/*.ko
-	@gzip -f $(MODDESTDIR)/phydm/*.ko
-endif
-ifeq ($(COMPRESS_XZ), y)
-	@xz -f $(MODDESTDIR)/*.ko
-	@xz -f $(MODDESTDIR)/btcoexist/*.ko
-	@xz -f $(MODDESTDIR)/rtl8*/*.ko
-	@xz -f $(MODDESTDIR)/halmac/*.ko
-	@xz -f $(MODDESTDIR)/phydm/*.ko
-endif
-
-	@depmod -a
-
-	@#copy firmware images to target folder
-	@cp -fr firmware/rtlwifi/ $(FIRMWAREDIR)/
-	@echo "Install rtlwifi SUCCESS"
-
-uninstall:
-	@rm $(MODDESTDIR)/*.ko*
-	@rm $(MODDESTDIR)/btcoexist/*.ko*
-	@rm $(MODDESTDIR)/halmac/*.ko*
-	@rm $(MODDESTDIR)/phydm/*.ko*
-	@rm $(MODDESTDIR)/rtl8188ee/*.ko*
-	@rm $(MODDESTDIR)/rtl8192c/*.ko*
-	@rm $(MODDESTDIR)/rtl8192ce/*.ko*
-	@rm $(MODDESTDIR)/rtl8192cu/*.ko*
-	@rm $(MODDESTDIR)/rtl8192de/*.ko*
-	@rm $(MODDESTDIR)/rtl8192ee/*.ko*
-	@rm $(MODDESTDIR)/rtl8192se/*.ko*
-	@rm $(MODDESTDIR)/rtl8723ae/*.ko*
-	@rm $(MODDESTDIR)/rtl8723be/*.ko*
-	@rm $(MODDESTDIR)/rtl8723de/*.ko*
-	@rm $(MODDESTDIR)/rtl8821ae/*.ko*
-	@rm $(MODDESTDIR)/rtl8822be/*.ko*
-	@rm $(MODDESTDIR)/rtl8723com/*.ko*
-ifneq (,$(wildcard ./backup_drivers.tar))
-	@echo Restoring backups
-	@tar xvPf backup_drivers.tar
-endif
-
-	@depmod -a
-
-	@echo "Uninstall rtlwifi SUCCESS"
-
-clean:
-	@find halmac/ \( -name "*.mod.c" -o -name "*.mod" -o -name "*.o" -o -name ".*.cmd" -o -name "*.ko" -o -name "*~" \) -exec rm {} \;
-	@find phydm/ \( -name "*.mod.c" -o -name "*.mod" -o -name "*.o" -o -name ".*.cmd" -o -name "*.ko" -o -name "*~" \) -exec rm {} \;
-	@rm -fr *.mod.c *.mod *.o .*.cmd *.ko *~ .cache.mk
-	@rm -fr rtl8*/*.mod.c rtl8*/*.mod rtl8*/*.o rtl8*/.*.cmd rtl8*/*.ko rtl8*/*~
-	@rm -fr bt*/*.mod.c bt*/*.mod bt*/*.o bt*/.*.cmd bt*/*.ko bt*/*~
-	@rm -fr .tmp_versions
-	@rm -fr Modules.symvers
-	@rm -fr Module.symvers
-	@rm -fr Module.markers
-	@rm -fr modules.order
+obj-$(CONFIG_RTW88_PCI)		+= rtwpci.o
+rtwpci-objs			:= pci.o
Only in drivers/net/wireless/realtek/rtw88/: modules.order
diff -upr /home/finger/rtlwifi_new1/pci.c drivers/net/wireless/realtek/rtw88/pci.c
--- /home/finger/rtlwifi_new1/pci.c	2019-06-14 10:13:19.914404655 -0500
+++ drivers/net/wireless/realtek/rtw88/pci.c	2019-05-29 10:27:03.755295149 -0500
@@ -1,2524 +1,1213 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/* Copyright(c) 2018-2019  Realtek Corporation
+ */
 
-#include "wifi.h"
-#include "core.h"
-#include "pci.h"
-#include "base.h"
-#include "ps.h"
-#include "efuse.h"
-#include <linux/interrupt.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-#include <linux/export.h>
-#endif
-#include <linux/kmemleak.h>
 #include <linux/module.h>
-
-MODULE_AUTHOR("lizhaoming	<chaoming_li@realsil.com.cn>");
-MODULE_AUTHOR("Realtek WlanFAE	<wlanfae@realtek.com>");
-MODULE_AUTHOR("Larry Finger	<Larry.FInger@lwfinger.net>");
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("PCI basic driver for rtlwifi");
-
-static const u16 pcibridge_vendors[PCI_BRIDGE_VENDOR_MAX] = {
-	INTEL_VENDOR_ID,
-	ATI_VENDOR_ID,
-	AMD_VENDOR_ID,
-	SIS_VENDOR_ID
-};
-
-static const u8 ac_to_hwq[] = {
-	VO_QUEUE,
-	VI_QUEUE,
-	BE_QUEUE,
-	BK_QUEUE
+#include <linux/pci.h>
+#include "main.h"
+#include "pci.h"
+#include "tx.h"
+#include "rx.h"
+#include "debug.h"
+
+static u32 rtw_pci_tx_queue_idx_addr[] = {
+	[RTW_TX_QUEUE_BK]	= RTK_PCI_TXBD_IDX_BKQ,
+	[RTW_TX_QUEUE_BE]	= RTK_PCI_TXBD_IDX_BEQ,
+	[RTW_TX_QUEUE_VI]	= RTK_PCI_TXBD_IDX_VIQ,
+	[RTW_TX_QUEUE_VO]	= RTK_PCI_TXBD_IDX_VOQ,
+	[RTW_TX_QUEUE_MGMT]	= RTK_PCI_TXBD_IDX_MGMTQ,
+	[RTW_TX_QUEUE_HI0]	= RTK_PCI_TXBD_IDX_HI0Q,
+	[RTW_TX_QUEUE_H2C]	= RTK_PCI_TXBD_IDX_H2CQ,
 };
 
-static u8 _rtl_mac_to_hwqueue(struct ieee80211_hw *hw, struct sk_buff *skb)
+static u8 rtw_pci_get_tx_qsel(struct sk_buff *skb, u8 queue)
 {
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	__le16 fc = rtl_get_fc(skb);
-	u8 queue_index = skb_get_queue_mapping(skb);
-	struct ieee80211_hdr *hdr;
-
-	if (unlikely(ieee80211_is_beacon(fc)))
-		return BEACON_QUEUE;
-	if (ieee80211_is_mgmt(fc) || ieee80211_is_ctl(fc))
-		return MGNT_QUEUE;
-	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE)
-		if (ieee80211_is_nullfunc(fc))
-			return HIGH_QUEUE;
-	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8822BE) {
-		hdr = rtl_get_hdr(skb);
-
-		if (is_multicast_ether_addr(hdr->addr1) ||
-		    is_broadcast_ether_addr(hdr->addr1))
-			return HIGH_QUEUE;
-	}
-
-	return ac_to_hwq[queue_index];
-}
-
-/* Update PCI dependent default settings*/
-static void _rtl_pci_update_default_setting(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	u8 pcibridge_vendor = pcipriv->ndis_adapter.pcibridge_vendor;
-	u8 init_aspm;
-
-	ppsc->reg_rfps_level = 0;
-	ppsc->support_aspm = false;
-
-	/*Update PCI ASPM setting */
-	ppsc->const_amdpci_aspm = rtlpci->const_amdpci_aspm;
-	switch (rtlpci->const_pci_aspm) {
-	case 0:
-		/*No ASPM */
-		break;
-
-	case 1:
-		/*ASPM dynamically enabled/disable. */
-		ppsc->reg_rfps_level |= RT_RF_LPS_LEVEL_ASPM;
-		break;
-
-	case 2:
-		/*ASPM with Clock Req dynamically enabled/disable. */
-		ppsc->reg_rfps_level |= (RT_RF_LPS_LEVEL_ASPM |
-					 RT_RF_OFF_LEVL_CLK_REQ);
-		break;
-
-	case 3:
-		/* Always enable ASPM and Clock Req
-		 * from initialization to halt.
-		 */
-		ppsc->reg_rfps_level &= ~(RT_RF_LPS_LEVEL_ASPM);
-		ppsc->reg_rfps_level |= (RT_RF_PS_LEVEL_ALWAYS_ASPM |
-					 RT_RF_OFF_LEVL_CLK_REQ);
-		break;
-
-	case 4:
-		/* Always enable ASPM without Clock Req
-		 * from initialization to halt.
-		 */
-		ppsc->reg_rfps_level &= ~(RT_RF_LPS_LEVEL_ASPM |
-					  RT_RF_OFF_LEVL_CLK_REQ);
-		ppsc->reg_rfps_level |= RT_RF_PS_LEVEL_ALWAYS_ASPM;
-		break;
-	}
-
-	ppsc->reg_rfps_level |= RT_RF_OFF_LEVL_HALT_NIC;
-
-	/*Update Radio OFF setting */
-	switch (rtlpci->const_hwsw_rfoff_d3) {
-	case 1:
-		if (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM)
-			ppsc->reg_rfps_level |= RT_RF_OFF_LEVL_ASPM;
-		break;
-
-	case 2:
-		if (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM)
-			ppsc->reg_rfps_level |= RT_RF_OFF_LEVL_ASPM;
-		ppsc->reg_rfps_level |= RT_RF_OFF_LEVL_HALT_NIC;
-		break;
-
-	case 3:
-		ppsc->reg_rfps_level |= RT_RF_OFF_LEVL_PCI_D3;
-		break;
-	}
-
-	/*Set HW definition to determine if it supports ASPM. */
-	switch (rtlpci->const_support_pciaspm) {
-	case 0:
-		/*Not support ASPM. */
-		ppsc->support_aspm = false;
-		break;
-	case 1:
-		/*Support ASPM. */
-		ppsc->support_aspm = true;
-		ppsc->support_backdoor = true;
-		break;
-	case 2:
-		/*ASPM value set by chipset. */
-		if (pcibridge_vendor == PCI_BRIDGE_VENDOR_INTEL)
-			ppsc->support_aspm = true;
-		break;
+	switch (queue) {
+	case RTW_TX_QUEUE_BCN:
+		return TX_DESC_QSEL_BEACON;
+	case RTW_TX_QUEUE_H2C:
+		return TX_DESC_QSEL_H2C;
+	case RTW_TX_QUEUE_MGMT:
+		return TX_DESC_QSEL_MGMT;
+	case RTW_TX_QUEUE_HI0:
+		return TX_DESC_QSEL_HIGH;
 	default:
-		pr_err("switch case %#x not processed\n",
-		       rtlpci->const_support_pciaspm);
-		break;
+		return skb->priority;
 	}
+};
 
-	/* toshiba aspm issue, toshiba will set aspm selfly
-	 * so we should not set aspm in driver
-	 */
-	pci_read_config_byte(rtlpci->pdev, 0x80, &init_aspm);
-	if (rtlpriv->rtlhal.hw_type == HARDWARE_TYPE_RTL8192SE &&
-	    init_aspm == 0x43)
-		ppsc->support_aspm = false;
-}
-
-static bool _rtl_pci_platform_switch_device_pci_aspm(
-			struct ieee80211_hw *hw,
-			u8 value)
+static u8 rtw_pci_read8(struct rtw_dev *rtwdev, u32 addr)
 {
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-
-	if (rtlhal->hw_type != HARDWARE_TYPE_RTL8192SE)
-		value |= 0x40;
-
-	pci_write_config_byte(rtlpci->pdev, 0x80, value);
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
 
-	return false;
+	return readb(rtwpci->mmap + addr);
 }
 
-/*When we set 0x01 to enable clk request. Set 0x0 to disable clk req.*/
-static void _rtl_pci_switch_clk_req(struct ieee80211_hw *hw, u8 value)
+static u16 rtw_pci_read16(struct rtw_dev *rtwdev, u32 addr)
 {
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
 
-	pci_write_config_byte(rtlpci->pdev, 0x81, value);
-
-	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE)
-		udelay(100);
+	return readw(rtwpci->mmap + addr);
 }
 
-/*Disable RTL8192SE ASPM & Disable Pci Bridge ASPM*/
-static void rtl_pci_disable_aspm(struct ieee80211_hw *hw)
+static u32 rtw_pci_read32(struct rtw_dev *rtwdev, u32 addr)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	u8 pcibridge_vendor = pcipriv->ndis_adapter.pcibridge_vendor;
-	u8 num4bytes = pcipriv->ndis_adapter.num4bytes;
-	/*Retrieve original configuration settings. */
-	u8 linkctrl_reg = pcipriv->ndis_adapter.linkctrl_reg;
-	u16 pcibridge_linkctrlreg = pcipriv->ndis_adapter.
-				pcibridge_linkctrlreg;
-	u16 aspmlevel = 0;
-	u8 tmp_u1b = 0;
-
-	if (!ppsc->support_aspm)
-		return;
-
-	if (pcibridge_vendor == PCI_BRIDGE_VENDOR_UNKNOWN) {
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,
-			 "PCI(Bridge) UNKNOWN\n");
-
-		return;
-	}
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
 
-	if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_CLK_REQ) {
-		RT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_CLK_REQ);
-		_rtl_pci_switch_clk_req(hw, 0x0);
-	}
-
-	/*for promising device will in L0 state after an I/O. */
-	pci_read_config_byte(rtlpci->pdev, 0x80, &tmp_u1b);
-
-	/*Set corresponding value. */
-	aspmlevel |= BIT(0) | BIT(1);
-	linkctrl_reg &= ~aspmlevel;
-	pcibridge_linkctrlreg &= ~(BIT(0) | BIT(1));
-
-	_rtl_pci_platform_switch_device_pci_aspm(hw, linkctrl_reg);
-	udelay(50);
-
-	/*4 Disable Pci Bridge ASPM */
-	pci_write_config_byte(rtlpci->pdev, (num4bytes << 2),
-			      pcibridge_linkctrlreg);
-
-	udelay(50);
+	return readl(rtwpci->mmap + addr);
 }
 
-/*Enable RTL8192SE ASPM & Enable Pci Bridge ASPM for
- *power saving We should follow the sequence to enable
- *RTL8192SE first then enable Pci Bridge ASPM
- *or the system will show bluescreen.
- */
-static void rtl_pci_enable_aspm(struct ieee80211_hw *hw)
+static void rtw_pci_write8(struct rtw_dev *rtwdev, u32 addr, u8 val)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	u8 pcibridge_vendor = pcipriv->ndis_adapter.pcibridge_vendor;
-	u8 num4bytes = pcipriv->ndis_adapter.num4bytes;
-	u16 aspmlevel;
-	u8 u_pcibridge_aspmsetting;
-	u8 u_device_aspmsetting;
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
 
-	if (!ppsc->support_aspm)
-		return;
-
-	if (pcibridge_vendor == PCI_BRIDGE_VENDOR_UNKNOWN) {
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,
-			 "PCI(Bridge) UNKNOWN\n");
-		return;
-	}
-
-	/*4 Enable Pci Bridge ASPM */
-
-	u_pcibridge_aspmsetting =
-	    pcipriv->ndis_adapter.pcibridge_linkctrlreg |
-	    rtlpci->const_hostpci_aspm_setting;
-
-	if (pcibridge_vendor == PCI_BRIDGE_VENDOR_INTEL)
-		u_pcibridge_aspmsetting &= ~BIT(0);
-
-	pci_write_config_byte(rtlpci->pdev, (num4bytes << 2),
-			      u_pcibridge_aspmsetting);
-
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-		 "PlatformEnableASPM(): Write reg[%x] = %x\n",
-		 (pcipriv->ndis_adapter.pcibridge_pciehdr_offset + 0x10),
-		 u_pcibridge_aspmsetting);
-
-	udelay(50);
-
-	/*Get ASPM level (with/without Clock Req) */
-	aspmlevel = rtlpci->const_devicepci_aspm_setting;
-	u_device_aspmsetting = pcipriv->ndis_adapter.linkctrl_reg;
-
-	/*_rtl_pci_platform_switch_device_pci_aspm(dev,*/
-	/*(priv->ndis_adapter.linkctrl_reg | ASPMLevel)); */
-
-	u_device_aspmsetting |= aspmlevel;
-
-	_rtl_pci_platform_switch_device_pci_aspm(hw, u_device_aspmsetting);
-
-	if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_CLK_REQ) {
-		_rtl_pci_switch_clk_req(hw, (ppsc->reg_rfps_level &
-					     RT_RF_OFF_LEVL_CLK_REQ) ? 1 : 0);
-		RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_CLK_REQ);
-	}
-	udelay(100);
+	writeb(val, rtwpci->mmap + addr);
 }
 
-static bool rtl_pci_get_amd_l1_patch(struct ieee80211_hw *hw)
+static void rtw_pci_write16(struct rtw_dev *rtwdev, u32 addr, u16 val)
 {
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-
-	bool status = false;
-	u8 offset_e0;
-	unsigned int offset_e4;
-
-	pci_write_config_byte(rtlpci->pdev, 0xe0, 0xa0);
-
-	pci_read_config_byte(rtlpci->pdev, 0xe0, &offset_e0);
-
-	if (offset_e0 == 0xA0) {
-		pci_read_config_dword(rtlpci->pdev, 0xe4, &offset_e4);
-		if (offset_e4 & BIT(23))
-			status = true;
-	}
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
 
-	return status;
+	writew(val, rtwpci->mmap + addr);
 }
 
-static bool rtl_pci_check_buddy_priv(struct ieee80211_hw *hw,
-				     struct rtl_priv **buddy_priv)
+static void rtw_pci_write32(struct rtw_dev *rtwdev, u32 addr, u32 val)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	bool find_buddy_priv = false;
-	struct rtl_priv *tpriv;
-	struct rtl_pci_priv *tpcipriv = NULL;
-
-	if (!list_empty(&rtlpriv->glb_var->glb_priv_list)) {
-		list_for_each_entry(tpriv, &rtlpriv->glb_var->glb_priv_list,
-				    list) {
-			tpcipriv = (struct rtl_pci_priv *)tpriv->priv;
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-				 "pcipriv->ndis_adapter.funcnumber %x\n",
-				pcipriv->ndis_adapter.funcnumber);
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-				 "tpcipriv->ndis_adapter.funcnumber %x\n",
-				tpcipriv->ndis_adapter.funcnumber);
-
-			if (pcipriv->ndis_adapter.busnumber ==
-			    tpcipriv->ndis_adapter.busnumber &&
-			    pcipriv->ndis_adapter.devnumber ==
-			    tpcipriv->ndis_adapter.devnumber &&
-			    pcipriv->ndis_adapter.funcnumber !=
-			    tpcipriv->ndis_adapter.funcnumber) {
-				find_buddy_priv = true;
-				break;
-			}
-		}
-	}
-
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-		 "find_buddy_priv %d\n", find_buddy_priv);
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
 
-	if (find_buddy_priv)
-		*buddy_priv = tpriv;
-
-	return find_buddy_priv;
-}
-
-static void rtl_pci_get_linkcontrol_field(struct ieee80211_hw *hw)
-{
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(pcipriv);
-	u8 capabilityoffset = pcipriv->ndis_adapter.pcibridge_pciehdr_offset;
-	u8 linkctrl_reg;
-	u8 num4bbytes;
-
-	num4bbytes = (capabilityoffset + 0x10) / 4;
-
-	/*Read  Link Control Register */
-	pci_read_config_byte(rtlpci->pdev, (num4bbytes << 2), &linkctrl_reg);
-
-	pcipriv->ndis_adapter.pcibridge_linkctrlreg = linkctrl_reg;
+	writel(val, rtwpci->mmap + addr);
 }
 
-static void rtl_pci_parse_configuration(struct pci_dev *pdev,
-					struct ieee80211_hw *hw)
+static inline void *rtw_pci_get_tx_desc(struct rtw_pci_tx_ring *tx_ring, u8 idx)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
+	int offset = tx_ring->r.desc_size * idx;
 
-	u8 tmp;
-	u16 linkctrl_reg;
-
-	/*Link Control Register */
-	pcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &linkctrl_reg);
-	pcipriv->ndis_adapter.linkctrl_reg = (u8)linkctrl_reg;
-
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "Link Control Register =%x\n",
-		 pcipriv->ndis_adapter.linkctrl_reg);
-
-	pci_read_config_byte(pdev, 0x98, &tmp);
-	tmp |= BIT(4);
-	pci_write_config_byte(pdev, 0x98, tmp);
-
-	tmp = 0x17;
-	pci_write_config_byte(pdev, 0x70f, tmp);
+	return tx_ring->r.head + offset;
 }
 
-static void rtl_pci_init_aspm(struct ieee80211_hw *hw)
+static void rtw_pci_free_tx_ring(struct rtw_dev *rtwdev,
+				 struct rtw_pci_tx_ring *tx_ring)
 {
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct pci_dev *pdev = to_pci_dev(rtwdev->dev);
+	struct rtw_pci_tx_data *tx_data;
+	struct sk_buff *skb, *tmp;
+	dma_addr_t dma;
+	u8 *head = tx_ring->r.head;
+	u32 len = tx_ring->r.len;
+	int ring_sz = len * tx_ring->r.desc_size;
 
-	_rtl_pci_update_default_setting(hw);
+	/* free every skb remained in tx list */
+	skb_queue_walk_safe(&tx_ring->queue, skb, tmp) {
+		__skb_unlink(skb, &tx_ring->queue);
+		tx_data = rtw_pci_get_tx_data(skb);
+		dma = tx_data->dma;
 
-	if (ppsc->reg_rfps_level & RT_RF_PS_LEVEL_ALWAYS_ASPM) {
-		/*Always enable ASPM & Clock Req. */
-		rtl_pci_enable_aspm(hw);
-		RT_SET_PS_LEVEL(ppsc, RT_RF_PS_LEVEL_ALWAYS_ASPM);
+		pci_unmap_single(pdev, dma, skb->len, PCI_DMA_TODEVICE);
+		dev_kfree_skb_any(skb);
 	}
-}
 
-static void _rtl_pci_io_handler_init(struct device *dev,
-				     struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	rtlpriv->io.dev = dev;
-
-	rtlpriv->io.write8_async = pci_write8_async;
-	rtlpriv->io.write16_async = pci_write16_async;
-	rtlpriv->io.write32_async = pci_write32_async;
-
-	rtlpriv->io.read8_sync = pci_read8_sync;
-	rtlpriv->io.read16_sync = pci_read16_sync;
-	rtlpriv->io.read32_sync = pci_read32_sync;
+	/* free the ring itself */
+	pci_free_consistent(pdev, ring_sz, head, tx_ring->r.dma);
+	tx_ring->r.head = NULL;
 }
 
-static bool _rtl_update_earlymode_info(struct ieee80211_hw *hw,
-				       struct sk_buff *skb,
-				       struct rtl_tcb_desc *tcb_desc, u8 tid)
+static void rtw_pci_free_rx_ring(struct rtw_dev *rtwdev,
+				 struct rtw_pci_rx_ring *rx_ring)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct sk_buff *next_skb;
-	u8 additionlen = FCS_LEN;
-
-	/* here open is 4, wep/tkip is 8, aes is 12*/
-	if (info->control.hw_key)
-		additionlen += info->control.hw_key->icv_len;
-
-	/* The most skb num is 6 */
-	tcb_desc->empkt_num = 0;
-	spin_lock_bh(&rtlpriv->locks.waitq_lock);
-	skb_queue_walk(&rtlpriv->mac80211.skb_waitq[tid], next_skb) {
-		struct ieee80211_tx_info *next_info;
-
-		next_info = IEEE80211_SKB_CB(next_skb);
-		if (next_info->flags & IEEE80211_TX_CTL_AMPDU) {
-			tcb_desc->empkt_len[tcb_desc->empkt_num] =
-				next_skb->len + additionlen;
-			tcb_desc->empkt_num++;
-		} else {
-			break;
-		}
+	struct pci_dev *pdev = to_pci_dev(rtwdev->dev);
+	struct sk_buff *skb;
+	dma_addr_t dma;
+	u8 *head = rx_ring->r.head;
+	int buf_sz = RTK_PCI_RX_BUF_SIZE;
+	int ring_sz = rx_ring->r.desc_size * rx_ring->r.len;
+	int i;
 
-		if (skb_queue_is_last(&rtlpriv->mac80211.skb_waitq[tid],
-				      next_skb))
-			break;
+	for (i = 0; i < rx_ring->r.len; i++) {
+		skb = rx_ring->buf[i];
+		if (!skb)
+			continue;
 
-		if (tcb_desc->empkt_num >= rtlhal->max_earlymode_num)
-			break;
+		dma = *((dma_addr_t *)skb->cb);
+		pci_unmap_single(pdev, dma, buf_sz, PCI_DMA_FROMDEVICE);
+		dev_kfree_skb(skb);
+		rx_ring->buf[i] = NULL;
 	}
-	spin_unlock_bh(&rtlpriv->locks.waitq_lock);
 
-	return true;
+	pci_free_consistent(pdev, ring_sz, head, rx_ring->r.dma);
 }
 
-/* just for early mode now */
-static void _rtl_pci_tx_chk_waitq(struct ieee80211_hw *hw)
+static void rtw_pci_free_trx_ring(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct sk_buff *skb = NULL;
-	struct ieee80211_tx_info *info = NULL;
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	int tid;
-
-	if (!rtlpriv->rtlhal.earlymode_enable)
-		return;
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	struct rtw_pci_tx_ring *tx_ring;
+	struct rtw_pci_rx_ring *rx_ring;
+	int i;
 
-	if (rtlpriv->dm.supp_phymode_switch &&
-	    (rtlpriv->easy_concurrent_ctl.switch_in_process ||
-	    (rtlpriv->buddy_priv &&
-	    rtlpriv->buddy_priv->easy_concurrent_ctl.switch_in_process)))
-		return;
-	/* we just use em for BE/BK/VI/VO */
-	for (tid = 7; tid >= 0; tid--) {
-		u8 hw_queue = ac_to_hwq[rtl_tid_to_ac(tid)];
-		struct rtl8192_tx_ring *ring = &rtlpci->tx_ring[hw_queue];
-
-		while (!mac->act_scanning &&
-		       rtlpriv->psc.rfpwr_state == ERFON) {
-			struct rtl_tcb_desc tcb_desc;
-
-			memset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));
-
-			spin_lock_bh(&rtlpriv->locks.waitq_lock);
-			if (!skb_queue_empty(&mac->skb_waitq[tid]) &&
-			    (ring->entries - skb_queue_len(&ring->queue) >
-			     rtlhal->max_earlymode_num)) {
-				skb = skb_dequeue(&mac->skb_waitq[tid]);
-			} else {
-				spin_unlock_bh(&rtlpriv->locks.waitq_lock);
-				break;
-			}
-			spin_unlock_bh(&rtlpriv->locks.waitq_lock);
+	for (i = 0; i < RTK_MAX_TX_QUEUE_NUM; i++) {
+		tx_ring = &rtwpci->tx_rings[i];
+		rtw_pci_free_tx_ring(rtwdev, tx_ring);
+	}
 
-			/* Some macaddr can't do early mode. like
-			 * multicast/broadcast/no_qos data
-			 */
-			info = IEEE80211_SKB_CB(skb);
-			if (info->flags & IEEE80211_TX_CTL_AMPDU)
-				_rtl_update_earlymode_info(hw, skb,
-							   &tcb_desc, tid);
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-			rtlpriv->intf_ops->adapter_tx(hw, skb, &tcb_desc);
-#else
-			rtlpriv->intf_ops->adapter_tx(hw, NULL, skb, &tcb_desc);
-#endif
-		}
+	for (i = 0; i < RTK_MAX_RX_QUEUE_NUM; i++) {
+		rx_ring = &rtwpci->rx_rings[i];
+		rtw_pci_free_rx_ring(rtwdev, rx_ring);
 	}
 }
 
-static void _rtl_pci_tx_isr(struct ieee80211_hw *hw, int prio)
+static int rtw_pci_init_tx_ring(struct rtw_dev *rtwdev,
+				struct rtw_pci_tx_ring *tx_ring,
+				u8 desc_size, u32 len)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-
-	struct rtl8192_tx_ring *ring = &rtlpci->tx_ring[prio];
-
-	while (skb_queue_len(&ring->queue)) {
-		struct sk_buff *skb;
-		struct ieee80211_tx_info *info;
-		__le16 fc;
-		u8 tid;
-		u8 *entry;
-
-		if (rtlpriv->use_new_trx_flow)
-			entry = (u8 *)(&ring->buffer_desc[ring->idx]);
-		else
-			entry = (u8 *)(&ring->desc[ring->idx]);
-
-		if (!rtlpriv->cfg->ops->is_tx_desc_closed(hw, prio, ring->idx))
-			return;
-		ring->idx = (ring->idx + 1) % ring->entries;
-
-		skb = __skb_dequeue(&ring->queue);
-		pci_unmap_single(rtlpci->pdev,
-				 rtlpriv->cfg->ops->
-					     get_desc(hw, (u8 *)entry, true,
-						      HW_DESC_TXBUFF_ADDR),
-				 skb->len, PCI_DMA_TODEVICE);
-
-		/* remove early mode header */
-		if (rtlpriv->rtlhal.earlymode_enable)
-			skb_pull(skb, EM_HDR_LEN);
-
-		RT_TRACE(rtlpriv, (COMP_INTR | COMP_SEND), DBG_TRACE,
-			 "new ring->idx:%d, free: skb_queue_len:%d, free: seq:%x\n",
-			 ring->idx,
-			 skb_queue_len(&ring->queue),
-			 *(u16 *)(skb->data + 22));
-
-		if (prio == TXCMD_QUEUE) {
-			dev_kfree_skb(skb);
-			goto tx_status_ok;
-		}
-
-		/* for sw LPS, just after NULL skb send out, we can
-		 * sure AP knows we are sleeping, we should not let
-		 * rf sleep
-		 */
-		fc = rtl_get_fc(skb);
-		if (ieee80211_is_nullfunc(fc)) {
-			if (ieee80211_has_pm(fc)) {
-				rtlpriv->mac80211.offchan_delay = true;
-				rtlpriv->psc.state_inap = true;
-			} else {
-				rtlpriv->psc.state_inap = false;
-			}
-		}
-		if (ieee80211_is_action(fc)) {
-			struct ieee80211_mgmt *action_frame =
-				(struct ieee80211_mgmt *)skb->data;
-			if (action_frame->u.action.u.ht_smps.action ==
-			    WLAN_HT_ACTION_SMPS) {
-				dev_kfree_skb(skb);
-				goto tx_status_ok;
-			}
-		}
+	struct pci_dev *pdev = to_pci_dev(rtwdev->dev);
+	int ring_sz = desc_size * len;
+	dma_addr_t dma;
+	u8 *head;
 
-		/* update tid tx pkt num */
-		tid = rtl_get_tid(skb);
-		if (tid <= 7)
-			rtlpriv->link_info.tidtx_inperiod[tid]++;
-
-		info = IEEE80211_SKB_CB(skb);
-		ieee80211_tx_info_clear_status(info);
-
-		info->flags |= IEEE80211_TX_STAT_ACK;
-		/*info->status.rates[0].count = 1; */
-
-		ieee80211_tx_status_irqsafe(hw, skb);
-
-		if ((ring->entries - skb_queue_len(&ring->queue)) <= 4) {
-			RT_TRACE(rtlpriv, COMP_ERR, DBG_DMESG,
-				 "more desc left, wake skb_queue@%d, ring->idx = %d, skb_queue_len = 0x%x\n",
-				 prio, ring->idx,
-				 skb_queue_len(&ring->queue));
-
-			ieee80211_wake_queue(hw, skb_get_queue_mapping(skb));
-		}
-tx_status_ok:
-		skb = NULL;
+	head = pci_zalloc_consistent(pdev, ring_sz, &dma);
+	if (!head) {
+		rtw_err(rtwdev, "failed to allocate tx ring\n");
+		return -ENOMEM;
 	}
 
-	if (((rtlpriv->link_info.num_rx_inperiod +
-	      rtlpriv->link_info.num_tx_inperiod) > 8) ||
-	      rtlpriv->link_info.num_rx_inperiod > 2)
-		rtl_lps_leave(hw);
+	skb_queue_head_init(&tx_ring->queue);
+	tx_ring->r.head = head;
+	tx_ring->r.dma = dma;
+	tx_ring->r.len = len;
+	tx_ring->r.desc_size = desc_size;
+	tx_ring->r.wp = 0;
+	tx_ring->r.rp = 0;
+
+	return 0;
 }
 
-static int _rtl_pci_init_one_rxdesc(struct ieee80211_hw *hw,
-				    struct sk_buff *new_skb, u8 *entry,
-				    int rxring_idx, int desc_idx)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	u32 bufferaddress;
-	u8 tmp_one = 1;
-	struct sk_buff *skb;
+static int rtw_pci_reset_rx_desc(struct rtw_dev *rtwdev, struct sk_buff *skb,
+				 struct rtw_pci_rx_ring *rx_ring,
+				 u32 idx, u32 desc_sz)
+{
+	struct pci_dev *pdev = to_pci_dev(rtwdev->dev);
+	struct rtw_pci_rx_buffer_desc *buf_desc;
+	int buf_sz = RTK_PCI_RX_BUF_SIZE;
+	dma_addr_t dma;
 
-	if (likely(new_skb)) {
-		skb = new_skb;
-		goto remap;
-	}
-	skb = dev_alloc_skb(rtlpci->rxbuffersize);
 	if (!skb)
-		return 0;
+		return -EINVAL;
 
-remap:
-	/* just set skb->cb to mapping addr for pci_unmap_single use */
-	*((dma_addr_t *)skb->cb) =
-		pci_map_single(rtlpci->pdev, skb_tail_pointer(skb),
-			       rtlpci->rxbuffersize, PCI_DMA_FROMDEVICE);
-	bufferaddress = *((dma_addr_t *)skb->cb);
-	if (pci_dma_mapping_error(rtlpci->pdev, bufferaddress))
-		return 0;
-	rtlpci->rx_ring[rxring_idx].rx_buf[desc_idx] = skb;
-	if (rtlpriv->use_new_trx_flow) {
-		/* skb->cb may be 64 bit address */
-		rtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,
-					    HW_DESC_RX_PREPARE,
-					    (u8 *)(dma_addr_t *)skb->cb);
-	} else {
-		rtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,
-					    HW_DESC_RXBUFF_ADDR,
-					    (u8 *)&bufferaddress);
-		rtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,
-					    HW_DESC_RXPKT_LEN,
-					    (u8 *)&rtlpci->rxbuffersize);
-		rtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,
-					    HW_DESC_RXOWN,
-					    (u8 *)&tmp_one);
-	}
-	return 1;
-}
-
-/* inorder to receive 8K AMSDU we have set skb to
- * 9100bytes in init rx ring, but if this packet is
- * not a AMSDU, this large packet will be sent to
- * TCP/IP directly, this cause big packet ping fail
- * like: "ping -s 65507", so here we will realloc skb
- * based on the true size of packet, Mac80211
- * Probably will do it better, but does not yet.
- *
- * Some platform will fail when alloc skb sometimes.
- * in this condition, we will send the old skb to
- * mac80211 directly, this will not cause any other
- * issues, but only this packet will be lost by TCP/IP
- */
-static void _rtl_pci_rx_to_mac80211(struct ieee80211_hw *hw,
-				    struct sk_buff *skb,
-				    struct ieee80211_rx_status rx_status)
-{
-	if (unlikely(!rtl_action_proc(hw, skb, false))) {
-		dev_kfree_skb_any(skb);
-	} else {
-		struct sk_buff *uskb = NULL;
+	dma = pci_map_single(pdev, skb->data, buf_sz, PCI_DMA_FROMDEVICE);
+	if (pci_dma_mapping_error(pdev, dma))
+		return -EBUSY;
+
+	*((dma_addr_t *)skb->cb) = dma;
+	buf_desc = (struct rtw_pci_rx_buffer_desc *)(rx_ring->r.head +
+						     idx * desc_sz);
+	memset(buf_desc, 0, sizeof(*buf_desc));
+	buf_desc->buf_size = cpu_to_le16(RTK_PCI_RX_BUF_SIZE);
+	buf_desc->dma = cpu_to_le32(dma);
 
-		uskb = dev_alloc_skb(skb->len + 128);
-		if (likely(uskb)) {
-			memcpy(IEEE80211_SKB_RXCB(uskb), &rx_status,
-			       sizeof(rx_status));
-			skb_put_data(uskb, skb->data, skb->len);
-			dev_kfree_skb_any(skb);
-			ieee80211_rx_irqsafe(hw, uskb);
-		} else {
-			ieee80211_rx_irqsafe(hw, skb);
-		}
-	}
+	return 0;
 }
 
-/*hsisr interrupt handler*/
-static void _rtl_pci_hs_interrupt(struct ieee80211_hw *hw)
+static int rtw_pci_init_rx_ring(struct rtw_dev *rtwdev,
+				struct rtw_pci_rx_ring *rx_ring,
+				u8 desc_size, u32 len)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-
-	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[MAC_HSISR],
-		       rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[MAC_HSISR]) |
-		       rtlpci->sys_irq_mask);
-}
-
-static void _rtl_pci_rx_interrupt(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	int rxring_idx = RTL_PCI_RX_MPDU_QUEUE;
-	struct ieee80211_rx_status rx_status = { 0 };
-	unsigned int count = rtlpci->rxringcount;
-	u8 own;
-	u8 tmp_one;
-	bool unicast = false;
-	u8 hw_queue = 0;
-	unsigned int rx_remained_cnt = 0;
-	struct rtl_stats stats = {
-		.signal = 0,
-		.rate = 0,
-	};
-
-	/*RX NORMAL PKT */
-	while (count--) {
-		struct ieee80211_hdr *hdr;
-		__le16 fc;
-		u16 len;
-		/*rx buffer descriptor */
-		struct rtl_rx_buffer_desc *buffer_desc = NULL;
-		/*if use new trx flow, it means wifi info */
-		struct rtl_rx_desc *pdesc = NULL;
-		/*rx pkt */
-		struct sk_buff *skb = rtlpci->rx_ring[rxring_idx].rx_buf[
-				      rtlpci->rx_ring[rxring_idx].idx];
-		struct sk_buff *new_skb;
-
-		if (rtlpriv->use_new_trx_flow) {
-			if (rx_remained_cnt == 0)
-				rx_remained_cnt =
-				rtlpriv->cfg->ops->rx_desc_buff_remained_cnt(hw,
-								      hw_queue);
-			if (rx_remained_cnt == 0)
-				return;
-			buffer_desc = &rtlpci->rx_ring[rxring_idx].buffer_desc[
-				rtlpci->rx_ring[rxring_idx].idx];
-			pdesc = (struct rtl_rx_desc *)skb->data;
-		} else {	/* rx descriptor */
-			pdesc = &rtlpci->rx_ring[rxring_idx].desc[
-				rtlpci->rx_ring[rxring_idx].idx];
-
-			own = (u8)rtlpriv->cfg->ops->get_desc(hw, (u8 *)pdesc,
-							      false,
-							      HW_DESC_OWN);
-			if (own) /* wait data to be filled by hardware */
-				return;
-		}
+	struct pci_dev *pdev = to_pci_dev(rtwdev->dev);
+	struct sk_buff *skb = NULL;
+	dma_addr_t dma;
+	u8 *head;
+	int ring_sz = desc_size * len;
+	int buf_sz = RTK_PCI_RX_BUF_SIZE;
+	int i, allocated;
+	int ret = 0;
+
+	head = pci_zalloc_consistent(pdev, ring_sz, &dma);
+	if (!head) {
+		rtw_err(rtwdev, "failed to allocate rx ring\n");
+		return -ENOMEM;
+	}
+	rx_ring->r.head = head;
 
-		/* Reaching this point means: data is filled already
-		 * AAAAAAttention !!!
-		 * We can NOT access 'skb' before 'pci_unmap_single'
-		 */
-		pci_unmap_single(rtlpci->pdev, *((dma_addr_t *)skb->cb),
-				 rtlpci->rxbuffersize, PCI_DMA_FROMDEVICE);
-
-		/* get a new skb - if fail, old one will be reused */
-		new_skb = dev_alloc_skb(rtlpci->rxbuffersize);
-		if (unlikely(!new_skb))
-			goto no_new;
-		memset(&rx_status, 0, sizeof(rx_status));
-		rtlpriv->cfg->ops->query_rx_desc(hw, &stats,
-						 &rx_status, (u8 *)pdesc, skb);
-
-		if (rtlpriv->use_new_trx_flow)
-			rtlpriv->cfg->ops->rx_check_dma_ok(hw,
-							   (u8 *)buffer_desc,
-							   hw_queue);
-
-		len = rtlpriv->cfg->ops->get_desc(hw, (u8 *)pdesc, false,
-						  HW_DESC_RXPKT_LEN);
-
-		if (skb->end - skb->tail > len) {
-			skb_put(skb, len);
-			if (rtlpriv->use_new_trx_flow)
-				skb_reserve(skb, stats.rx_drvinfo_size +
-					    stats.rx_bufshift + 24);
-			else
-				skb_reserve(skb, stats.rx_drvinfo_size +
-					    stats.rx_bufshift);
-		} else {
-			RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-				 "skb->end - skb->tail = %d, len is %d\n",
-				 skb->end - skb->tail, len);
-			dev_kfree_skb_any(skb);
-			goto new_trx_end;
+	for (i = 0; i < len; i++) {
+		skb = dev_alloc_skb(buf_sz);
+		if (!skb) {
+			allocated = i;
+			ret = -ENOMEM;
+			goto err_out;
 		}
-		/* handle command packet here */
-		if (rtlpriv->cfg->ops->rx_command_packet &&
-		    rtlpriv->cfg->ops->rx_command_packet(hw, &stats, skb)) {
-			dev_kfree_skb_any(skb);
-			goto new_trx_end;
-		}
-
-		/* NOTICE This can not be use for mac80211,
-		 * this is done in mac80211 code,
-		 * if done here sec DHCP will fail
-		 * skb_trim(skb, skb->len - 4);
-		 */
-
-		hdr = rtl_get_hdr(skb);
-		fc = rtl_get_fc(skb);
-
-		if (!stats.crc && !stats.hwerror) {
-			memcpy(IEEE80211_SKB_RXCB(skb), &rx_status,
-			       sizeof(rx_status));
-
-			if (is_broadcast_ether_addr(hdr->addr1)) {
-				;/*TODO*/
-			} else if (is_multicast_ether_addr(hdr->addr1)) {
-				;/*TODO*/
-			} else {
-				unicast = true;
-				rtlpriv->stats.rxbytesunicast += skb->len;
-			}
-
-			if (rtlpriv->sta)
-				rtlpriv->sta->rxbytes += skb->len;
-
-			rtl_is_special_data(hw, skb, false, true);
 
-			if (ieee80211_is_data(fc)) {
-				rtlpriv->cfg->ops->led_control(hw, LED_CTL_RX);
-				if (unicast)
-					rtlpriv->link_info.num_rx_inperiod++;
-			}
-
-			rtl_collect_scan_list(hw, skb);
-
-			/* static bcn for roaming */
-			rtl_beacon_statistic(hw, skb);
-			rtl_p2p_info(hw, (void *)skb->data, skb->len);
-			/* for sw lps */
-			rtl_swlps_beacon(hw, (void *)skb->data, skb->len);
-			rtl_recognize_peer(hw, (void *)skb->data, skb->len);
-			if (rtlpriv->mac80211.opmode == NL80211_IFTYPE_AP &&
-			    rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G &&
-			    (ieee80211_is_beacon(fc) ||
-			     ieee80211_is_probe_resp(fc))) {
-				dev_kfree_skb_any(skb);
-			} else {
-				rtl_check_beacon_key(hw, (void *)skb->data,
-						     skb->len);
-				_rtl_pci_rx_to_mac80211(hw, skb, rx_status);
-			}
-		} else {
+		memset(skb->data, 0, buf_sz);
+		rx_ring->buf[i] = skb;
+		ret = rtw_pci_reset_rx_desc(rtwdev, skb, rx_ring, i, desc_size);
+		if (ret) {
+			allocated = i;
 			dev_kfree_skb_any(skb);
+			goto err_out;
 		}
-new_trx_end:
-		if (rtlpriv->use_new_trx_flow) {
-			rtlpci->rx_ring[hw_queue].next_rx_rp += 1;
-			rtlpci->rx_ring[hw_queue].next_rx_rp %=
-					RTL_PCI_MAX_RX_COUNT;
-
-			rx_remained_cnt--;
-			rtl_write_word(rtlpriv, 0x3B4,
-				       rtlpci->rx_ring[hw_queue].next_rx_rp);
-		}
-		if (((rtlpriv->link_info.num_rx_inperiod +
-		      rtlpriv->link_info.num_tx_inperiod) > 8) ||
-		      rtlpriv->link_info.num_rx_inperiod > 2)
-			rtl_lps_leave(hw);
-		skb = new_skb;
-no_new:
-		if (rtlpriv->use_new_trx_flow) {
-			_rtl_pci_init_one_rxdesc(hw, skb, (u8 *)buffer_desc,
-						 rxring_idx,
-						 rtlpci->rx_ring[rxring_idx].idx);
-		} else {
-			_rtl_pci_init_one_rxdesc(hw, skb, (u8 *)pdesc,
-						 rxring_idx,
-						 rtlpci->rx_ring[rxring_idx].idx);
-			if (rtlpci->rx_ring[rxring_idx].idx ==
-			    rtlpci->rxringcount - 1)
-				rtlpriv->cfg->ops->set_desc(hw, (u8 *)pdesc,
-							    false,
-							    HW_DESC_RXERO,
-							    (u8 *)&tmp_one);
-		}
-		rtlpci->rx_ring[rxring_idx].idx =
-				(rtlpci->rx_ring[rxring_idx].idx + 1) %
-				rtlpci->rxringcount;
-	}
-}
-
-static irqreturn_t _rtl_pci_interrupt(int irq, void *dev_id)
-{
-	struct ieee80211_hw *hw = dev_id;
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	unsigned long flags;
-	struct rtl_int intvec = {0};
-
-	irqreturn_t ret = IRQ_HANDLED;
-
-	if (rtlpci->irq_enabled == 0)
-		return ret;
-
-	spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
-	rtlpriv->cfg->ops->disable_interrupt(hw);
-
-	/*read ISR: 4/8bytes */
-	rtlpriv->cfg->ops->interrupt_recognized(hw, &intvec);
-
-	/*Shared IRQ or HW disappeared */
-	if (!intvec.inta || intvec.inta == 0xffff)
-		goto done;
-
-	/*<1> beacon related */
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_TBDOK])
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-			 "beacon ok interrupt!\n");
-
-	if (unlikely(intvec.inta & rtlpriv->cfg->maps[RTL_IMR_TBDER]))
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-			 "beacon err interrupt!\n");
-
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_BDOK])
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE, "beacon interrupt!\n");
-
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_BCNINT]) {
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-			 "prepare beacon for interrupt!\n");
-		tasklet_schedule(&rtlpriv->works.irq_prepare_bcn_tasklet);
 	}
 
-	/*<2> Tx related */
-	if (unlikely(intvec.intb & rtlpriv->cfg->maps[RTL_IMR_TXFOVW]) &&
-	    printk_ratelimit())
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING, "IMR_TXFOVW!\n");
-
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_MGNTDOK]) {
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-			 "Manage ok interrupt!\n");
-		_rtl_pci_tx_isr(hw, MGNT_QUEUE);
-	}
+	rx_ring->r.dma = dma;
+	rx_ring->r.len = len;
+	rx_ring->r.desc_size = desc_size;
+	rx_ring->r.wp = 0;
+	rx_ring->r.rp = 0;
 
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_HIGHDOK]) {
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-			 "HIGH_QUEUE ok interrupt!\n");
-		_rtl_pci_tx_isr(hw, HIGH_QUEUE);
-	}
-
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_BKDOK]) {
-		rtlpriv->link_info.num_tx_inperiod++;
+	return 0;
 
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-			 "BK Tx OK interrupt!\n");
-		_rtl_pci_tx_isr(hw, BK_QUEUE);
+err_out:
+	for (i = 0; i < allocated; i++) {
+		skb = rx_ring->buf[i];
+		if (!skb)
+			continue;
+		dma = *((dma_addr_t *)skb->cb);
+		pci_unmap_single(pdev, dma, buf_sz, PCI_DMA_FROMDEVICE);
+		dev_kfree_skb_any(skb);
+		rx_ring->buf[i] = NULL;
 	}
+	pci_free_consistent(pdev, ring_sz, head, dma);
 
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_BEDOK]) {
-		rtlpriv->link_info.num_tx_inperiod++;
+	rtw_err(rtwdev, "failed to init rx buffer\n");
 
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-			 "BE TX OK interrupt!\n");
-		_rtl_pci_tx_isr(hw, BE_QUEUE);
-	}
-
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_VIDOK]) {
-		rtlpriv->link_info.num_tx_inperiod++;
+	return ret;
+}
 
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-			 "VI TX OK interrupt!\n");
-		_rtl_pci_tx_isr(hw, VI_QUEUE);
-	}
+static int rtw_pci_init_trx_ring(struct rtw_dev *rtwdev)
+{
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	struct rtw_pci_tx_ring *tx_ring;
+	struct rtw_pci_rx_ring *rx_ring;
+	struct rtw_chip_info *chip = rtwdev->chip;
+	int i = 0, j = 0, tx_alloced = 0, rx_alloced = 0;
+	int tx_desc_size, rx_desc_size;
+	u32 len;
+	int ret;
 
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_VODOK]) {
-		rtlpriv->link_info.num_tx_inperiod++;
+	tx_desc_size = chip->tx_buf_desc_sz;
 
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-			 "Vo TX OK interrupt!\n");
-		_rtl_pci_tx_isr(hw, VO_QUEUE);
+	for (i = 0; i < RTK_MAX_TX_QUEUE_NUM; i++) {
+		tx_ring = &rtwpci->tx_rings[i];
+		len = max_num_of_tx_queue(i);
+		ret = rtw_pci_init_tx_ring(rtwdev, tx_ring, tx_desc_size, len);
+		if (ret)
+			goto out;
 	}
 
-	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8822BE) {
-		if (intvec.intd & rtlpriv->cfg->maps[RTL_IMR_H2CDOK]) {
-			rtlpriv->link_info.num_tx_inperiod++;
+	rx_desc_size = chip->rx_buf_desc_sz;
 
-			RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-				 "H2C TX OK interrupt!\n");
-			_rtl_pci_tx_isr(hw, H2C_QUEUE);
-		}
+	for (j = 0; j < RTK_MAX_RX_QUEUE_NUM; j++) {
+		rx_ring = &rtwpci->rx_rings[j];
+		ret = rtw_pci_init_rx_ring(rtwdev, rx_ring, rx_desc_size,
+					   RTK_MAX_RX_DESC_NUM);
+		if (ret)
+			goto out;
 	}
 
-	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE) {
-		if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_COMDOK]) {
-			rtlpriv->link_info.num_tx_inperiod++;
-
-			RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-				 "CMD TX OK interrupt!\n");
-			_rtl_pci_tx_isr(hw, TXCMD_QUEUE);
-		}
-	}
+	return 0;
 
-	/*<3> Rx related */
-	if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_ROK]) {
-		RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE, "Rx ok interrupt!\n");
-		_rtl_pci_rx_interrupt(hw);
-	}
-
-	if (unlikely(intvec.inta & rtlpriv->cfg->maps[RTL_IMR_RDU])) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-			 "rx descriptor unavailable!\n");
-		_rtl_pci_rx_interrupt(hw);
-	}
-
-	if (unlikely(intvec.intb & rtlpriv->cfg->maps[RTL_IMR_RXFOVW])) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING, "rx overflow !\n");
-		_rtl_pci_rx_interrupt(hw);
-	}
-
-	/*<4> fw related*/
-	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8723AE) {
-		if (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_C2HCMD]) {
-			RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-				 "firmware interrupt!\n");
-			queue_delayed_work(rtlpriv->works.rtl_wq,
-					   &rtlpriv->works.fwevt_wq, 0);
-		}
+out:
+	tx_alloced = i;
+	for (i = 0; i < tx_alloced; i++) {
+		tx_ring = &rtwpci->tx_rings[i];
+		rtw_pci_free_tx_ring(rtwdev, tx_ring);
 	}
 
-	/*<5> hsisr related*/
-	/* Only 8188EE & 8723BE Supported.
-	 * If Other ICs Come in, System will corrupt,
-	 * because maps[RTL_IMR_HSISR_IND] & maps[MAC_HSISR]
-	 * are not initialized
-	 */
-	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8188EE ||
-	    rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE ||
-	    rtlhal->hw_type == HARDWARE_TYPE_RTL8723DE) {
-		if (unlikely(intvec.inta &
-		    rtlpriv->cfg->maps[RTL_IMR_HSISR_IND])) {
-			RT_TRACE(rtlpriv, COMP_INTR, DBG_TRACE,
-				 "hsisr interrupt!\n");
-			_rtl_pci_hs_interrupt(hw);
-		}
+	rx_alloced = j;
+	for (j = 0; j < rx_alloced; j++) {
+		rx_ring = &rtwpci->rx_rings[j];
+		rtw_pci_free_rx_ring(rtwdev, rx_ring);
 	}
 
-	if (rtlpriv->rtlhal.earlymode_enable)
-		tasklet_schedule(&rtlpriv->works.irq_tasklet);
-
-done:
-	rtlpriv->cfg->ops->enable_interrupt(hw);
-	spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 	return ret;
 }
 
-static void _rtl_pci_irq_tasklet(struct ieee80211_hw *hw)
+static void rtw_pci_deinit(struct rtw_dev *rtwdev)
 {
-	_rtl_pci_tx_chk_waitq(hw);
+	rtw_pci_free_trx_ring(rtwdev);
 }
 
-static void _rtl_pci_prepare_bcn_tasklet(struct ieee80211_hw *hw)
+static int rtw_pci_init(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl8192_tx_ring *ring = NULL;
-	struct ieee80211_hdr *hdr = NULL;
-	struct ieee80211_tx_info *info = NULL;
-	struct sk_buff *pskb = NULL;
-	struct rtl_tx_desc *pdesc = NULL;
-	struct rtl_tcb_desc tcb_desc;
-	/*This is for new trx flow*/
-	struct rtl_tx_buffer_desc *pbuffer_desc = NULL;
-	u8 temp_one = 1;
-	u8 *entry;
-
-	memset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));
-	ring = &rtlpci->tx_ring[BEACON_QUEUE];
-	pskb = __skb_dequeue(&ring->queue);
-	if (rtlpriv->use_new_trx_flow)
-		entry = (u8 *)(&ring->buffer_desc[ring->idx]);
-	else
-		entry = (u8 *)(&ring->desc[ring->idx]);
-	if (pskb) {
-		pci_unmap_single(rtlpci->pdev,
-				 rtlpriv->cfg->ops->get_desc(
-				 hw, (u8 *)entry, true, HW_DESC_TXBUFF_ADDR),
-				 pskb->len, PCI_DMA_TODEVICE);
-		kfree_skb(pskb);
-	}
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	int ret = 0;
+
+	rtwpci->irq_mask[0] = IMR_HIGHDOK |
+			      IMR_MGNTDOK |
+			      IMR_BKDOK |
+			      IMR_BEDOK |
+			      IMR_VIDOK |
+			      IMR_VODOK |
+			      IMR_ROK |
+			      IMR_BCNDMAINT_E |
+			      0;
+	rtwpci->irq_mask[1] = IMR_TXFOVW |
+			      0;
+	rtwpci->irq_mask[3] = IMR_H2CDOK |
+			      0;
+	spin_lock_init(&rtwpci->irq_lock);
+	ret = rtw_pci_init_trx_ring(rtwdev);
 
-	/*NB: the beacon data buffer must be 32-bit aligned. */
-	pskb = ieee80211_beacon_get(hw, mac->vif);
-	if (!pskb)
-		return;
-	hdr = rtl_get_hdr(pskb);
-	info = IEEE80211_SKB_CB(pskb);
-	pdesc = &ring->desc[0];
-	if (rtlpriv->use_new_trx_flow)
-		pbuffer_desc = &ring->buffer_desc[0];
-
-	rtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *)pdesc,
-					(u8 *)pbuffer_desc, info, NULL, pskb,
-					BEACON_QUEUE, &tcb_desc);
-
-	__skb_queue_tail(&ring->queue, pskb);
-
-	if (rtlpriv->use_new_trx_flow) {
-		temp_one = 4;
-		rtlpriv->cfg->ops->set_desc(hw, (u8 *)pbuffer_desc, true,
-					    HW_DESC_OWN, (u8 *)&temp_one);
-	} else {
-		rtlpriv->cfg->ops->set_desc(hw, (u8 *)pdesc, true, HW_DESC_OWN,
-					    &temp_one);
-	}
+	return ret;
 }
 
-static void _rtl_pci_init_trx_var(struct ieee80211_hw *hw)
+static void rtw_pci_reset_buf_desc(struct rtw_dev *rtwdev)
 {
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
-	u8 i;
-	u16 desc_num;
-
-	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8192EE)
-		desc_num = TX_DESC_NUM_92E;
-	else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8822BE)
-		desc_num = TX_DESC_NUM_8822B;
-	else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8723DE)
-		desc_num = TX_DESC_NUM_8723D;
-	else
-		desc_num = RT_TXDESC_NUM;
-
-	for (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++)
-		rtlpci->txringcount[i] = desc_num;
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	u32 len;
+	u8 tmp;
+	dma_addr_t dma;
 
-	/*we just alloc 2 desc for beacon queue,
-	 *because we just need first desc in hw beacon.
-	 */
-	rtlpci->txringcount[BEACON_QUEUE] = 2;
+	tmp = rtw_read8(rtwdev, RTK_PCI_CTRL + 3);
+	rtw_write8(rtwdev, RTK_PCI_CTRL + 3, tmp | 0xf7);
 
-	/*BE queue need more descriptor for performance
-	 *consideration or, No more tx desc will happen,
-	 *and may cause mac80211 mem leakage.
-	 */
-	if (!rtl_priv(hw)->use_new_trx_flow)
-		rtlpci->txringcount[BE_QUEUE] = RT_TXDESC_NUM_BE_QUEUE;
+	dma = rtwpci->tx_rings[RTW_TX_QUEUE_BCN].r.dma;
+	rtw_write32(rtwdev, RTK_PCI_TXBD_DESA_BCNQ, dma);
 
-	rtlpci->rxbuffersize = 9100;	/*2048/1024; */
-	rtlpci->rxringcount = RTL_PCI_MAX_RX_COUNT;	/*64; */
+	len = rtwpci->tx_rings[RTW_TX_QUEUE_H2C].r.len;
+	dma = rtwpci->tx_rings[RTW_TX_QUEUE_H2C].r.dma;
+	rtwpci->tx_rings[RTW_TX_QUEUE_H2C].r.rp = 0;
+	rtwpci->tx_rings[RTW_TX_QUEUE_H2C].r.wp = 0;
+	rtw_write16(rtwdev, RTK_PCI_TXBD_NUM_H2CQ, len);
+	rtw_write32(rtwdev, RTK_PCI_TXBD_DESA_H2CQ, dma);
+
+	len = rtwpci->tx_rings[RTW_TX_QUEUE_BK].r.len;
+	dma = rtwpci->tx_rings[RTW_TX_QUEUE_BK].r.dma;
+	rtwpci->tx_rings[RTW_TX_QUEUE_BK].r.rp = 0;
+	rtwpci->tx_rings[RTW_TX_QUEUE_BK].r.wp = 0;
+	rtw_write16(rtwdev, RTK_PCI_TXBD_NUM_BKQ, len);
+	rtw_write32(rtwdev, RTK_PCI_TXBD_DESA_BKQ, dma);
+
+	len = rtwpci->tx_rings[RTW_TX_QUEUE_BE].r.len;
+	dma = rtwpci->tx_rings[RTW_TX_QUEUE_BE].r.dma;
+	rtwpci->tx_rings[RTW_TX_QUEUE_BE].r.rp = 0;
+	rtwpci->tx_rings[RTW_TX_QUEUE_BE].r.wp = 0;
+	rtw_write16(rtwdev, RTK_PCI_TXBD_NUM_BEQ, len);
+	rtw_write32(rtwdev, RTK_PCI_TXBD_DESA_BEQ, dma);
+
+	len = rtwpci->tx_rings[RTW_TX_QUEUE_VO].r.len;
+	dma = rtwpci->tx_rings[RTW_TX_QUEUE_VO].r.dma;
+	rtwpci->tx_rings[RTW_TX_QUEUE_VO].r.rp = 0;
+	rtwpci->tx_rings[RTW_TX_QUEUE_VO].r.wp = 0;
+	rtw_write16(rtwdev, RTK_PCI_TXBD_NUM_VOQ, len);
+	rtw_write32(rtwdev, RTK_PCI_TXBD_DESA_VOQ, dma);
+
+	len = rtwpci->tx_rings[RTW_TX_QUEUE_VI].r.len;
+	dma = rtwpci->tx_rings[RTW_TX_QUEUE_VI].r.dma;
+	rtwpci->tx_rings[RTW_TX_QUEUE_VI].r.rp = 0;
+	rtwpci->tx_rings[RTW_TX_QUEUE_VI].r.wp = 0;
+	rtw_write16(rtwdev, RTK_PCI_TXBD_NUM_VIQ, len);
+	rtw_write32(rtwdev, RTK_PCI_TXBD_DESA_VIQ, dma);
+
+	len = rtwpci->tx_rings[RTW_TX_QUEUE_MGMT].r.len;
+	dma = rtwpci->tx_rings[RTW_TX_QUEUE_MGMT].r.dma;
+	rtwpci->tx_rings[RTW_TX_QUEUE_MGMT].r.rp = 0;
+	rtwpci->tx_rings[RTW_TX_QUEUE_MGMT].r.wp = 0;
+	rtw_write16(rtwdev, RTK_PCI_TXBD_NUM_MGMTQ, len);
+	rtw_write32(rtwdev, RTK_PCI_TXBD_DESA_MGMTQ, dma);
+
+	len = rtwpci->tx_rings[RTW_TX_QUEUE_HI0].r.len;
+	dma = rtwpci->tx_rings[RTW_TX_QUEUE_HI0].r.dma;
+	rtwpci->tx_rings[RTW_TX_QUEUE_HI0].r.rp = 0;
+	rtwpci->tx_rings[RTW_TX_QUEUE_HI0].r.wp = 0;
+	rtw_write16(rtwdev, RTK_PCI_TXBD_NUM_HI0Q, len);
+	rtw_write32(rtwdev, RTK_PCI_TXBD_DESA_HI0Q, dma);
+
+	len = rtwpci->rx_rings[RTW_RX_QUEUE_MPDU].r.len;
+	dma = rtwpci->rx_rings[RTW_RX_QUEUE_MPDU].r.dma;
+	rtwpci->rx_rings[RTW_RX_QUEUE_MPDU].r.rp = 0;
+	rtwpci->rx_rings[RTW_RX_QUEUE_MPDU].r.wp = 0;
+	rtw_write16(rtwdev, RTK_PCI_RXBD_NUM_MPDUQ, len & 0xfff);
+	rtw_write32(rtwdev, RTK_PCI_RXBD_DESA_MPDUQ, dma);
+
+	/* reset read/write point */
+	rtw_write32(rtwdev, RTK_PCI_TXBD_RWPTR_CLR, 0xffffffff);
+
+	/* rest H2C Queue index */
+	rtw_write32_set(rtwdev, RTK_PCI_TXBD_H2CQ_CSR, BIT_CLR_H2CQ_HOST_IDX);
+	rtw_write32_set(rtwdev, RTK_PCI_TXBD_H2CQ_CSR, BIT_CLR_H2CQ_HW_IDX);
+}
+
+static void rtw_pci_reset_trx_ring(struct rtw_dev *rtwdev)
+{
+	rtw_pci_reset_buf_desc(rtwdev);
+}
+
+static void rtw_pci_enable_interrupt(struct rtw_dev *rtwdev,
+				     struct rtw_pci *rtwpci)
+{
+	rtw_write32(rtwdev, RTK_PCI_HIMR0, rtwpci->irq_mask[0]);
+	rtw_write32(rtwdev, RTK_PCI_HIMR1, rtwpci->irq_mask[1]);
+	rtw_write32(rtwdev, RTK_PCI_HIMR3, rtwpci->irq_mask[3]);
+	rtwpci->irq_enabled = true;
+}
+
+static void rtw_pci_disable_interrupt(struct rtw_dev *rtwdev,
+				      struct rtw_pci *rtwpci)
+{
+	rtw_write32(rtwdev, RTK_PCI_HIMR0, 0);
+	rtw_write32(rtwdev, RTK_PCI_HIMR1, 0);
+	rtw_write32(rtwdev, RTK_PCI_HIMR3, 0);
+	rtwpci->irq_enabled = false;
 }
 
-static void _rtl_pci_init_struct(struct ieee80211_hw *hw,
-				 struct pci_dev *pdev)
+static int rtw_pci_setup(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-
-	rtlpci->up_first_time = true;
-	rtlpci->being_init_adapter = false;
-
-	rtlhal->hw = hw;
-	rtlpci->pdev = pdev;
-
-	/*Tx/Rx related var */
-	_rtl_pci_init_trx_var(hw);
-
-	/*IBSS*/
-	mac->beacon_interval = 100;
-
-	/*AMPDU*/
-	mac->min_space_cfg = 0;
-	mac->max_mss_density = 0;
-	/*set sane AMPDU defaults */
-	mac->current_ampdu_density = 7;
-	mac->current_ampdu_factor = 3;
-
-	/*Retry Limit*/
-	mac->retry_short = 7;
-	mac->retry_long = 7;
-
-	/*QOS*/
-	rtlpci->acm_method = EACMWAY2_SW;
-
-	/*task */
-	tasklet_init(&rtlpriv->works.irq_tasklet,
-		     (void (*)(unsigned long))_rtl_pci_irq_tasklet,
-		     (unsigned long)hw);
-	tasklet_init(&rtlpriv->works.irq_prepare_bcn_tasklet,
-		     (void (*)(unsigned long))_rtl_pci_prepare_bcn_tasklet,
-		     (unsigned long)hw);
-	INIT_WORK(&rtlpriv->works.lps_change_work,
-		  rtl_lps_change_work_callback);
-}
-
-static int _rtl_pci_init_tx_ring(struct ieee80211_hw *hw,
-				 unsigned int prio, unsigned int entries)
-{
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_tx_buffer_desc *buffer_desc;
-	struct rtl_tx_desc *desc;
-	dma_addr_t buffer_desc_dma, desc_dma;
-	u32 nextdescaddress;
-	int i;
-
-	/* alloc tx buffer desc for new trx flow*/
-	if (rtlpriv->use_new_trx_flow) {
-		buffer_desc =
-		   pci_zalloc_consistent(rtlpci->pdev,
-					 sizeof(*buffer_desc) * entries,
-					 &buffer_desc_dma);
-
-		if (!buffer_desc || (unsigned long)buffer_desc & 0xFF) {
-			pr_err("Cannot allocate TX ring (prio = %d)\n",
-			       prio);
-			return -ENOMEM;
-		}
-
-		rtlpci->tx_ring[prio].buffer_desc = buffer_desc;
-		rtlpci->tx_ring[prio].buffer_desc_dma = buffer_desc_dma;
-
-		rtlpci->tx_ring[prio].cur_tx_rp = 0;
-		rtlpci->tx_ring[prio].cur_tx_wp = 0;
-	}
-
-	/* alloc dma for this ring */
-	desc = pci_zalloc_consistent(rtlpci->pdev,
-				     sizeof(*desc) * entries, &desc_dma);
+	rtw_pci_reset_trx_ring(rtwdev);
 
-	if (!desc || (unsigned long)desc & 0xFF) {
-		pr_err("Cannot allocate TX ring (prio = %d)\n", prio);
-		return -ENOMEM;
-	}
-
-	rtlpci->tx_ring[prio].desc = desc;
-	rtlpci->tx_ring[prio].dma = desc_dma;
-
-	rtlpci->tx_ring[prio].idx = 0;
-	rtlpci->tx_ring[prio].entries = entries;
-	skb_queue_head_init(&rtlpci->tx_ring[prio].queue);
-
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "queue:%d, ring_addr:%p\n",
-		 prio, desc);
-
-	/* init every desc in this ring */
-	if (!rtlpriv->use_new_trx_flow) {
-		for (i = 0; i < entries; i++) {
-			nextdescaddress = (u32)desc_dma +
-					  ((i +	1) % entries) *
-					  sizeof(*desc);
-
-			rtlpriv->cfg->ops->set_desc(hw, (u8 *)&desc[i],
-						    true,
-						    HW_DESC_TX_NEXTDESC_ADDR,
-						    (u8 *)&nextdescaddress);
-		}
-	}
 	return 0;
 }
 
-static int _rtl_pci_init_rx_ring(struct ieee80211_hw *hw, int rxring_idx)
+static void rtw_pci_dma_reset(struct rtw_dev *rtwdev, struct rtw_pci *rtwpci)
 {
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	int i;
-
-	if (rtlpriv->use_new_trx_flow) {
-		struct rtl_rx_buffer_desc *entry = NULL;
-		/* alloc dma for this ring */
-		rtlpci->rx_ring[rxring_idx].buffer_desc =
-		    pci_zalloc_consistent(rtlpci->pdev,
-					  sizeof(*rtlpci->rx_ring[rxring_idx].
-						 buffer_desc) *
-						 rtlpci->rxringcount,
-					  &rtlpci->rx_ring[rxring_idx].dma);
-		if (!rtlpci->rx_ring[rxring_idx].buffer_desc ||
-		    (ulong)rtlpci->rx_ring[rxring_idx].buffer_desc & 0xFF) {
-			pr_err("Cannot allocate RX ring\n");
-			return -ENOMEM;
-		}
+	/* reset dma and rx tag */
+	rtw_write32_set(rtwdev, RTK_PCI_CTRL,
+			BIT_RST_TRXDMA_INTF | BIT_RX_TAG_EN);
+	rtwpci->rx_tag = 0;
+}
 
-		/* init every desc in this ring */
-		rtlpci->rx_ring[rxring_idx].idx = 0;
-		for (i = 0; i < rtlpci->rxringcount; i++) {
-			entry = &rtlpci->rx_ring[rxring_idx].buffer_desc[i];
-			if (!_rtl_pci_init_one_rxdesc(hw, NULL, (u8 *)entry,
-						      rxring_idx, i))
-				return -ENOMEM;
-		}
-	} else {
-		struct rtl_rx_desc *entry = NULL;
-		u8 tmp_one = 1;
-		/* alloc dma for this ring */
-		rtlpci->rx_ring[rxring_idx].desc =
-		    pci_zalloc_consistent(rtlpci->pdev,
-					  sizeof(*rtlpci->rx_ring[rxring_idx].
-					  desc) * rtlpci->rxringcount,
-					  &rtlpci->rx_ring[rxring_idx].dma);
-		if (!rtlpci->rx_ring[rxring_idx].desc ||
-		    (unsigned long)rtlpci->rx_ring[rxring_idx].desc & 0xFF) {
-			pr_err("Cannot allocate RX ring\n");
-			return -ENOMEM;
-		}
+static int rtw_pci_start(struct rtw_dev *rtwdev)
+{
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	unsigned long flags;
 
-		/* init every desc in this ring */
-		rtlpci->rx_ring[rxring_idx].idx = 0;
+	rtw_pci_dma_reset(rtwdev, rtwpci);
 
-		for (i = 0; i < rtlpci->rxringcount; i++) {
-			entry = &rtlpci->rx_ring[rxring_idx].desc[i];
-			if (!_rtl_pci_init_one_rxdesc(hw, NULL, (u8 *)entry,
-						      rxring_idx, i))
-				return -ENOMEM;
-		}
+	spin_lock_irqsave(&rtwpci->irq_lock, flags);
+	rtw_pci_enable_interrupt(rtwdev, rtwpci);
+	spin_unlock_irqrestore(&rtwpci->irq_lock, flags);
 
-		rtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,
-					    HW_DESC_RXERO, &tmp_one);
-	}
 	return 0;
 }
 
-static void _rtl_pci_free_tx_ring(struct ieee80211_hw *hw,
-				  unsigned int prio)
+static void rtw_pci_stop(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl8192_tx_ring *ring = &rtlpci->tx_ring[prio];
-
-	/* free every desc in this ring */
-	while (skb_queue_len(&ring->queue)) {
-		u8 *entry;
-		struct sk_buff *skb = __skb_dequeue(&ring->queue);
-
-		if (rtlpriv->use_new_trx_flow)
-			entry = (u8 *)(&ring->buffer_desc[ring->idx]);
-		else
-			entry = (u8 *)(&ring->desc[ring->idx]);
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	unsigned long flags;
 
-		pci_unmap_single(rtlpci->pdev,
-				 rtlpriv->cfg->ops->get_desc(hw, (u8 *)entry,
-						   true,
-						   HW_DESC_TXBUFF_ADDR),
-				 skb->len, PCI_DMA_TODEVICE);
-		kfree_skb(skb);
-		ring->idx = (ring->idx + 1) % ring->entries;
-	}
-
-	/* free dma of this ring */
-	pci_free_consistent(rtlpci->pdev,
-			    sizeof(*ring->desc) * ring->entries,
-			    ring->desc, ring->dma);
-	ring->desc = NULL;
-	if (rtlpriv->use_new_trx_flow) {
-		pci_free_consistent(rtlpci->pdev,
-				    sizeof(*ring->buffer_desc) * ring->entries,
-				    ring->buffer_desc, ring->buffer_desc_dma);
-		ring->buffer_desc = NULL;
-	}
+	spin_lock_irqsave(&rtwpci->irq_lock, flags);
+	rtw_pci_disable_interrupt(rtwdev, rtwpci);
+	spin_unlock_irqrestore(&rtwpci->irq_lock, flags);
 }
 
-static void _rtl_pci_free_rx_ring(struct ieee80211_hw *hw, int rxring_idx)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	int i;
+static u8 ac_to_hwq[] = {
+	[IEEE80211_AC_VO] = RTW_TX_QUEUE_VO,
+	[IEEE80211_AC_VI] = RTW_TX_QUEUE_VI,
+	[IEEE80211_AC_BE] = RTW_TX_QUEUE_BE,
+	[IEEE80211_AC_BK] = RTW_TX_QUEUE_BK,
+};
 
-	/* free every desc in this ring */
-	for (i = 0; i < rtlpci->rxringcount; i++) {
-		struct sk_buff *skb = rtlpci->rx_ring[rxring_idx].rx_buf[i];
+static u8 rtw_hw_queue_mapping(struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	__le16 fc = hdr->frame_control;
+	u8 q_mapping = skb_get_queue_mapping(skb);
+	u8 queue;
 
-		if (!skb)
-			continue;
-		pci_unmap_single(rtlpci->pdev, *((dma_addr_t *)skb->cb),
-				 rtlpci->rxbuffersize, PCI_DMA_FROMDEVICE);
-		kfree_skb(skb);
-	}
+	if (unlikely(ieee80211_is_beacon(fc)))
+		queue = RTW_TX_QUEUE_BCN;
+	else if (unlikely(ieee80211_is_mgmt(fc) || ieee80211_is_ctl(fc)))
+		queue = RTW_TX_QUEUE_MGMT;
+	else if (WARN_ON_ONCE(q_mapping >= ARRAY_SIZE(ac_to_hwq)))
+		queue = ac_to_hwq[IEEE80211_AC_BE];
+	else
+		queue = ac_to_hwq[q_mapping];
 
-	/* free dma of this ring */
-	if (rtlpriv->use_new_trx_flow) {
-		pci_free_consistent(rtlpci->pdev,
-				    sizeof(*rtlpci->rx_ring[rxring_idx].
-				    buffer_desc) * rtlpci->rxringcount,
-				    rtlpci->rx_ring[rxring_idx].buffer_desc,
-				    rtlpci->rx_ring[rxring_idx].dma);
-		rtlpci->rx_ring[rxring_idx].buffer_desc = NULL;
-	} else {
-		pci_free_consistent(rtlpci->pdev,
-				    sizeof(*rtlpci->rx_ring[rxring_idx].desc) *
-				    rtlpci->rxringcount,
-				    rtlpci->rx_ring[rxring_idx].desc,
-				    rtlpci->rx_ring[rxring_idx].dma);
-		rtlpci->rx_ring[rxring_idx].desc = NULL;
-	}
+	return queue;
 }
 
-static int _rtl_pci_init_trx_ring(struct ieee80211_hw *hw)
+static void rtw_pci_release_rsvd_page(struct rtw_pci *rtwpci,
+				      struct rtw_pci_tx_ring *ring)
 {
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	int ret;
-	int i, rxring_idx;
+	struct sk_buff *prev = skb_dequeue(&ring->queue);
+	struct rtw_pci_tx_data *tx_data;
+	dma_addr_t dma;
 
-	/* rxring_idx 0:RX_MPDU_QUEUE
-	 * rxring_idx 1:RX_CMD_QUEUE
-	 */
-	for (rxring_idx = 0; rxring_idx < RTL_PCI_MAX_RX_QUEUE; rxring_idx++) {
-		ret = _rtl_pci_init_rx_ring(hw, rxring_idx);
-		if (ret)
-			return ret;
-	}
+	if (!prev)
+		return;
 
-	for (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++) {
-		ret = _rtl_pci_init_tx_ring(hw, i, rtlpci->txringcount[i]);
-		if (ret)
-			goto err_free_rings;
+	tx_data = rtw_pci_get_tx_data(prev);
+	dma = tx_data->dma;
+	pci_unmap_single(rtwpci->pdev, dma, prev->len,
+			 PCI_DMA_TODEVICE);
+	dev_kfree_skb_any(prev);
+}
+
+static void rtw_pci_dma_check(struct rtw_dev *rtwdev,
+			      struct rtw_pci_rx_ring *rx_ring,
+			      u32 idx)
+{
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	struct rtw_chip_info *chip = rtwdev->chip;
+	struct rtw_pci_rx_buffer_desc *buf_desc;
+	u32 desc_sz = chip->rx_buf_desc_sz;
+	u16 total_pkt_size;
+
+	buf_desc = (struct rtw_pci_rx_buffer_desc *)(rx_ring->r.head +
+						     idx * desc_sz);
+	total_pkt_size = le16_to_cpu(buf_desc->total_pkt_size);
+
+	/* rx tag mismatch, throw a warning */
+	if (total_pkt_size != rtwpci->rx_tag)
+		rtw_warn(rtwdev, "pci bus timeout, check dma status\n");
+
+	rtwpci->rx_tag = (rtwpci->rx_tag + 1) % RX_TAG_MAX;
+}
+
+static int rtw_pci_xmit(struct rtw_dev *rtwdev,
+			struct rtw_tx_pkt_info *pkt_info,
+			struct sk_buff *skb, u8 queue)
+{
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	struct rtw_chip_info *chip = rtwdev->chip;
+	struct rtw_pci_tx_ring *ring;
+	struct rtw_pci_tx_data *tx_data;
+	dma_addr_t dma;
+	u32 tx_pkt_desc_sz = chip->tx_pkt_desc_sz;
+	u32 tx_buf_desc_sz = chip->tx_buf_desc_sz;
+	u32 size;
+	u32 psb_len;
+	u8 *pkt_desc;
+	struct rtw_pci_tx_buffer_desc *buf_desc;
+	u32 bd_idx;
+
+	ring = &rtwpci->tx_rings[queue];
+
+	size = skb->len;
+
+	if (queue == RTW_TX_QUEUE_BCN)
+		rtw_pci_release_rsvd_page(rtwpci, ring);
+	else if (!avail_desc(ring->r.wp, ring->r.rp, ring->r.len))
+		return -ENOSPC;
+
+	pkt_desc = skb_push(skb, chip->tx_pkt_desc_sz);
+	memset(pkt_desc, 0, tx_pkt_desc_sz);
+	pkt_info->qsel = rtw_pci_get_tx_qsel(skb, queue);
+	rtw_tx_fill_tx_desc(pkt_info, skb);
+	dma = pci_map_single(rtwpci->pdev, skb->data, skb->len,
+			     PCI_DMA_TODEVICE);
+	if (pci_dma_mapping_error(rtwpci->pdev, dma))
+		return -EBUSY;
+
+	/* after this we got dma mapped, there is no way back */
+	buf_desc = get_tx_buffer_desc(ring, tx_buf_desc_sz);
+	memset(buf_desc, 0, tx_buf_desc_sz);
+	psb_len = (skb->len - 1) / 128 + 1;
+	if (queue == RTW_TX_QUEUE_BCN)
+		psb_len |= 1 << RTK_PCI_TXBD_OWN_OFFSET;
+
+	buf_desc[0].psb_len = cpu_to_le16(psb_len);
+	buf_desc[0].buf_size = cpu_to_le16(tx_pkt_desc_sz);
+	buf_desc[0].dma = cpu_to_le32(dma);
+	buf_desc[1].buf_size = cpu_to_le16(size);
+	buf_desc[1].dma = cpu_to_le32(dma + tx_pkt_desc_sz);
+
+	tx_data = rtw_pci_get_tx_data(skb);
+	tx_data->dma = dma;
+	tx_data->sn = pkt_info->sn;
+	skb_queue_tail(&ring->queue, skb);
+
+	/* kick off tx queue */
+	if (queue != RTW_TX_QUEUE_BCN) {
+		if (++ring->r.wp >= ring->r.len)
+			ring->r.wp = 0;
+		bd_idx = rtw_pci_tx_queue_idx_addr[queue];
+		rtw_write16(rtwdev, bd_idx, ring->r.wp & 0xfff);
+	} else {
+		u32 reg_bcn_work;
+
+		reg_bcn_work = rtw_read8(rtwdev, RTK_PCI_TXBD_BCN_WORK);
+		reg_bcn_work |= BIT_PCI_BCNQ_FLAG;
+		rtw_write8(rtwdev, RTK_PCI_TXBD_BCN_WORK, reg_bcn_work);
 	}
 
 	return 0;
+}
 
-err_free_rings:
-	for (rxring_idx = 0; rxring_idx < RTL_PCI_MAX_RX_QUEUE; rxring_idx++)
-		_rtl_pci_free_rx_ring(hw, rxring_idx);
+static int rtw_pci_write_data_rsvd_page(struct rtw_dev *rtwdev, u8 *buf,
+					u32 size)
+{
+	struct sk_buff *skb;
+	struct rtw_tx_pkt_info pkt_info;
+	u32 tx_pkt_desc_sz;
+	u32 length;
+
+	tx_pkt_desc_sz = rtwdev->chip->tx_pkt_desc_sz;
+	length = size + tx_pkt_desc_sz;
+	skb = dev_alloc_skb(length);
+	if (!skb)
+		return -ENOMEM;
 
-	for (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++)
-		if (rtlpci->tx_ring[i].desc ||
-		    rtlpci->tx_ring[i].buffer_desc)
-			_rtl_pci_free_tx_ring(hw, i);
+	skb_reserve(skb, tx_pkt_desc_sz);
+	memcpy((u8 *)skb_put(skb, size), buf, size);
+	memset(&pkt_info, 0, sizeof(pkt_info));
+	pkt_info.tx_pkt_size = size;
+	pkt_info.offset = tx_pkt_desc_sz;
 
-	return 1;
+	return rtw_pci_xmit(rtwdev, &pkt_info, skb, RTW_TX_QUEUE_BCN);
 }
 
-static int _rtl_pci_deinit_trx_ring(struct ieee80211_hw *hw)
+static int rtw_pci_write_data_h2c(struct rtw_dev *rtwdev, u8 *buf, u32 size)
 {
-	u32 i, rxring_idx;
-
-	/*free rx rings */
-	for (rxring_idx = 0; rxring_idx < RTL_PCI_MAX_RX_QUEUE; rxring_idx++)
-		_rtl_pci_free_rx_ring(hw, rxring_idx);
+	struct sk_buff *skb;
+	struct rtw_tx_pkt_info pkt_info;
+	u32 tx_pkt_desc_sz;
+	u32 length;
+
+	tx_pkt_desc_sz = rtwdev->chip->tx_pkt_desc_sz;
+	length = size + tx_pkt_desc_sz;
+	skb = dev_alloc_skb(length);
+	if (!skb)
+		return -ENOMEM;
 
-	/*free tx rings */
-	for (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++)
-		_rtl_pci_free_tx_ring(hw, i);
+	skb_reserve(skb, tx_pkt_desc_sz);
+	memcpy((u8 *)skb_put(skb, size), buf, size);
+	memset(&pkt_info, 0, sizeof(pkt_info));
+	pkt_info.tx_pkt_size = size;
 
-	return 0;
+	return rtw_pci_xmit(rtwdev, &pkt_info, skb, RTW_TX_QUEUE_H2C);
 }
 
-int rtl_pci_reset_trx_ring(struct ieee80211_hw *hw)
+static int rtw_pci_tx(struct rtw_dev *rtwdev,
+		      struct rtw_tx_pkt_info *pkt_info,
+		      struct sk_buff *skb)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	int i, rxring_idx;
-	unsigned long flags;
-	u8 tmp_one = 1;
-	u32 bufferaddress;
-	/* rxring_idx 0:RX_MPDU_QUEUE */
-	/* rxring_idx 1:RX_CMD_QUEUE */
-	for (rxring_idx = 0; rxring_idx < RTL_PCI_MAX_RX_QUEUE; rxring_idx++) {
-		/* force the rx_ring[RX_MPDU_QUEUE/
-		 * RX_CMD_QUEUE].idx to the first one
-		 *new trx flow, do nothing
-		 */
-		if (!rtlpriv->use_new_trx_flow &&
-		    rtlpci->rx_ring[rxring_idx].desc) {
-			struct rtl_rx_desc *entry = NULL;
-
-			rtlpci->rx_ring[rxring_idx].idx = 0;
-			for (i = 0; i < rtlpci->rxringcount; i++) {
-				entry = &rtlpci->rx_ring[rxring_idx].desc[i];
-				bufferaddress =
-				  rtlpriv->cfg->ops->get_desc(hw, (u8 *)entry,
-				  false, HW_DESC_RXBUFF_ADDR);
-				memset((u8 *)entry, 0,
-				       sizeof(*rtlpci->rx_ring
-				       [rxring_idx].desc));/*clear one entry*/
-				if (rtlpriv->use_new_trx_flow) {
-					/* This is deadcode */
-					rtlpriv->cfg->ops->set_desc(hw,
-					    (u8 *)entry, false,
-					    HW_DESC_RX_PREPARE,
-					    (u8 *)&bufferaddress);
-				} else {
-					rtlpriv->cfg->ops->set_desc(hw,
-					    (u8 *)entry, false,
-					    HW_DESC_RXBUFF_ADDR,
-					    (u8 *)&bufferaddress);
-					rtlpriv->cfg->ops->set_desc(hw,
-					    (u8 *)entry, false,
-					    HW_DESC_RXPKT_LEN,
-					    (u8 *)&rtlpci->rxbuffersize);
-					rtlpriv->cfg->ops->set_desc(hw,
-					    (u8 *)entry, false,
-					    HW_DESC_RXOWN,
-					    (u8 *)&tmp_one);
-				}
-			}
-			rtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,
-					    HW_DESC_RXERO, (u8 *)&tmp_one);
-		}
-		rtlpci->rx_ring[rxring_idx].idx = 0;
-	}
-
-	/*after reset, release previous pending packet,
-	 *and force the  tx idx to the first one
-	 */
-	spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
-	for (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++) {
-		if (rtlpci->tx_ring[i].desc ||
-		    rtlpci->tx_ring[i].buffer_desc) {
-			struct rtl8192_tx_ring *ring = &rtlpci->tx_ring[i];
-
-			while (skb_queue_len(&ring->queue)) {
-				u8 *entry;
-				struct sk_buff *skb =
-					__skb_dequeue(&ring->queue);
-				if (rtlpriv->use_new_trx_flow)
-					entry = (u8 *)(&ring->buffer_desc
-								[ring->idx]);
-				else
-					entry = (u8 *)(&ring->desc[ring->idx]);
-
-				pci_unmap_single(rtlpci->pdev,
-						 rtlpriv->cfg->ops->
-							 get_desc(hw, (u8 *)
-							 entry,
-							 true,
-							 HW_DESC_TXBUFF_ADDR),
-						 skb->len, PCI_DMA_TODEVICE);
-				dev_kfree_skb_irq(skb);
-				ring->idx = (ring->idx + 1) % ring->entries;
-			}
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	struct rtw_pci_tx_ring *ring;
+	u8 queue = rtw_hw_queue_mapping(skb);
+	int ret;
 
-			if (rtlpriv->use_new_trx_flow) {
-				rtlpci->tx_ring[i].cur_tx_rp = 0;
-				rtlpci->tx_ring[i].cur_tx_wp = 0;
-			}
+	ret = rtw_pci_xmit(rtwdev, pkt_info, skb, queue);
+	if (ret)
+		return ret;
 
-			ring->idx = 0;
-			ring->entries = rtlpci->txringcount[i];
-		}
+	ring = &rtwpci->tx_rings[queue];
+	if (avail_desc(ring->r.wp, ring->r.rp, ring->r.len) < 2) {
+		ieee80211_stop_queue(rtwdev->hw, skb_get_queue_mapping(skb));
+		ring->queue_stopped = true;
 	}
-	spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-static bool rtl_pci_tx_chk_waitq_insert(struct ieee80211_hw *hw,
-					struct sk_buff *skb)
-#else
-static bool rtl_pci_tx_chk_waitq_insert(struct ieee80211_hw *hw,
-					struct ieee80211_sta *sta,
-					struct sk_buff *skb)
-#endif
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	struct ieee80211_sta *sta = info->control.sta;
-#endif
-	struct rtl_sta_info *sta_entry = NULL;
-	u8 tid = rtl_get_tid(skb);
-	__le16 fc = rtl_get_fc(skb);
-
-	if (!sta)
-		return false;
-	sta_entry = (struct rtl_sta_info *)sta->drv_priv;
-
-	if (!rtlpriv->rtlhal.earlymode_enable)
-		return false;
-	if (ieee80211_is_nullfunc(fc))
-		return false;
-	if (ieee80211_is_qos_nullfunc(fc))
-		return false;
-	if (ieee80211_is_pspoll(fc))
-		return false;
-	if (sta_entry->tids[tid].agg.agg_state != RTL_AGG_OPERATIONAL)
-		return false;
-	if (_rtl_mac_to_hwqueue(hw, skb) > VO_QUEUE)
-		return false;
-	if (tid > 7)
-		return false;
-
-	/* maybe every tid should be checked */
-	if (!rtlpriv->link_info.higher_busytxtraffic[tid])
-		return false;
-
-	spin_lock_bh(&rtlpriv->locks.waitq_lock);
-	skb_queue_tail(&rtlpriv->mac80211.skb_waitq[tid], skb);
-	spin_unlock_bh(&rtlpriv->locks.waitq_lock);
-
-	return true;
-}
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-int rtl_pci_tx(struct ieee80211_hw *hw, struct sk_buff *skb,
-	       struct rtl_tcb_desc *ptcb_desc)
-#else
-static int rtl_pci_tx(struct ieee80211_hw *hw,
-		      struct ieee80211_sta *sta,
-		      struct sk_buff *skb,
-		      struct rtl_tcb_desc *ptcb_desc)
-#endif
+static void rtw_pci_tx_isr(struct rtw_dev *rtwdev, struct rtw_pci *rtwpci,
+			   u8 hw_queue)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_sta_info *sta_entry = NULL;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	struct ieee80211_sta *sta = info->control.sta;
-#endif
-	struct rtl8192_tx_ring *ring;
-	struct rtl_tx_desc *pdesc;
-	struct rtl_tx_buffer_desc *ptx_bd_desc = NULL;
-	u16 idx;
-	u8 hw_queue = _rtl_mac_to_hwqueue(hw, skb);
-	unsigned long flags;
-	struct ieee80211_hdr *hdr = rtl_get_hdr(skb);
-	__le16 fc = rtl_get_fc(skb);
-	u8 *pda_addr = hdr->addr1;
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	u8 own;
-	u8 temp_one = 1;
-
-	if (ieee80211_is_mgmt(fc))
-		rtl_tx_mgmt_proc(hw, skb);
-
-	if (rtlpriv->psc.sw_ps_enabled) {
-		if (ieee80211_is_data(fc) && !ieee80211_is_nullfunc(fc) &&
-		    !ieee80211_has_pm(fc))
-			hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);
-	}
-
-	rtl_action_proc(hw, skb, true);
-
-	if (is_multicast_ether_addr(pda_addr))
-		rtlpriv->stats.txbytesmulticast += skb->len;
-	else if (is_broadcast_ether_addr(pda_addr))
-		rtlpriv->stats.txbytesbroadcast += skb->len;
+	struct ieee80211_hw *hw = rtwdev->hw;
+	struct ieee80211_tx_info *info;
+	struct rtw_pci_tx_ring *ring;
+	struct rtw_pci_tx_data *tx_data;
+	struct sk_buff *skb;
+	u32 count;
+	u32 bd_idx_addr;
+	u32 bd_idx, cur_rp;
+	u16 q_map;
+
+	ring = &rtwpci->tx_rings[hw_queue];
+
+	bd_idx_addr = rtw_pci_tx_queue_idx_addr[hw_queue];
+	bd_idx = rtw_read32(rtwdev, bd_idx_addr);
+	cur_rp = bd_idx >> 16;
+	cur_rp &= 0xfff;
+	if (cur_rp >= ring->r.rp)
+		count = cur_rp - ring->r.rp;
 	else
-		rtlpriv->stats.txbytesunicast += skb->len;
-
-	if (sta) {
-		sta_entry = (struct rtl_sta_info *)sta->drv_priv;
-		sta_entry->txbytes += skb->len;
-	}
+		count = ring->r.len - (ring->r.rp - cur_rp);
 
-	spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
-	ring = &rtlpci->tx_ring[hw_queue];
-	if (hw_queue != BEACON_QUEUE) {
-		if (rtlpriv->use_new_trx_flow)
-			idx = ring->cur_tx_wp;
-		else
-			idx = (ring->idx + skb_queue_len(&ring->queue)) %
-			      ring->entries;
-	} else {
-		idx = 0;
-	}
-
-	pdesc = &ring->desc[idx];
-	if (rtlpriv->use_new_trx_flow) {
-		ptx_bd_desc = &ring->buffer_desc[idx];
-	} else {
-		own = (u8)rtlpriv->cfg->ops->get_desc(hw, (u8 *)pdesc,
-				true, HW_DESC_OWN);
-
-		if (own == 1 && hw_queue != BEACON_QUEUE) {
-			RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-				 "No more TX desc@%d, ring->idx = %d, idx = %d, skb_queue_len = 0x%x\n",
-				 hw_queue, ring->idx, idx,
-				 skb_queue_len(&ring->queue));
-
-			spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock,
-					       flags);
-			return skb->len;
+	while (count--) {
+		skb = skb_dequeue(&ring->queue);
+		tx_data = rtw_pci_get_tx_data(skb);
+		pci_unmap_single(rtwpci->pdev, tx_data->dma, skb->len,
+				 PCI_DMA_TODEVICE);
+
+		/* just free command packets from host to card */
+		if (hw_queue == RTW_TX_QUEUE_H2C) {
+			dev_kfree_skb_irq(skb);
+			continue;
 		}
-	}
-
-	if (rtlpriv->cfg->ops->get_available_desc &&
-	    rtlpriv->cfg->ops->get_available_desc(hw, hw_queue) == 0) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-			 "get_available_desc fail\n");
-		spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
-		return skb->len;
-	}
 
-	if (ieee80211_is_data(fc))
-		rtlpriv->cfg->ops->led_control(hw, LED_CTL_TX);
+		if (ring->queue_stopped &&
+		    avail_desc(ring->r.wp, ring->r.rp, ring->r.len) > 4) {
+			q_map = skb_get_queue_mapping(skb);
+			ieee80211_wake_queue(hw, q_map);
+			ring->queue_stopped = false;
+		}
 
-	rtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *)pdesc,
-			(u8 *)ptx_bd_desc, info, sta, skb, hw_queue, ptcb_desc);
+		skb_pull(skb, rtwdev->chip->tx_pkt_desc_sz);
 
-	__skb_queue_tail(&ring->queue, skb);
+		info = IEEE80211_SKB_CB(skb);
 
-	if (rtlpriv->use_new_trx_flow) {
-		rtlpriv->cfg->ops->set_desc(hw, (u8 *)pdesc, true,
-					    HW_DESC_OWN, &hw_queue);
-	} else {
-		rtlpriv->cfg->ops->set_desc(hw, (u8 *)pdesc, true,
-					    HW_DESC_OWN, &temp_one);
-	}
+		/* enqueue to wait for tx report */
+		if (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS) {
+			rtw_tx_report_enqueue(rtwdev, skb, tx_data->sn);
+			continue;
+		}
 
-	if ((ring->entries - skb_queue_len(&ring->queue)) < 2 &&
-	    hw_queue != BEACON_QUEUE) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
-			 "less desc left, stop skb_queue@%d, ring->idx = %d, idx = %d, skb_queue_len = 0x%x\n",
-			 hw_queue, ring->idx, idx,
-			 skb_queue_len(&ring->queue));
+		/* always ACK for others, then they won't be marked as drop */
+		if (info->flags & IEEE80211_TX_CTL_NO_ACK)
+			info->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;
+		else
+			info->flags |= IEEE80211_TX_STAT_ACK;
 
-		ieee80211_stop_queue(hw, skb_get_queue_mapping(skb));
+		ieee80211_tx_info_clear_status(info);
+		ieee80211_tx_status_irqsafe(hw, skb);
 	}
 
-	spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
-
-	rtlpriv->cfg->ops->tx_polling(hw, hw_queue);
-
-	return 0;
+	ring->r.rp = cur_rp;
 }
 
-static void rtl_pci_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
+static void rtw_pci_rx_isr(struct rtw_dev *rtwdev, struct rtw_pci *rtwpci,
+			   u8 hw_queue)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	u16 i = 0;
-	int queue_id;
-	struct rtl8192_tx_ring *ring;
-
-	if (mac->skip_scan)
-		return;
-
-	for (queue_id = RTL_PCI_MAX_TX_QUEUE_COUNT - 1; queue_id >= 0;) {
-		u32 queue_len;
+	struct rtw_chip_info *chip = rtwdev->chip;
+	struct rtw_pci_rx_ring *ring;
+	struct rtw_rx_pkt_stat pkt_stat;
+	struct ieee80211_rx_status rx_status;
+	struct sk_buff *skb, *new;
+	u32 cur_wp, cur_rp, tmp;
+	u32 count;
+	u32 pkt_offset;
+	u32 pkt_desc_sz = chip->rx_pkt_desc_sz;
+	u32 buf_desc_sz = chip->rx_buf_desc_sz;
+	u8 *rx_desc;
+	dma_addr_t dma;
+
+	ring = &rtwpci->rx_rings[RTW_RX_QUEUE_MPDU];
+
+	tmp = rtw_read32(rtwdev, RTK_PCI_RXBD_IDX_MPDUQ);
+	cur_wp = tmp >> 16;
+	cur_wp &= 0xfff;
+	if (cur_wp >= ring->r.wp)
+		count = cur_wp - ring->r.wp;
+	else
+		count = ring->r.len - (ring->r.wp - cur_wp);
 
-		if (((queues >> queue_id) & 0x1) == 0) {
-			queue_id--;
-			continue;
-		}
-		ring = &pcipriv->dev.tx_ring[queue_id];
-		queue_len = skb_queue_len(&ring->queue);
-		if (queue_len == 0 || queue_id == BEACON_QUEUE ||
-		    queue_id == TXCMD_QUEUE) {
-			queue_id--;
-			continue;
+	cur_rp = ring->r.rp;
+	while (count--) {
+		rtw_pci_dma_check(rtwdev, ring, cur_rp);
+		skb = ring->buf[cur_rp];
+		dma = *((dma_addr_t *)skb->cb);
+		pci_unmap_single(rtwpci->pdev, dma, RTK_PCI_RX_BUF_SIZE,
+				 PCI_DMA_FROMDEVICE);
+		rx_desc = skb->data;
+		chip->ops->query_rx_desc(rtwdev, rx_desc, &pkt_stat, &rx_status);
+
+		/* offset from rx_desc to payload */
+		pkt_offset = pkt_desc_sz + pkt_stat.drv_info_sz +
+			     pkt_stat.shift;
+
+		if (pkt_stat.is_c2h) {
+			/* keep rx_desc, halmac needs it */
+			skb_put(skb, pkt_stat.pkt_len + pkt_offset);
+
+			/* pass offset for further operation */
+			*((u32 *)skb->cb) = pkt_offset;
+			skb_queue_tail(&rtwdev->c2h_queue, skb);
+			ieee80211_queue_work(rtwdev->hw, &rtwdev->c2h_work);
 		} else {
-			msleep(20);
-			i++;
+			/* remove rx_desc, maybe use skb_pull? */
+			skb_put(skb, pkt_stat.pkt_len);
+			skb_reserve(skb, pkt_offset);
+
+			/* alloc a smaller skb to mac80211 */
+			new = dev_alloc_skb(pkt_stat.pkt_len);
+			if (!new) {
+				new = skb;
+			} else {
+				skb_put_data(new, skb->data, skb->len);
+				dev_kfree_skb_any(skb);
+			}
+			/* TODO: merge into rx.c */
+			rtw_rx_stats(rtwdev, pkt_stat.vif, skb);
+			memcpy(new->cb, &rx_status, sizeof(rx_status));
+			ieee80211_rx_irqsafe(rtwdev->hw, new);
 		}
 
-		/* we just wait 1s for all queues */
-		if (rtlpriv->psc.rfpwr_state == ERFOFF ||
-		    is_hal_stop(rtlhal) || i >= 200)
+		/* skb delivered to mac80211, alloc a new one in rx ring */
+		new = dev_alloc_skb(RTK_PCI_RX_BUF_SIZE);
+		if (WARN(!new, "rx routine starvation\n"))
 			return;
-	}
-}
 
-static void rtl_pci_deinit(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
+		ring->buf[cur_rp] = new;
+		rtw_pci_reset_rx_desc(rtwdev, new, ring, cur_rp, buf_desc_sz);
 
-	_rtl_pci_deinit_trx_ring(hw);
+		/* host read next element in ring */
+		if (++cur_rp >= ring->r.len)
+			cur_rp = 0;
+	}
+
+	ring->r.rp = cur_rp;
+	ring->r.wp = cur_wp;
+	rtw_write16(rtwdev, RTK_PCI_RXBD_IDX_MPDUQ, ring->r.rp);
+}
+
+static void rtw_pci_irq_recognized(struct rtw_dev *rtwdev,
+				   struct rtw_pci *rtwpci, u32 *irq_status)
+{
+	irq_status[0] = rtw_read32(rtwdev, RTK_PCI_HISR0);
+	irq_status[1] = rtw_read32(rtwdev, RTK_PCI_HISR1);
+	irq_status[3] = rtw_read32(rtwdev, RTK_PCI_HISR3);
+	irq_status[0] &= rtwpci->irq_mask[0];
+	irq_status[1] &= rtwpci->irq_mask[1];
+	irq_status[3] &= rtwpci->irq_mask[3];
+	rtw_write32(rtwdev, RTK_PCI_HISR0, irq_status[0]);
+	rtw_write32(rtwdev, RTK_PCI_HISR1, irq_status[1]);
+	rtw_write32(rtwdev, RTK_PCI_HISR3, irq_status[3]);
+}
+
+static irqreturn_t rtw_pci_interrupt_handler(int irq, void *dev)
+{
+	struct rtw_dev *rtwdev = dev;
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	u32 irq_status[4];
+
+	spin_lock(&rtwpci->irq_lock);
+	if (!rtwpci->irq_enabled)
+		goto out;
+
+	rtw_pci_irq_recognized(rtwdev, rtwpci, irq_status);
+
+	if (irq_status[0] & IMR_MGNTDOK)
+		rtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_MGMT);
+	if (irq_status[0] & IMR_HIGHDOK)
+		rtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_HI0);
+	if (irq_status[0] & IMR_BEDOK)
+		rtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_BE);
+	if (irq_status[0] & IMR_BKDOK)
+		rtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_BK);
+	if (irq_status[0] & IMR_VODOK)
+		rtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_VO);
+	if (irq_status[0] & IMR_VIDOK)
+		rtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_VI);
+	if (irq_status[3] & IMR_H2CDOK)
+		rtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_H2C);
+	if (irq_status[0] & IMR_ROK)
+		rtw_pci_rx_isr(rtwdev, rtwpci, RTW_RX_QUEUE_MPDU);
+
+out:
+	spin_unlock(&rtwpci->irq_lock);
+
+	return IRQ_HANDLED;
+}
+
+static int rtw_pci_io_mapping(struct rtw_dev *rtwdev,
+			      struct pci_dev *pdev)
+{
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
+	unsigned long len;
+	u8 bar_id = 2;
+	int ret;
+
+	ret = pci_request_regions(pdev, KBUILD_MODNAME);
+	if (ret) {
+		rtw_err(rtwdev, "failed to request pci regions\n");
+		return ret;
+	}
 
-	synchronize_irq(rtlpci->pdev->irq);
-	tasklet_kill(&rtlpriv->works.irq_tasklet);
-	cancel_work_sync(&rtlpriv->works.lps_change_work);
+	len = pci_resource_len(pdev, bar_id);
+	rtwpci->mmap = pci_iomap(pdev, bar_id, len);
+	if (!rtwpci->mmap) {
+		rtw_err(rtwdev, "failed to map pci memory\n");
+		return -ENOMEM;
+	}
 
-	flush_workqueue(rtlpriv->works.rtl_wq);
-	destroy_workqueue(rtlpriv->works.rtl_wq);
+	return 0;
 }
 
-static int rtl_pci_init(struct ieee80211_hw *hw, struct pci_dev *pdev)
+static void rtw_pci_io_unmapping(struct rtw_dev *rtwdev,
+				 struct pci_dev *pdev)
 {
-	int err;
-
-	_rtl_pci_init_struct(hw, pdev);
+	struct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;
 
-	err = _rtl_pci_init_trx_ring(hw);
-	if (err) {
-		pr_err("tx ring initialization failed\n");
-		return err;
+	if (rtwpci->mmap) {
+		pci_iounmap(pdev, rtwpci->mmap);
+		pci_release_regions(pdev);
 	}
-
-	return 0;
 }
 
-static int rtl_pci_start(struct ieee80211_hw *hw)
+static void rtw_dbi_write8(struct rtw_dev *rtwdev, u16 addr, u8 data)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));
+	u16 write_addr;
+	u16 remainder = addr & 0x3;
+	u8 flag;
+	u8 cnt = 20;
 
-	int err;
+	write_addr = ((addr & 0x0ffc) | (BIT(0) << (remainder + 12)));
+	rtw_write8(rtwdev, REG_DBI_WDATA_V1 + remainder, data);
+	rtw_write16(rtwdev, REG_DBI_FLAG_V1, write_addr);
+	rtw_write8(rtwdev, REG_DBI_FLAG_V1 + 2, 0x01);
 
-	rtl_pci_reset_trx_ring(hw);
-
-	rtlpci->driver_is_goingto_unload = false;
-	if (rtlpriv->cfg->ops->get_btc_status &&
-	    rtlpriv->cfg->ops->get_btc_status()) {
-		rtlpriv->btcoexist.btc_info.ap_num = 36;
-		rtlpriv->btcoexist.btc_ops->btc_init_variables(rtlpriv);
-		rtlpriv->btcoexist.btc_ops->btc_init_hal_vars(rtlpriv);
-	} else if (rtlpriv->btcoexist.btc_ops) {
-		rtlpriv->btcoexist.btc_ops->btc_init_variables_wifi_only(
-								rtlpriv);
+	flag = rtw_read8(rtwdev, REG_DBI_FLAG_V1 + 2);
+	while (flag && (cnt != 0)) {
+		udelay(10);
+		flag = rtw_read8(rtwdev, REG_DBI_FLAG_V1 + 2);
+		cnt--;
 	}
 
-	err = rtlpriv->cfg->ops->hw_init(hw);
-	if (err) {
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "Failed to config hardware!\n");
-		return err;
-	}
-	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RETRY_LIMIT,
-			&rtlmac->retry_long);
+	WARN(flag, "DBI write fail\n");
+}
 
-	rtlpriv->cfg->ops->enable_interrupt(hw);
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "enable_interrupt OK\n");
+static void rtw_mdio_write(struct rtw_dev *rtwdev, u8 addr, u16 data, bool g1)
+{
+	u8 page;
+	u8 wflag;
+	u8 cnt;
 
-	rtl_init_rx_config(hw);
+	rtw_write16(rtwdev, REG_MDIO_V1, data);
 
-	/*should be after adapter start and interrupt enable. */
-	set_hal_start(rtlhal);
+	page = addr < 0x20 ? 0 : 1;
+	page += g1 ? 0 : 2;
+	rtw_write8(rtwdev, REG_PCIE_MIX_CFG, addr & 0x1f);
+	rtw_write8(rtwdev, REG_PCIE_MIX_CFG + 3, page);
 
-	RT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);
+	rtw_write32_mask(rtwdev, REG_PCIE_MIX_CFG, BIT_MDIO_WFLAG_V1, 1);
+	wflag = rtw_read32_mask(rtwdev, REG_PCIE_MIX_CFG, BIT_MDIO_WFLAG_V1);
 
-	rtlpci->up_first_time = false;
+	cnt = 20;
+	while (wflag && (cnt != 0)) {
+		udelay(10);
+		wflag = rtw_read32_mask(rtwdev, REG_PCIE_MIX_CFG,
+					BIT_MDIO_WFLAG_V1);
+		cnt--;
+	}
 
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "%s OK\n", __func__);
-	return 0;
+	WARN(wflag, "MDIO write fail\n");
 }
 
-static void rtl_pci_stop(struct ieee80211_hw *hw)
+static void rtw_pci_phy_cfg(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	unsigned long flags;
-	u8 rf_timeout = 0;
-
-	if (rtlpriv->cfg->ops->get_btc_status())
-		rtlpriv->btcoexist.btc_ops->btc_halt_notify(rtlpriv);
-
-	if (rtlpriv->btcoexist.btc_ops)
-		rtlpriv->btcoexist.btc_ops->btc_deinit_variables(rtlpriv);
-
-	/*should be before disable interrupt&adapter
-	 *and will do it immediately.
-	 */
-	set_hal_stop(rtlhal);
-
-	rtlpci->driver_is_goingto_unload = true;
-	rtlpriv->cfg->ops->disable_interrupt(hw);
-	cancel_work_sync(&rtlpriv->works.lps_change_work);
-
-	spin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flags);
-	while (ppsc->rfchange_inprogress) {
-		spin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flags);
-		if (rf_timeout > 100) {
-			spin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flags);
-			break;
-		}
-		mdelay(1);
-		rf_timeout++;
-		spin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flags);
-	}
-	ppsc->rfchange_inprogress = true;
-	spin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flags);
-
-	rtlpriv->cfg->ops->hw_disable(hw);
-	/* some things are not needed if firmware not available */
-	if (!rtlpriv->max_fw_size)
-		return;
-	rtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);
+	struct rtw_chip_info *chip = rtwdev->chip;
+	struct rtw_intf_phy_para *para;
+	u16 cut;
+	u16 value;
+	u16 offset;
+	u16 ip_sel;
+	int i;
 
-	spin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flags);
-	ppsc->rfchange_inprogress = false;
-	spin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flags);
-
-	rtl_pci_enable_aspm(hw);
-}
-
-static bool _rtl_pci_find_adapter(struct pci_dev *pdev,
-				  struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct pci_dev *bridge_pdev = pdev->bus->self;
-	u16 venderid;
-	u16 deviceid;
-	u8 revisionid;
-	u16 irqline;
-	u8 tmp;
+	cut = BIT(0) << rtwdev->hal.cut_version;
 
-	pcipriv->ndis_adapter.pcibridge_vendor = PCI_BRIDGE_VENDOR_UNKNOWN;
-	venderid = pdev->vendor;
-	deviceid = pdev->device;
-	pci_read_config_byte(pdev, 0x8, &revisionid);
-	pci_read_config_word(pdev, 0x3C, &irqline);
-
-	/* PCI ID 0x10ec:0x8192 occurs for both RTL8192E, which uses
-	 * r8192e_pci, and RTL8192SE, which uses this driver. If the
-	 * revision ID is RTL_PCI_REVISION_ID_8192PCIE (0x01), then
-	 * the correct driver is r8192e_pci, thus this routine should
-	 * return false.
-	 */
-	if (deviceid == RTL_PCI_8192SE_DID &&
-	    revisionid == RTL_PCI_REVISION_ID_8192PCIE)
-		return false;
-
-	if (deviceid == RTL_PCI_8192_DID ||
-	    deviceid == RTL_PCI_0044_DID ||
-	    deviceid == RTL_PCI_0047_DID ||
-	    deviceid == RTL_PCI_8192SE_DID ||
-	    deviceid == RTL_PCI_8174_DID ||
-	    deviceid == RTL_PCI_8173_DID ||
-	    deviceid == RTL_PCI_8172_DID ||
-	    deviceid == RTL_PCI_8171_DID) {
-		switch (revisionid) {
-		case RTL_PCI_REVISION_ID_8192PCIE:
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-				 "8192 PCI-E is found - vid/did=%x/%x\n",
-				 venderid, deviceid);
-			rtlhal->hw_type = HARDWARE_TYPE_RTL8192E;
-			return false;
-		case RTL_PCI_REVISION_ID_8192SE:
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-				 "8192SE is found - vid/did=%x/%x\n",
-				 venderid, deviceid);
-			rtlhal->hw_type = HARDWARE_TYPE_RTL8192SE;
-			break;
-		default:
-			RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-				 "Err: Unknown device - vid/did=%x/%x\n",
-				 venderid, deviceid);
-			rtlhal->hw_type = HARDWARE_TYPE_RTL8192SE;
+	for (i = 0; i < chip->intf_table->n_gen1_para; i++) {
+		para = &chip->intf_table->gen1_para[i];
+		if (!(para->cut_mask & cut))
+			continue;
+		if (para->offset == 0xffff)
 			break;
-		}
-	} else if (deviceid == RTL_PCI_8723AE_DID) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8723AE;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "8723AE PCI-E is found - vid/did=%x/%x\n",
-			 venderid, deviceid);
-	} else if (deviceid == RTL_PCI_8192CET_DID ||
-		   deviceid == RTL_PCI_8192CE_DID ||
-		   deviceid == RTL_PCI_8191CE_DID ||
-		   deviceid == RTL_PCI_8188CE_DID) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8192CE;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "8192C PCI-E is found - vid/did=%x/%x\n",
-			 venderid, deviceid);
-	} else if (deviceid == RTL_PCI_8192DE_DID ||
-		   deviceid == RTL_PCI_8192DE_DID2) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8192DE;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "8192D PCI-E is found - vid/did=%x/%x\n",
-			 venderid, deviceid);
-	} else if (deviceid == RTL_PCI_8188EE_DID) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8188EE;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-			 "Find adapter, Hardware type is 8188EE\n");
-	} else if (deviceid == RTL_PCI_8723BE_DID) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8723BE;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-			 "Find adapter, Hardware type is 8723BE\n");
-	} else if (deviceid == RTL_PCI_8192EE_DID) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8192EE;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-			 "Find adapter, Hardware type is 8192EE\n");
-	} else if (deviceid == RTL_PCI_8821AE_DID) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8821AE;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-			 "Find adapter, Hardware type is 8821AE\n");
-	} else if (deviceid == RTL_PCI_8812AE_DID) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8812AE;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-			 "Find adapter, Hardware type is 8812AE\n");
-	} else if (deviceid == RTL_PCI_8822BE_DID) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8822BE;
-		rtlhal->bandset = BAND_ON_BOTH;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-			 "Find adapter, Hardware type is 8822BE\n");
-	} else if (deviceid == RTL_PCI_8723DE_DID) {
-		rtlhal->hw_type = HARDWARE_TYPE_RTL8723DE;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-			 "Find adapter, Hardware type is 8723DE\n");
-	} else {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-			 "Err: Unknown device - vid/did=%x/%x\n",
-			 venderid, deviceid);
-
-		rtlhal->hw_type = RTL_DEFAULT_HARDWARE_TYPE;
-	}
-
-	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8192DE) {
-		if (revisionid == 0 || revisionid == 1) {
-			if (revisionid == 0) {
-				RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-					 "Find 92DE MAC0\n");
-				rtlhal->interfaceindex = 0;
-			} else if (revisionid == 1) {
-				RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-					 "Find 92DE MAC1\n");
-				rtlhal->interfaceindex = 1;
-			}
-		} else {
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-				 "Unknown device - VendorID/DeviceID=%x/%x, Revision=%x\n",
-				 venderid, deviceid, revisionid);
-			rtlhal->interfaceindex = 0;
-		}
-	}
-
-	switch (rtlhal->hw_type) {
-	case HARDWARE_TYPE_RTL8192EE:
-		/* use new trx flow */
-		rtlpriv->use_new_trx_flow = true;
-		rtlpriv->use_new_phydm = false;
-		break;
-	case HARDWARE_TYPE_RTL8822BE:
-	case HARDWARE_TYPE_RTL8723DE:
-		/* use new trx flow */
-		rtlpriv->use_new_trx_flow = true;
-		/* use new phydm */
-		rtlpriv->use_new_phydm = true;
-		break;
-
-	default:
-		rtlpriv->use_new_trx_flow = false;
-		rtlpriv->use_new_phydm = false;
-		break;
-	}
-
-	/*find bus info */
-	pcipriv->ndis_adapter.busnumber = pdev->bus->number;
-	pcipriv->ndis_adapter.devnumber = PCI_SLOT(pdev->devfn);
-	pcipriv->ndis_adapter.funcnumber = PCI_FUNC(pdev->devfn);
-
-	/*find bridge info */
-	pcipriv->ndis_adapter.pcibridge_vendor = PCI_BRIDGE_VENDOR_UNKNOWN;
-	/* some ARM have no bridge_pdev and will crash here
-	 * so we should check if bridge_pdev is NULL
-	 */
-	if (bridge_pdev) {
-		/*find bridge info if available */
-		pcipriv->ndis_adapter.pcibridge_vendorid = bridge_pdev->vendor;
-		for (tmp = 0; tmp < PCI_BRIDGE_VENDOR_MAX; tmp++) {
-			if (bridge_pdev->vendor == pcibridge_vendors[tmp]) {
-				pcipriv->ndis_adapter.pcibridge_vendor = tmp;
-				RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-					 "Pci Bridge Vendor is found index: %d\n",
-					 tmp);
-				break;
-			}
-		}
+		offset = para->offset;
+		value = para->value;
+		ip_sel = para->ip_sel;
+		if (para->ip_sel == RTW_IP_SEL_PHY)
+			rtw_mdio_write(rtwdev, offset, value, true);
+		else
+			rtw_dbi_write8(rtwdev, offset, value);
 	}
 
-	if (pcipriv->ndis_adapter.pcibridge_vendor !=
-		PCI_BRIDGE_VENDOR_UNKNOWN) {
-		pcipriv->ndis_adapter.pcibridge_busnum =
-		    bridge_pdev->bus->number;
-		pcipriv->ndis_adapter.pcibridge_devnum =
-		    PCI_SLOT(bridge_pdev->devfn);
-		pcipriv->ndis_adapter.pcibridge_funcnum =
-		    PCI_FUNC(bridge_pdev->devfn);
-		pcipriv->ndis_adapter.pcibridge_pciehdr_offset =
-		    pci_pcie_cap(bridge_pdev);
-		pcipriv->ndis_adapter.num4bytes =
-		    (pcipriv->ndis_adapter.pcibridge_pciehdr_offset + 0x10) / 4;
-
-		rtl_pci_get_linkcontrol_field(hw);
-
-		if (pcipriv->ndis_adapter.pcibridge_vendor ==
-		    PCI_BRIDGE_VENDOR_AMD) {
-			pcipriv->ndis_adapter.amd_l1_patch =
-			    rtl_pci_get_amd_l1_patch(hw);
-		}
+	for (i = 0; i < chip->intf_table->n_gen2_para; i++) {
+		para = &chip->intf_table->gen2_para[i];
+		if (!(para->cut_mask & cut))
+			continue;
+		if (para->offset == 0xffff)
+			break;
+		offset = para->offset;
+		value = para->value;
+		ip_sel = para->ip_sel;
+		if (para->ip_sel == RTW_IP_SEL_PHY)
+			rtw_mdio_write(rtwdev, offset, value, false);
+		else
+			rtw_dbi_write8(rtwdev, offset, value);
 	}
+}
 
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-		 "pcidev busnumber:devnumber:funcnumber:vendor:link_ctl %d:%d:%d:%x:%x\n",
-		 pcipriv->ndis_adapter.busnumber,
-		 pcipriv->ndis_adapter.devnumber,
-		 pcipriv->ndis_adapter.funcnumber,
-		 pdev->vendor, pcipriv->ndis_adapter.linkctrl_reg);
-
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-		 "pci_bridge busnumber:devnumber:funcnumber:vendor:pcie_cap:link_ctl_reg:amd %d:%d:%d:%x:%x:%x:%x\n",
-		 pcipriv->ndis_adapter.pcibridge_busnum,
-		 pcipriv->ndis_adapter.pcibridge_devnum,
-		 pcipriv->ndis_adapter.pcibridge_funcnum,
-		 pcibridge_vendors[pcipriv->ndis_adapter.pcibridge_vendor],
-		 pcipriv->ndis_adapter.pcibridge_pciehdr_offset,
-		 pcipriv->ndis_adapter.pcibridge_linkctrlreg,
-		 pcipriv->ndis_adapter.amd_l1_patch);
-
-	rtl_pci_parse_configuration(pdev, hw);
-	list_add_tail(&rtlpriv->list, &rtlpriv->glb_var->glb_priv_list);
-
-	return true;
-}
-
-static int rtl_pci_intr_mode_msi(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(pcipriv);
+static int rtw_pci_claim(struct rtw_dev *rtwdev, struct pci_dev *pdev)
+{
 	int ret;
 
-	ret = pci_enable_msi(rtlpci->pdev);
-	if (ret < 0)
-		return ret;
-
-	ret = request_irq(rtlpci->pdev->irq, &_rtl_pci_interrupt,
-			  IRQF_SHARED, KBUILD_MODNAME, hw);
-	if (ret < 0) {
-		pci_disable_msi(rtlpci->pdev);
+	ret = pci_enable_device(pdev);
+	if (ret) {
+		rtw_err(rtwdev, "failed to enable pci device\n");
 		return ret;
 	}
 
-	rtlpci->using_msi = true;
+	pci_set_master(pdev);
+	pci_set_drvdata(pdev, rtwdev->hw);
+	SET_IEEE80211_DEV(rtwdev->hw, &pdev->dev);
 
-	RT_TRACE(rtlpriv, COMP_INIT | COMP_INTR, DBG_DMESG,
-		 "MSI Interrupt Mode!\n");
 	return 0;
 }
 
-static int rtl_pci_intr_mode_legacy(struct ieee80211_hw *hw)
+static void rtw_pci_declaim(struct rtw_dev *rtwdev, struct pci_dev *pdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(pcipriv);
-	int ret;
-
-	ret = request_irq(rtlpci->pdev->irq, &_rtl_pci_interrupt,
-			  IRQF_SHARED, KBUILD_MODNAME, hw);
-	if (ret < 0)
-		return ret;
-
-	rtlpci->using_msi = false;
-	RT_TRACE(rtlpriv, COMP_INIT | COMP_INTR, DBG_DMESG,
-		 "Pin-based Interrupt Mode!\n");
-	return 0;
+	pci_clear_master(pdev);
+	pci_disable_device(pdev);
 }
 
-static int rtl_pci_intr_mode_decide(struct ieee80211_hw *hw)
+static int rtw_pci_setup_resource(struct rtw_dev *rtwdev, struct pci_dev *pdev)
 {
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(pcipriv);
+	struct rtw_pci *rtwpci;
 	int ret;
 
-	if (rtlpci->msi_support) {
-		ret = rtl_pci_intr_mode_msi(hw);
-		if (ret < 0)
-			ret = rtl_pci_intr_mode_legacy(hw);
-	} else {
-		ret = rtl_pci_intr_mode_legacy(hw);
+	rtwpci = (struct rtw_pci *)rtwdev->priv;
+	rtwpci->pdev = pdev;
+
+	/* after this driver can access to hw registers */
+	ret = rtw_pci_io_mapping(rtwdev, pdev);
+	if (ret) {
+		rtw_err(rtwdev, "failed to request pci io region\n");
+		goto err_out;
 	}
-	return ret;
-}
 
-static void platform_enable_dma64(struct pci_dev *pdev, bool dma64)
-{
-	u8	value;
+	ret = rtw_pci_init(rtwdev);
+	if (ret) {
+		rtw_err(rtwdev, "failed to allocate pci resources\n");
+		goto err_io_unmap;
+	}
 
-	pci_read_config_byte(pdev, 0x719, &value);
+	rtw_pci_phy_cfg(rtwdev);
 
-	/* 0x719 Bit5 is DMA64 bit fetch. */
-	if (dma64)
-		value |= BIT(5);
-	else
-		value &= ~BIT(5);
+	return 0;
 
-	pci_write_config_byte(pdev, 0x719, value);
+err_io_unmap:
+	rtw_pci_io_unmapping(rtwdev, pdev);
+
+err_out:
+	return ret;
 }
 
-int rtl_pci_probe(struct pci_dev *pdev,
-		  const struct pci_device_id *id)
+static void rtw_pci_destroy(struct rtw_dev *rtwdev, struct pci_dev *pdev)
 {
-	struct ieee80211_hw *hw = NULL;
-
-	struct rtl_priv *rtlpriv = NULL;
-	struct rtl_pci_priv *pcipriv = NULL;
-	struct rtl_pci *rtlpci;
-	unsigned long pmem_start, pmem_len, pmem_flags;
-	int err;
-
-	err = pci_enable_device(pdev);
-	if (err) {
-		WARN_ONCE(true, "%s : Cannot enable new PCI device\n",
-			  pci_name(pdev));
-		return err;
-	}
-
-	if (((struct rtl_hal_cfg *)id->driver_data)->mod_params->dma64 &&
-	    !pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {
-		if (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64))) {
-			WARN_ONCE(true,
-				  "Unable to obtain 64bit DMA for consistent allocations\n");
-			err = -ENOMEM;
-			goto fail1;
-		}
-
-		platform_enable_dma64(pdev, true);
-	} else if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
-		if (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
-			WARN_ONCE(true,
-				  "rtlwifi: Unable to obtain 32bit DMA for consistent allocations\n");
-			err = -ENOMEM;
-			goto fail1;
-		}
+	rtw_pci_deinit(rtwdev);
+	rtw_pci_io_unmapping(rtwdev, pdev);
+}
 
-		platform_enable_dma64(pdev, false);
-	}
+static struct rtw_hci_ops rtw_pci_ops = {
+	.tx = rtw_pci_tx,
+	.setup = rtw_pci_setup,
+	.start = rtw_pci_start,
+	.stop = rtw_pci_stop,
+
+	.read8 = rtw_pci_read8,
+	.read16 = rtw_pci_read16,
+	.read32 = rtw_pci_read32,
+	.write8 = rtw_pci_write8,
+	.write16 = rtw_pci_write16,
+	.write32 = rtw_pci_write32,
+	.write_data_rsvd_page = rtw_pci_write_data_rsvd_page,
+	.write_data_h2c = rtw_pci_write_data_h2c,
+};
 
-	pci_set_master(pdev);
+static int rtw_pci_probe(struct pci_dev *pdev,
+			 const struct pci_device_id *id)
+{
+	struct ieee80211_hw *hw;
+	struct rtw_dev *rtwdev;
+	int drv_data_size;
+	int ret;
 
-	hw = ieee80211_alloc_hw(sizeof(struct rtl_pci_priv) +
-				sizeof(struct rtl_priv), &rtl_ops);
+	drv_data_size = sizeof(struct rtw_dev) + sizeof(struct rtw_pci);
+	hw = ieee80211_alloc_hw(drv_data_size, &rtw_ops);
 	if (!hw) {
-		WARN_ONCE(true,
-			  "%s : ieee80211 alloc failed\n", pci_name(pdev));
-		err = -ENOMEM;
-		goto fail1;
-	}
-
-	SET_IEEE80211_DEV(hw, &pdev->dev);
-	pci_set_drvdata(pdev, hw);
-
-	rtlpriv = hw->priv;
-	rtlpriv->hw = hw;
-	pcipriv = (void *)rtlpriv->priv;
-	pcipriv->dev.pdev = pdev;
-	init_completion(&rtlpriv->firmware_loading_complete);
-	/*proximity init here*/
-	rtlpriv->proximity.proxim_on = false;
-
-	pcipriv = (void *)rtlpriv->priv;
-	pcipriv->dev.pdev = pdev;
-
-	/* init cfg & intf_ops */
-	rtlpriv->rtlhal.interface = INTF_PCI;
-	rtlpriv->cfg = (struct rtl_hal_cfg *)(id->driver_data);
-	rtlpriv->intf_ops = &rtl_pci_ops;
-	rtlpriv->glb_var = &rtl_global_var;
-	rtl_efuse_ops_init(hw);
-
-	/* MEM map */
-	err = pci_request_regions(pdev, KBUILD_MODNAME);
-	if (err) {
-		WARN_ONCE(true, "rtlwifi: Can't obtain PCI resources\n");
-		goto fail1;
-	}
-
-	pmem_start = pci_resource_start(pdev, rtlpriv->cfg->bar_id);
-	pmem_len = pci_resource_len(pdev, rtlpriv->cfg->bar_id);
-	pmem_flags = pci_resource_flags(pdev, rtlpriv->cfg->bar_id);
-
-	/*shared mem start */
-	rtlpriv->io.pci_mem_start =
-			(unsigned long)pci_iomap(pdev,
-			rtlpriv->cfg->bar_id, pmem_len);
-	if (rtlpriv->io.pci_mem_start == 0) {
-		WARN_ONCE(true, "rtlwifi: Can't map PCI mem\n");
-		err = -ENOMEM;
-		goto fail2;
-	}
-
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-		 "mem mapped space: start: 0x%08lx len:%08lx flags:%08lx, after map:0x%08lx\n",
-		 pmem_start, pmem_len, pmem_flags,
-		 rtlpriv->io.pci_mem_start);
-
-	/* Disable Clk Request */
-	pci_write_config_byte(pdev, 0x81, 0);
-	/* leave D3 mode */
-	pci_write_config_byte(pdev, 0x44, 0);
-	pci_write_config_byte(pdev, 0x04, 0x06);
-	pci_write_config_byte(pdev, 0x04, 0x07);
-
-	/* find adapter */
-	if (!_rtl_pci_find_adapter(pdev, hw)) {
-		err = -ENODEV;
-		goto fail2;
-	}
-
-	/* Init IO handler */
-	_rtl_pci_io_handler_init(&pdev->dev, hw);
-
-	/*like read eeprom and so on */
-	rtlpriv->cfg->ops->read_eeprom_info(hw);
-
-	if (rtlpriv->cfg->ops->init_sw_vars(hw)) {
-		pr_err("Can't init_sw_vars\n");
-		err = -ENODEV;
-		goto fail3;
-	}
-	rtlpriv->cfg->ops->init_sw_leds(hw);
-
-	/*aspm */
-	rtl_pci_init_aspm(hw);
-
-	/* Init mac80211 sw */
-	err = rtl_init_core(hw);
-	if (err) {
-		pr_err("Can't allocate sw for mac80211\n");
-		goto fail3;
-	}
-
-	/* Init PCI sw */
-	err = rtl_pci_init(hw, pdev);
-	if (err) {
-		pr_err("Failed to init PCI\n");
-		goto fail3;
-	}
-
-	err = ieee80211_register_hw(hw);
-	if (err) {
-		pr_err("Can't register mac80211 hw.\n");
-		err = -ENODEV;
-		goto fail3;
-	}
-	rtlpriv->mac80211.mac80211_registered = 1;
-
-	/* init mp flag */
-	rtlpriv->mp_mode = 0;
-
-	/* add for debug */
-	rtl_debug_add_one(hw);
-
-	/*init rfkill */
-	rtl_init_rfkill(hw);	/* Init PCI sw */
-
-	rtlpci = rtl_pcidev(pcipriv);
-	err = rtl_pci_intr_mode_decide(hw);
-	if (err) {
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "%s: failed to register IRQ handler\n",
-			 wiphy_name(hw->wiphy));
-		goto fail3;
+		dev_err(&pdev->dev, "failed to allocate hw\n");
+		return -ENOMEM;
 	}
-	rtlpci->irq_alloc = 1;
-
-	set_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);
-	return 0;
-
-fail3:
-	pci_set_drvdata(pdev, NULL);
-	rtl_deinit_core(hw);
-
-fail2:
-	if (rtlpriv->io.pci_mem_start != 0)
-		pci_iounmap(pdev, (void __iomem *)rtlpriv->io.pci_mem_start);
-
-	pci_release_regions(pdev);
-	complete(&rtlpriv->firmware_loading_complete);
-
-fail1:
-	if (hw)
-		ieee80211_free_hw(hw);
-	pci_disable_device(pdev);
 
-	return err;
-}
-EXPORT_SYMBOL(rtl_pci_probe);
+	rtwdev = hw->priv;
+	rtwdev->hw = hw;
+	rtwdev->dev = &pdev->dev;
+	rtwdev->chip = (struct rtw_chip_info *)id->driver_data;
+	rtwdev->hci.ops = &rtw_pci_ops;
+	rtwdev->hci.type = RTW_HCI_TYPE_PCIE;
 
-void rtl_pci_disconnect(struct pci_dev *pdev)
-{
-	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci *rtlpci = rtl_pcidev(pcipriv);
-	struct rtl_mac *rtlmac = rtl_mac(rtlpriv);
-
-	/* just in case driver is removed before firmware callback */
-	wait_for_completion(&rtlpriv->firmware_loading_complete);
-	clear_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);
+	ret = rtw_core_init(rtwdev);
+	if (ret)
+		goto err_release_hw;
 
-	/* remove form debug */
-	rtl_debug_remove_one(hw);
+	rtw_dbg(rtwdev, RTW_DBG_PCI,
+		"rtw88 pci probe: vendor=0x%4.04X device=0x%4.04X rev=%d\n",
+		pdev->vendor, pdev->device, pdev->revision);
 
-	/*ieee80211_unregister_hw will call ops_stop */
-	if (rtlmac->mac80211_registered == 1) {
-		ieee80211_unregister_hw(hw);
-		rtlmac->mac80211_registered = 0;
-	} else {
-		rtl_deinit_deferred_work(hw, false);
-		rtlpriv->intf_ops->adapter_stop(hw);
+	ret = rtw_pci_claim(rtwdev, pdev);
+	if (ret) {
+		rtw_err(rtwdev, "failed to claim pci device\n");
+		goto err_deinit_core;
 	}
-	rtlpriv->cfg->ops->disable_interrupt(hw);
-
-	/*deinit rfkill */
-	rtl_deinit_rfkill(hw);
 
-	rtl_pci_deinit(hw);
-	rtl_deinit_core(hw);
-	rtlpriv->cfg->ops->deinit_sw_vars(hw);
+	ret = rtw_pci_setup_resource(rtwdev, pdev);
+	if (ret) {
+		rtw_err(rtwdev, "failed to setup pci resources\n");
+		goto err_pci_declaim;
+	}
 
-	if (rtlpci->irq_alloc) {
-		free_irq(rtlpci->pdev->irq, hw);
-		rtlpci->irq_alloc = 0;
+	ret = rtw_chip_info_setup(rtwdev);
+	if (ret) {
+		rtw_err(rtwdev, "failed to setup chip information\n");
+		goto err_destroy_pci;
 	}
 
-	if (rtlpci->using_msi)
-		pci_disable_msi(rtlpci->pdev);
+	ret = rtw_register_hw(rtwdev, hw);
+	if (ret) {
+		rtw_err(rtwdev, "failed to register hw\n");
+		goto err_destroy_pci;
+	}
 
-	list_del(&rtlpriv->list);
-	if (rtlpriv->io.pci_mem_start != 0) {
-		pci_iounmap(pdev, (void __iomem *)rtlpriv->io.pci_mem_start);
-		pci_release_regions(pdev);
+	ret = request_irq(pdev->irq, &rtw_pci_interrupt_handler,
+			  IRQF_SHARED, KBUILD_MODNAME, rtwdev);
+	if (ret) {
+		ieee80211_unregister_hw(hw);
+		goto err_destroy_pci;
 	}
 
-	pci_disable_device(pdev);
+	return 0;
+
+err_destroy_pci:
+	rtw_pci_destroy(rtwdev, pdev);
 
-	rtl_pci_disable_aspm(hw);
+err_pci_declaim:
+	rtw_pci_declaim(rtwdev, pdev);
 
-	pci_set_drvdata(pdev, NULL);
+err_deinit_core:
+	rtw_core_deinit(rtwdev);
 
+err_release_hw:
 	ieee80211_free_hw(hw);
+
+	return ret;
 }
-EXPORT_SYMBOL(rtl_pci_disconnect);
 
-#ifdef CONFIG_PM_SLEEP
-/***************************************
- * kernel pci power state define:
- * PCI_D0         ((pci_power_t __force) 0)
- * PCI_D1         ((pci_power_t __force) 1)
- * PCI_D2         ((pci_power_t __force) 2)
- * PCI_D3hot      ((pci_power_t __force) 3)
- * PCI_D3cold     ((pci_power_t __force) 4)
- * PCI_UNKNOWN    ((pci_power_t __force) 5)
-
- * This function is called when system
- * goes into suspend state mac80211 will
- * call rtl_mac_stop() from the mac80211
- * suspend function first, So there is
- * no need to call hw_disable here.
- ****************************************/
-int rtl_pci_suspend(struct device *dev)
+static void rtw_pci_remove(struct pci_dev *pdev)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
 	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	rtlpriv->cfg->ops->hw_suspend(hw);
-	rtl_deinit_rfkill(hw);
+	struct rtw_dev *rtwdev;
+	struct rtw_pci *rtwpci;
 
-	return 0;
-}
-EXPORT_SYMBOL(rtl_pci_suspend);
+	if (!hw)
+		return;
 
-int rtl_pci_resume(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	rtwdev = hw->priv;
+	rtwpci = (struct rtw_pci *)rtwdev->priv;
 
-	rtlpriv->cfg->ops->hw_resume(hw);
-	rtl_init_rfkill(hw);
-	return 0;
+	rtw_unregister_hw(rtwdev, hw);
+	rtw_pci_disable_interrupt(rtwdev, rtwpci);
+	rtw_pci_destroy(rtwdev, pdev);
+	rtw_pci_declaim(rtwdev, pdev);
+	free_irq(rtwpci->pdev->irq, rtwdev);
+	rtw_core_deinit(rtwdev);
+	ieee80211_free_hw(hw);
 }
-EXPORT_SYMBOL(rtl_pci_resume);
-#endif /* CONFIG_PM_SLEEP */
 
-const struct rtl_intf_ops rtl_pci_ops = {
-	.read_efuse_byte = read_efuse_byte,
-	.adapter_start = rtl_pci_start,
-	.adapter_stop = rtl_pci_stop,
-	.check_buddy_priv = rtl_pci_check_buddy_priv,
-	.adapter_tx = rtl_pci_tx,
-	.flush = rtl_pci_flush,
-	.reset_trx_ring = rtl_pci_reset_trx_ring,
-	.waitq_insert = rtl_pci_tx_chk_waitq_insert,
+static const struct pci_device_id rtw_pci_id_table[] = {
+#ifdef CONFIG_RTW88_8822BE
+	{ RTK_PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0xB822, rtw8822b_hw_spec) },
+#endif
+#ifdef CONFIG_RTW88_8822CE
+	{ RTK_PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0xC822, rtw8822c_hw_spec) },
+#endif
+	{},
+};
+MODULE_DEVICE_TABLE(pci, rtw_pci_id_table);
 
-	.disable_aspm = rtl_pci_disable_aspm,
-	.enable_aspm = rtl_pci_enable_aspm,
+static struct pci_driver rtw_pci_driver = {
+	.name = "rtw_pci",
+	.id_table = rtw_pci_id_table,
+	.probe = rtw_pci_probe,
+	.remove = rtw_pci_remove,
 };
+module_pci_driver(rtw_pci_driver);
+
+MODULE_AUTHOR("Realtek Corporation");
+MODULE_DESCRIPTION("Realtek 802.11ac wireless PCI driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff -upr /home/finger/rtlwifi_new1/pci.h drivers/net/wireless/realtek/rtw88/pci.h
--- /home/finger/rtlwifi_new1/pci.h	2019-06-14 10:13:19.914404655 -0500
+++ drivers/net/wireless/realtek/rtw88/pci.h	2019-05-29 10:27:03.759295168 -0500
@@ -1,345 +1,237 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef __RTL_PCI_H__
-#define __RTL_PCI_H__
-
-#include <linux/pci.h>
-/* 1: MSDU packet queue,
- * 2: Rx Command Queue
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright(c) 2018-2019  Realtek Corporation
  */
-#define RTL_PCI_RX_MPDU_QUEUE			0
-#define RTL_PCI_RX_CMD_QUEUE			1
-#define RTL_PCI_MAX_RX_QUEUE			2
-
-#define RTL_PCI_MAX_RX_COUNT			512/*64*/
-#define RTL_PCI_MAX_TX_QUEUE_COUNT		9
-
-#define RT_TXDESC_NUM				128
-#define TX_DESC_NUM_92E				512
-#define TX_DESC_NUM_8822B			512
-#define TX_DESC_NUM_8723D			512
-#define RT_TXDESC_NUM_BE_QUEUE			256
-
-#define BK_QUEUE				0
-#define BE_QUEUE				1
-#define VI_QUEUE				2
-#define VO_QUEUE				3
-#define BEACON_QUEUE				4
-#define TXCMD_QUEUE				5
-#define MGNT_QUEUE				6
-#define HIGH_QUEUE				7
-#define HCCA_QUEUE				8
-#define H2C_QUEUE				TXCMD_QUEUE	/* In 8822B */
-
-#define RTL_PCI_DEVICE(vend, dev, cfg)  \
-	.vendor = (vend), \
-	.device = (dev), \
-	.subvendor = PCI_ANY_ID, \
-	.subdevice = PCI_ANY_ID,\
-	.driver_data = (kernel_ulong_t)&(cfg)
-
-#define INTEL_VENDOR_ID				0x8086
-#define SIS_VENDOR_ID				0x1039
-#define ATI_VENDOR_ID				0x1002
-#define ATI_DEVICE_ID				0x7914
-#define AMD_VENDOR_ID				0x1022
-
-#define PCI_MAX_BRIDGE_NUMBER			255
-#define PCI_MAX_DEVICES				32
-#define PCI_MAX_FUNCTION			8
-
-#define PCI_CONF_ADDRESS	0x0CF8	/*PCI Configuration Space Address */
-#define PCI_CONF_DATA		0x0CFC	/*PCI Configuration Space Data */
-
-#define PCI_CLASS_BRIDGE_DEV		0x06
-#define PCI_SUBCLASS_BR_PCI_TO_PCI	0x04
-#define PCI_CAPABILITY_ID_PCI_EXPRESS	0x10
-#define PCI_CAP_ID_EXP			0x10
-
-#define U1DONTCARE			0xFF
-#define U2DONTCARE			0xFFFF
-#define U4DONTCARE			0xFFFFFFFF
-
-#define RTL_PCI_8192_DID	0x8192	/*8192 PCI-E */
-#define RTL_PCI_8192SE_DID	0x8192	/*8192 SE */
-#define RTL_PCI_8174_DID	0x8174	/*8192 SE */
-#define RTL_PCI_8173_DID	0x8173	/*8191 SE Crab */
-#define RTL_PCI_8172_DID	0x8172	/*8191 SE RE */
-#define RTL_PCI_8171_DID	0x8171	/*8191 SE Unicron */
-#define RTL_PCI_8723AE_DID	0x8723	/*8723AE */
-#define RTL_PCI_0045_DID	0x0045	/*8190 PCI for Ceraga */
-#define RTL_PCI_0046_DID	0x0046	/*8190 Cardbus for Ceraga */
-#define RTL_PCI_0044_DID	0x0044	/*8192e PCIE for Ceraga */
-#define RTL_PCI_0047_DID	0x0047	/*8192e Express Card for Ceraga */
-#define RTL_PCI_700F_DID	0x700F
-#define RTL_PCI_701F_DID	0x701F
-#define RTL_PCI_DLINK_DID	0x3304
-#define RTL_PCI_8723AE_DID	0x8723	/*8723e */
-#define RTL_PCI_8192CET_DID	0x8191	/*8192ce */
-#define RTL_PCI_8192CE_DID	0x8178	/*8192ce */
-#define RTL_PCI_8191CE_DID	0x8177	/*8192ce */
-#define RTL_PCI_8188CE_DID	0x8176	/*8192ce */
-#define RTL_PCI_8192CU_DID	0x8191	/*8192ce */
-#define RTL_PCI_8192DE_DID	0x8193	/*8192de */
-#define RTL_PCI_8192DE_DID2	0x002B	/*92DE*/
-#define RTL_PCI_8188EE_DID	0x8179  /*8188ee*/
-#define RTL_PCI_8723BE_DID	0xB723  /*8723be*/
-#define RTL_PCI_8192EE_DID	0x818B	/*8192ee*/
-#define RTL_PCI_8821AE_DID	0x8821	/*8821ae*/
-#define RTL_PCI_8812AE_DID	0x8812	/*8812ae*/
-#define RTL_PCI_8822BE_DID	0xB822	/*8822be*/
-#define RTL_PCI_8723DE_DID	0xD723	/*8723de*/
-
-/*8192 support 16 pages of IO registers*/
-#define RTL_MEM_MAPPED_IO_RANGE_8190PCI		0x1000
-#define RTL_MEM_MAPPED_IO_RANGE_8192PCIE	0x4000
-#define RTL_MEM_MAPPED_IO_RANGE_8192SE		0x4000
-#define RTL_MEM_MAPPED_IO_RANGE_8192CE		0x4000
-#define RTL_MEM_MAPPED_IO_RANGE_8192DE		0x4000
-
-#define RTL_PCI_REVISION_ID_8190PCI		0x00
-#define RTL_PCI_REVISION_ID_8192PCIE		0x01
-#define RTL_PCI_REVISION_ID_8192SE		0x10
-#define RTL_PCI_REVISION_ID_8192CE		0x1
-#define RTL_PCI_REVISION_ID_8192DE		0x0
-
-#define RTL_DEFAULT_HARDWARE_TYPE	HARDWARE_TYPE_RTL8192CE
-
-enum pci_bridge_vendor {
-	PCI_BRIDGE_VENDOR_INTEL = 0x0,	/*0b'0000,0001 */
-	PCI_BRIDGE_VENDOR_ATI,		/*0b'0000,0010*/
-	PCI_BRIDGE_VENDOR_AMD,		/*0b'0000,0100*/
-	PCI_BRIDGE_VENDOR_SIS,		/*0b'0000,1000*/
-	PCI_BRIDGE_VENDOR_UNKNOWN,	/*0b'0100,0000*/
-	PCI_BRIDGE_VENDOR_MAX,
-};
 
-struct rtl_pci_capabilities_header {
-	u8 capability_id;
-	u8 next;
-};
+#ifndef __RTK_PCI_H_
+#define __RTK_PCI_H_
 
-/* In new TRX flow, Buffer_desc is new concept
- * But TX wifi info == TX descriptor in old flow
- * RX wifi info == RX descriptor in old flow
- */
-struct rtl_tx_buffer_desc {
-	u32 dword[4 * (1 << (BUFDESC_SEG_NUM + 1))];
-} __packed;
-
-struct rtl_tx_desc {
-	u32 dword[16];
-} __packed;
-
-struct rtl_rx_buffer_desc { /*rx buffer desc*/
-	u32 dword[4];
-} __packed;
-
-struct rtl_rx_desc { /*old: rx desc new: rx wifi info*/
-	u32 dword[8];
-} __packed;
-
-struct rtl_tx_cmd_desc {
-	u32 dword[16];
-} __packed;
+#define RTK_PCI_DEVICE(vend, dev, hw_config)	\
+	PCI_DEVICE(vend, dev),			\
+	.driver_data = (kernel_ulong_t)&(hw_config),
+
+#define RTK_DEFAULT_TX_DESC_NUM 128
+#define RTK_BEQ_TX_DESC_NUM	256
+
+#define RTK_MAX_RX_DESC_NUM	512
+/* 8K + rx desc size */
+#define RTK_PCI_RX_BUF_SIZE	(8192 + 24)
+
+#define RTK_PCI_CTRL		0x300
+#define BIT_RST_TRXDMA_INTF	BIT(20)
+#define BIT_RX_TAG_EN		BIT(15)
+#define REG_DBI_WDATA_V1	0x03E8
+#define REG_DBI_FLAG_V1		0x03F0
+#define REG_MDIO_V1		0x03F4
+#define REG_PCIE_MIX_CFG	0x03F8
+#define BIT_MDIO_WFLAG_V1	BIT(5)
+
+#define BIT_PCI_BCNQ_FLAG	BIT(4)
+#define RTK_PCI_TXBD_DESA_BCNQ	0x308
+#define RTK_PCI_TXBD_DESA_H2CQ	0x1320
+#define RTK_PCI_TXBD_DESA_MGMTQ	0x310
+#define RTK_PCI_TXBD_DESA_BKQ	0x330
+#define RTK_PCI_TXBD_DESA_BEQ	0x328
+#define RTK_PCI_TXBD_DESA_VIQ	0x320
+#define RTK_PCI_TXBD_DESA_VOQ	0x318
+#define RTK_PCI_TXBD_DESA_HI0Q	0x340
+#define RTK_PCI_RXBD_DESA_MPDUQ	0x338
+
+/* BCNQ is specialized for rsvd page, does not need to specify a number */
+#define RTK_PCI_TXBD_NUM_H2CQ	0x1328
+#define RTK_PCI_TXBD_NUM_MGMTQ	0x380
+#define RTK_PCI_TXBD_NUM_BKQ	0x38A
+#define RTK_PCI_TXBD_NUM_BEQ	0x388
+#define RTK_PCI_TXBD_NUM_VIQ	0x386
+#define RTK_PCI_TXBD_NUM_VOQ	0x384
+#define RTK_PCI_TXBD_NUM_HI0Q	0x38C
+#define RTK_PCI_RXBD_NUM_MPDUQ	0x382
+#define RTK_PCI_TXBD_IDX_H2CQ	0x132C
+#define RTK_PCI_TXBD_IDX_MGMTQ	0x3B0
+#define RTK_PCI_TXBD_IDX_BKQ	0x3AC
+#define RTK_PCI_TXBD_IDX_BEQ	0x3A8
+#define RTK_PCI_TXBD_IDX_VIQ	0x3A4
+#define RTK_PCI_TXBD_IDX_VOQ	0x3A0
+#define RTK_PCI_TXBD_IDX_HI0Q	0x3B8
+#define RTK_PCI_RXBD_IDX_MPDUQ	0x3B4
+
+#define RTK_PCI_TXBD_RWPTR_CLR	0x39C
+#define RTK_PCI_TXBD_H2CQ_CSR	0x1330
+
+#define BIT_CLR_H2CQ_HOST_IDX	BIT(16)
+#define BIT_CLR_H2CQ_HW_IDX	BIT(8)
+
+#define RTK_PCI_HIMR0		0x0B0
+#define RTK_PCI_HISR0		0x0B4
+#define RTK_PCI_HIMR1		0x0B8
+#define RTK_PCI_HISR1		0x0BC
+#define RTK_PCI_HIMR2		0x10B0
+#define RTK_PCI_HISR2		0x10B4
+#define RTK_PCI_HIMR3		0x10B8
+#define RTK_PCI_HISR3		0x10BC
+/* IMR 0 */
+#define IMR_TIMER2		BIT(31)
+#define IMR_TIMER1		BIT(30)
+#define IMR_PSTIMEOUT		BIT(29)
+#define IMR_GTINT4		BIT(28)
+#define IMR_GTINT3		BIT(27)
+#define IMR_TBDER		BIT(26)
+#define IMR_TBDOK		BIT(25)
+#define IMR_TSF_BIT32_TOGGLE	BIT(24)
+#define IMR_BCNDMAINT0		BIT(20)
+#define IMR_BCNDOK0		BIT(16)
+#define IMR_HSISR_IND_ON_INT	BIT(15)
+#define IMR_BCNDMAINT_E		BIT(14)
+#define IMR_ATIMEND		BIT(12)
+#define IMR_HISR1_IND_INT	BIT(11)
+#define IMR_C2HCMD		BIT(10)
+#define IMR_CPWM2		BIT(9)
+#define IMR_CPWM		BIT(8)
+#define IMR_HIGHDOK		BIT(7)
+#define IMR_MGNTDOK		BIT(6)
+#define IMR_BKDOK		BIT(5)
+#define IMR_BEDOK		BIT(4)
+#define IMR_VIDOK		BIT(3)
+#define IMR_VODOK		BIT(2)
+#define IMR_RDU			BIT(1)
+#define IMR_ROK			BIT(0)
+/* IMR 1 */
+#define IMR_TXFIFO_TH_INT	BIT(30)
+#define IMR_BTON_STS_UPDATE	BIT(29)
+#define IMR_MCUERR		BIT(28)
+#define IMR_BCNDMAINT7		BIT(27)
+#define IMR_BCNDMAINT6		BIT(26)
+#define IMR_BCNDMAINT5		BIT(25)
+#define IMR_BCNDMAINT4		BIT(24)
+#define IMR_BCNDMAINT3		BIT(23)
+#define IMR_BCNDMAINT2		BIT(22)
+#define IMR_BCNDMAINT1		BIT(21)
+#define IMR_BCNDOK7		BIT(20)
+#define IMR_BCNDOK6		BIT(19)
+#define IMR_BCNDOK5		BIT(18)
+#define IMR_BCNDOK4		BIT(17)
+#define IMR_BCNDOK3		BIT(16)
+#define IMR_BCNDOK2		BIT(15)
+#define IMR_BCNDOK1		BIT(14)
+#define IMR_ATIMEND_E		BIT(13)
+#define IMR_ATIMEND		BIT(12)
+#define IMR_TXERR		BIT(11)
+#define IMR_RXERR		BIT(10)
+#define IMR_TXFOVW		BIT(9)
+#define IMR_RXFOVW		BIT(8)
+#define IMR_CPU_MGQ_TXDONE	BIT(5)
+#define IMR_PS_TIMER_C		BIT(4)
+#define IMR_PS_TIMER_B		BIT(3)
+#define IMR_PS_TIMER_A		BIT(2)
+#define IMR_CPUMGQ_TX_TIMER	BIT(1)
+/* IMR 3 */
+#define IMR_H2CDOK		BIT(16)
+
+/* one element is reserved to know if the ring is closed */
+static inline int avail_desc(u32 wp, u32 rp, u32 len)
+{
+	if (rp > wp)
+		return rp - wp - 1;
+	else
+		return len - wp + rp - 1;
+}
+
+#define RTK_PCI_TXBD_OWN_OFFSET 15
+#define RTK_PCI_TXBD_BCN_WORK	0x383
+
+struct rtw_pci_tx_buffer_desc {
+	__le16 buf_size;
+	__le16 psb_len;
+	__le32 dma;
+};
 
-struct rtl8192_tx_ring {
-	struct rtl_tx_desc *desc;
+struct rtw_pci_tx_data {
 	dma_addr_t dma;
-	unsigned int idx;
-	unsigned int entries;
-	struct sk_buff_head queue;
-	/*add for new trx flow*/
-	struct rtl_tx_buffer_desc *buffer_desc; /*tx buffer descriptor*/
-	dma_addr_t buffer_desc_dma; /*tx bufferd desc dma memory*/
-	u16 cur_tx_wp; /* current_tx_write_point */
-	u16 cur_tx_rp; /* current_tx_read_point */
+	u8 sn;
 };
 
-struct rtl8192_rx_ring {
-	struct rtl_rx_desc *desc;
+struct rtw_pci_ring {
+	u8 *head;
 	dma_addr_t dma;
-	unsigned int idx;
-	struct sk_buff *rx_buf[RTL_PCI_MAX_RX_COUNT];
-	/*add for new trx flow*/
-	struct rtl_rx_buffer_desc *buffer_desc; /*rx buffer descriptor*/
-	u16 next_rx_rp; /* next_rx_read_point */
-};
 
-struct rtl_pci {
-	struct pci_dev *pdev;
-	bool irq_enabled;
+	u8 desc_size;
 
-	bool driver_is_goingto_unload;
-	bool up_first_time;
-	bool first_init;
-	bool being_init_adapter;
-	bool init_ready;
-
-	/*Tx */
-	struct rtl8192_tx_ring tx_ring[RTL_PCI_MAX_TX_QUEUE_COUNT];
-	int txringcount[RTL_PCI_MAX_TX_QUEUE_COUNT];
-	u32 transmit_config;
-
-	/*Rx */
-	struct rtl8192_rx_ring rx_ring[RTL_PCI_MAX_RX_QUEUE];
-	int rxringcount;
-	u16 rxbuffersize;
-	u32 receive_config;
-
-	/*irq */
-	u8 irq_alloc;
-	u32 irq_mask[4];	/* 0-1: normal, 2: unused, 3: h2c */
-	u32 sys_irq_mask;
-
-	/*Bcn control register setting */
-	u32 reg_bcn_ctrl_val;
-
-	 /*ASPM*/ u8 const_pci_aspm;
-	u8 const_amdpci_aspm;
-	u8 const_hwsw_rfoff_d3;
-	u8 const_support_pciaspm;
-	/*pci-e bridge */
-	u8 const_hostpci_aspm_setting;
-	/*pci-e device */
-	u8 const_devicepci_aspm_setting;
-	/* If it supports ASPM, Offset[560h] = 0x40,
-	 * otherwise Offset[560h] = 0x00.
-	 */
-	bool support_aspm;
-	bool support_backdoor;
-
-	/*QOS & EDCA */
-	enum acm_method acm_method;
-
-	u16 shortretry_limit;
-	u16 longretry_limit;
-
-	/* MSI support */
-	bool msi_support;
-	bool using_msi;
-	/* interrupt clear before set */
-	bool int_clear;
+	u32 len;
+	u32 wp;
+	u32 rp;
 };
 
-struct mp_adapter {
-	u8 linkctrl_reg;
-
-	u8 busnumber;
-	u8 devnumber;
-	u8 funcnumber;
-
-	u8 pcibridge_busnum;
-	u8 pcibridge_devnum;
-	u8 pcibridge_funcnum;
-
-	u8 pcibridge_vendor;
-	u16 pcibridge_vendorid;
-	u16 pcibridge_deviceid;
-
-	u8 num4bytes;
-
-	u8 pcibridge_pciehdr_offset;
-	u8 pcibridge_linkctrlreg;
+struct rtw_pci_tx_ring {
+	struct rtw_pci_ring r;
+	struct sk_buff_head queue;
+	bool queue_stopped;
+};
 
-	bool amd_l1_patch;
+struct rtw_pci_rx_buffer_desc {
+	__le16 buf_size;
+	__le16 total_pkt_size;
+	__le32 dma;
 };
 
-struct rtl_pci_priv {
-	struct bt_coexist_info bt_coexist;
-	struct rtl_led_ctl ledctl;
-	struct rtl_pci dev;
-	struct mp_adapter ndis_adapter;
+struct rtw_pci_rx_ring {
+	struct rtw_pci_ring r;
+	struct sk_buff *buf[RTK_MAX_RX_DESC_NUM];
 };
 
-#define rtl_pcipriv(hw)		(((struct rtl_pci_priv *)(rtl_priv(hw))->priv))
-#define rtl_pcidev(pcipriv)	(&((pcipriv)->dev))
+#define RX_TAG_MAX	8192
 
-int rtl_pci_reset_trx_ring(struct ieee80211_hw *hw);
+struct rtw_pci {
+	struct pci_dev *pdev;
 
-extern const struct rtl_intf_ops rtl_pci_ops;
+	/* used for pci interrupt */
+	spinlock_t irq_lock;
+	u32 irq_mask[4];
+	bool irq_enabled;
 
-int rtl_pci_probe(struct pci_dev *pdev,
-		  const struct pci_device_id *id);
-void rtl_pci_disconnect(struct pci_dev *pdev);
-#ifdef CONFIG_PM_SLEEP
-int rtl_pci_suspend(struct device *dev);
-int rtl_pci_resume(struct device *dev);
-#endif /* CONFIG_PM_SLEEP */
-static inline u8 pci_read8_sync(struct rtl_priv *rtlpriv, u32 addr)
-{
-	return readb((u8 __iomem *)rtlpriv->io.pci_mem_start + addr);
-}
+	u16 rx_tag;
+	struct rtw_pci_tx_ring tx_rings[RTK_MAX_TX_QUEUE_NUM];
+	struct rtw_pci_rx_ring rx_rings[RTK_MAX_RX_QUEUE_NUM];
 
-static inline u16 pci_read16_sync(struct rtl_priv *rtlpriv, u32 addr)
-{
-	return readw((u8 __iomem *)rtlpriv->io.pci_mem_start + addr);
-}
+	void __iomem *mmap;
+};
 
-static inline u32 pci_read32_sync(struct rtl_priv *rtlpriv, u32 addr)
+static u32 max_num_of_tx_queue(u8 queue)
 {
-	return readl((u8 __iomem *)rtlpriv->io.pci_mem_start + addr);
-}
+	u32 max_num;
 
-static inline void pci_write8_async(struct rtl_priv *rtlpriv, u32 addr, u8 val)
-{
-	writeb(val, (u8 __iomem *)rtlpriv->io.pci_mem_start + addr);
-}
+	switch (queue) {
+	case RTW_TX_QUEUE_BE:
+		max_num = RTK_BEQ_TX_DESC_NUM;
+		break;
+	case RTW_TX_QUEUE_BCN:
+		max_num = 1;
+		break;
+	default:
+		max_num = RTK_DEFAULT_TX_DESC_NUM;
+		break;
+	}
 
-static inline void pci_write16_async(struct rtl_priv *rtlpriv,
-				     u32 addr, u16 val)
-{
-	writew(val, (u8 __iomem *)rtlpriv->io.pci_mem_start + addr);
+	return max_num;
 }
 
-static inline void pci_write32_async(struct rtl_priv *rtlpriv,
-				     u32 addr, u32 val)
+static inline struct
+rtw_pci_tx_data *rtw_pci_get_tx_data(struct sk_buff *skb)
 {
-	writel(val, (u8 __iomem *)rtlpriv->io.pci_mem_start + addr);
-}
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
-static inline u16 calc_fifo_space(u16 rp, u16 wp, u16 size)
-{
-	if (rp <= wp)
-		return size - 1 + rp - wp;
-	return rp - wp - 1;
+	BUILD_BUG_ON(sizeof(struct rtw_pci_tx_data) >
+		     sizeof(info->status.status_driver_data));
+
+	return (struct rtw_pci_tx_data *)info->status.status_driver_data;
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0))
-static inline void *
-pci_zalloc_consistent(struct pci_dev *hwdev, size_t size,
-		      dma_addr_t *dma_handle)
+static inline
+struct rtw_pci_tx_buffer_desc *get_tx_buffer_desc(struct rtw_pci_tx_ring *ring,
+						  u32 size)
 {
-	void *tmp;
+	u8 *buf_desc;
 
-	tmp = pci_alloc_consistent(hwdev, size, dma_handle);
-	if (tmp)
-		memset(tmp, 0, size);
-	return tmp;
+	buf_desc = ring->r.head + ring->r.wp * size;
+	return (struct rtw_pci_tx_buffer_desc *)buf_desc;
 }
-#endif
 
 #endif
Only in drivers/net/wireless/realtek/rtw88/: pci.o
Only in drivers/net/wireless/realtek/rtw88/: .pci.o.cmd
Only in drivers/net/wireless/realtek/rtw88/: phy.c
Only in /home/finger/rtlwifi_new1/: phydm
Only in drivers/net/wireless/realtek/rtw88/: phy.h
Only in drivers/net/wireless/realtek/rtw88/: phy.o
Only in drivers/net/wireless/realtek/rtw88/: .phy.o.cmd
diff -upr /home/finger/rtlwifi_new1/ps.c drivers/net/wireless/realtek/rtw88/ps.c
--- /home/finger/rtlwifi_new1/ps.c	2019-06-14 10:13:19.934404745 -0500
+++ drivers/net/wireless/realtek/rtw88/ps.c	2019-05-29 10:27:03.759295168 -0500
@@ -1,1027 +1,166 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/* Copyright(c) 2018-2019  Realtek Corporation
+ */
 
-#include "wifi.h"
-#include "base.h"
+#include "main.h"
+#include "fw.h"
 #include "ps.h"
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-#include <linux/export.h>
-#endif
-#include "btcoexist/rtl_btc.h"
-
-bool rtl_ps_enable_nic(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));
-
-	/*<1> reset trx ring */
-	if (rtlhal->interface == INTF_PCI)
-		rtlpriv->intf_ops->reset_trx_ring(hw);
-
-	if (is_hal_stop(rtlhal))
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-			 "Driver is already down!\n");
-
-	/*<2> Enable Adapter */
-	if (rtlpriv->cfg->ops->hw_init(hw))
-		return false;
-	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RETRY_LIMIT,
-			&rtlmac->retry_long);
-	RT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);
-
-	/*<2.1> Switch Channel & Bandwidth to last rtl_op_config setting*/
-	rtlpriv->cfg->ops->switch_channel(hw);
-	rtlpriv->cfg->ops->set_channel_access(hw);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
-	rtlpriv->cfg->ops->set_bw_mode(hw,
-			cfg80211_get_chandef_type(&hw->conf.chandef));
-#else
-	rtlpriv->cfg->ops->set_bw_mode(hw, hw->conf.channel_type);
-#endif
-
-	/*<3> Enable Interrupt */
-	rtlpriv->cfg->ops->enable_interrupt(hw);
-
-	/*<enable timer> */
-	rtl_watch_dog_timer_callback(&rtlpriv->works.watchdog_timer);
+#include "mac.h"
+#include "debug.h"
 
-	return true;
-}
-EXPORT_SYMBOL(rtl_ps_enable_nic);
-
-bool rtl_ps_disable_nic(struct ieee80211_hw *hw)
+static int rtw_ips_pwr_up(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	/*<1> Stop all timer */
-	rtl_deinit_deferred_work(hw, true);
+	int ret;
 
-	/*<2> Disable Interrupt */
-	rtlpriv->cfg->ops->disable_interrupt(hw);
-	tasklet_kill(&rtlpriv->works.irq_tasklet);
+	ret = rtw_core_start(rtwdev);
+	if (ret)
+		rtw_err(rtwdev, "leave idle state failed\n");
 
-	/*<3> Disable Adapter */
-	rtlpriv->cfg->ops->hw_disable(hw);
+	rtw_set_channel(rtwdev);
+	rtw_flag_clear(rtwdev, RTW_FLAG_INACTIVE_PS);
 
-	return true;
+	return ret;
 }
-EXPORT_SYMBOL(rtl_ps_disable_nic);
 
-static bool rtl_ps_set_rf_state(struct ieee80211_hw *hw,
-				enum rf_pwrstate state_toset,
-				u32 changesource)
+int rtw_enter_ips(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	enum rf_pwrstate rtstate;
-	bool actionallowed = false;
-	u16 rfwait_cnt = 0;
-
-	/*Only one thread can change
-	 *the RF state at one time, and others
-	 *should wait to be executed.
-	 */
-	while (true) {
-		spin_lock(&rtlpriv->locks.rf_ps_lock);
-		if (ppsc->rfchange_inprogress) {
-			spin_unlock(&rtlpriv->locks.rf_ps_lock);
-
-			RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-				 "RF Change in progress! Wait to set..state_toset(%d).\n",
-				  state_toset);
-
-			/* Set RF after the previous action is done.  */
-			while (ppsc->rfchange_inprogress) {
-				rfwait_cnt++;
-				mdelay(1);
-				/*Wait too long, return false to avoid
-				 *to be stuck here.
-				 */
-				if (rfwait_cnt > 100)
-					return false;
-			}
-		} else {
-			ppsc->rfchange_inprogress = true;
-			spin_unlock(&rtlpriv->locks.rf_ps_lock);
-			break;
-		}
-	}
-
-	rtstate = ppsc->rfpwr_state;
-
-	switch (state_toset) {
-	case ERFON:
-		ppsc->rfoff_reason &= (~changesource);
-
-		if ((changesource == RF_CHANGE_BY_HW) &&
-		    (ppsc->hwradiooff)) {
-			ppsc->hwradiooff = false;
-		}
-
-		if (!ppsc->rfoff_reason) {
-			ppsc->rfoff_reason = 0;
-			actionallowed = true;
-		}
-
-		break;
-
-	case ERFOFF:
-
-		if ((changesource == RF_CHANGE_BY_HW) && !ppsc->hwradiooff) {
-			ppsc->hwradiooff = true;
-		}
-
-		ppsc->rfoff_reason |= changesource;
-		actionallowed = true;
-		break;
-
-	case ERFSLEEP:
-		ppsc->rfoff_reason |= changesource;
-		actionallowed = true;
-		break;
-
-	default:
-		pr_err("switch case %#x not processed\n", state_toset);
-		break;
-	}
-
-	if (actionallowed)
-		rtlpriv->cfg->ops->set_rf_power_state(hw, state_toset);
-
-	spin_lock(&rtlpriv->locks.rf_ps_lock);
-	ppsc->rfchange_inprogress = false;
-	spin_unlock(&rtlpriv->locks.rf_ps_lock);
-
-	return actionallowed;
-}
-
-static void _rtl_ps_inactive_ps(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-
-	ppsc->swrf_processing = true;
-
-	if (ppsc->inactive_pwrstate == ERFON &&
-	    rtlhal->interface == INTF_PCI) {
-		if ((ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM) &&
-		    RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM) &&
-		    rtlhal->interface == INTF_PCI) {
-			rtlpriv->intf_ops->disable_aspm(hw);
-			RT_CLEAR_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
-		}
-	}
-
-	rtl_ps_set_rf_state(hw, ppsc->inactive_pwrstate,
-			    RF_CHANGE_BY_IPS);
-
-	if (ppsc->inactive_pwrstate == ERFOFF &&
-	    rtlhal->interface == INTF_PCI) {
-		if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM &&
-		    !RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {
-			rtlpriv->intf_ops->enable_aspm(hw);
-			RT_SET_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
-		}
-	}
-
-	ppsc->swrf_processing = false;
-}
-
-void rtl_ips_nic_off_wq_callback(void *data)
-{
-	struct rtl_works *rtlworks =
-	    container_of_dwork_rtl(data, struct rtl_works, ips_nic_off_wq);
-	struct ieee80211_hw *hw = rtlworks->hw;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	enum rf_pwrstate rtstate;
-
-	if (mac->opmode != NL80211_IFTYPE_STATION) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-			 "not station return\n");
-		return;
-	}
-
-	if (mac->p2p_in_use)
-		return;
-
-	if (mac->link_state > MAC80211_NOLINK)
-		return;
-
-	if (is_hal_stop(rtlhal))
-		return;
-
-	if (rtlpriv->sec.being_setkey)
-		return;
-
-	if (rtlpriv->cfg->ops->bt_coex_off_before_lps)
-		rtlpriv->cfg->ops->bt_coex_off_before_lps(hw);
+	rtw_flag_set(rtwdev, RTW_FLAG_INACTIVE_PS);
 
-	if (ppsc->inactiveps) {
-		rtstate = ppsc->rfpwr_state;
+	rtw_core_stop(rtwdev);
 
-		/*
-		 *Do not enter IPS in the following conditions:
-		 *(1) RF is already OFF or Sleep
-		 *(2) swrf_processing (indicates the IPS is still under going)
-		 *(3) Connectted (only disconnected can trigger IPS)
-		 *(4) IBSS (send Beacon)
-		 *(5) AP mode (send Beacon)
-		 *(6) monitor mode (rcv packet)
-		 */
-
-		if (rtstate == ERFON &&
-		    !ppsc->swrf_processing &&
-		    (mac->link_state == MAC80211_NOLINK) &&
-		    !mac->act_scanning) {
-			RT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,
-				 "IPSEnter(): Turn off RF\n");
-
-			ppsc->inactive_pwrstate = ERFOFF;
-			ppsc->in_powersavemode = true;
-
-			/* call before RF off */
-			if (rtlpriv->cfg->ops->get_btc_status())
-				rtlpriv->btcoexist.btc_ops->btc_ips_notify(rtlpriv,
-									ppsc->inactive_pwrstate);
-
-			/*rtl_pci_reset_trx_ring(hw); */
-			_rtl_ps_inactive_ps(hw);
-		}
-	}
+	return 0;
 }
 
-void rtl_ips_nic_off(struct ieee80211_hw *hw)
+static void rtw_restore_port_cfg_iter(void *data, u8 *mac,
+				      struct ieee80211_vif *vif)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtw_dev *rtwdev = data;
+	struct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;
+	u32 config = ~0;
 
-	/* because when link with ap, mac80211 will ask us
-	 * to disable nic quickly after scan before linking,
-	 * this will cause link failed, so we delay 100ms here
-	 */
-	queue_delayed_work(rtlpriv->works.rtl_wq,
-			   &rtlpriv->works.ips_nic_off_wq, MSECS(100));
+	rtw_vif_port_config(rtwdev, rtwvif, config);
 }
 
-/* NOTICE: any opmode should exc nic_on, or disable without
- * nic_on may something wrong, like adhoc TP
- */
-void rtl_ips_nic_on(struct ieee80211_hw *hw)
+int rtw_leave_ips(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	enum rf_pwrstate rtstate;
-
-	cancel_delayed_work_sync(&rtlpriv->works.ips_nic_off_wq);
-
-	mutex_lock(&rtlpriv->locks.ips_mutex);
-	if (ppsc->inactiveps) {
-		rtstate = ppsc->rfpwr_state;
-
-		if (rtstate != ERFON &&
-		    !ppsc->swrf_processing &&
-		    ppsc->rfoff_reason <= RF_CHANGE_BY_IPS) {
-
-			ppsc->inactive_pwrstate = ERFON;
-			ppsc->in_powersavemode = false;
-			_rtl_ps_inactive_ps(hw);
-			/* call after RF on */
-			if (rtlpriv->phydm.ops)
-				rtlpriv->phydm.ops->phydm_reset_dm(rtlpriv);
-			if (rtlpriv->cfg->ops->get_btc_status())
-				rtlpriv->btcoexist.btc_ops->btc_ips_notify(rtlpriv,
-									ppsc->inactive_pwrstate);
-		}
-	}
-	mutex_unlock(&rtlpriv->locks.ips_mutex);
-}
-EXPORT_SYMBOL_GPL(rtl_ips_nic_on);
-
-/*for FW LPS*/
+	int ret;
 
-/*
- *Determine if we can set Fw into PS mode
- *in current condition.Return TRUE if it
- *can enter PS mode.
- */
-static bool rtl_get_fwlps_doze(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	u32 ps_timediff;
-
-	ps_timediff = jiffies_to_msecs(jiffies -
-				       ppsc->last_delaylps_stamp_jiffies);
-
-	if (ps_timediff < 2000) {
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
-			 "Delay enter Fw LPS for DHCP, ARP, or EAPOL exchanging state\n");
-		return false;
+	ret = rtw_ips_pwr_up(rtwdev);
+	if (ret) {
+		rtw_err(rtwdev, "failed to leave ips state\n");
+		return ret;
 	}
 
-	if (mac->link_state != MAC80211_LINKED)
-		return false;
-
-	if (mac->opmode == NL80211_IFTYPE_ADHOC)
-		return false;
+	rtw_iterate_vifs_atomic(rtwdev, rtw_restore_port_cfg_iter, rtwdev);
 
-	return true;
+	return 0;
 }
 
-/* Change current and default preamble mode.*/
-void rtl_lps_set_psmode(struct ieee80211_hw *hw, u8 rt_psmode)
+static void rtw_leave_lps_core(struct rtw_dev *rtwdev)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	bool enter_fwlps;
+	struct rtw_lps_conf *conf = &rtwdev->lps_conf;
 
-	if (mac->opmode == NL80211_IFTYPE_ADHOC)
-		return;
+	conf->state = RTW_ALL_ON;
+	conf->awake_interval = 1;
+	conf->rlbm = 0;
+	conf->smart_ps = 0;
 
-	if (mac->link_state != MAC80211_LINKED)
-		return;
-
-	if (ppsc->dot11_psmode == rt_psmode && rt_psmode == EACTIVE)
-		return;
-
-	/* Update power save mode configured. */
-	ppsc->dot11_psmode = rt_psmode;
-
-	/*
-	 *<FW control LPS>
-	 *1. Enter PS mode
-	 *   Set RPWM to Fw to turn RF off and send H2C fw_pwrmode
-	 *   cmd to set Fw into PS mode.
-	 *2. Leave PS mode
-	 *   Send H2C fw_pwrmode cmd to Fw to set Fw into Active
-	 *   mode and set RPWM to turn RF on.
-	 */
-
-	if ((ppsc->fwctrl_lps) && ppsc->report_linked) {
-		if (ppsc->dot11_psmode == EACTIVE) {
-			RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
-				 "FW LPS leave ps_mode:%x\n",
-				  FW_PS_ACTIVE_MODE);
-			enter_fwlps = false;
-			ppsc->pwr_mode = FW_PS_ACTIVE_MODE;
-			ppsc->smart_ps = 0;
-			rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_FW_LPS_ACTION,
-						      (u8 *)(&enter_fwlps));
-			if (ppsc->p2p_ps_info.opp_ps)
-				rtl_p2p_ps_cmd(hw , P2P_PS_ENABLE);
-
-			if (rtlpriv->cfg->ops->get_btc_status())
-				rtlpriv->btcoexist.btc_ops->btc_lps_notify(rtlpriv, rt_psmode);
-		} else {
-			if (rtl_get_fwlps_doze(hw)) {
-				RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
-					 "FW LPS enter ps_mode:%x\n",
-					 ppsc->fwctrl_psmode);
-				if (rtlpriv->cfg->ops->get_btc_status())
-					rtlpriv->btcoexist.btc_ops->btc_lps_notify(rtlpriv, rt_psmode);
-				enter_fwlps = true;
-				ppsc->pwr_mode = ppsc->fwctrl_psmode;
-				ppsc->smart_ps = 2;
-				rtlpriv->cfg->ops->set_hw_reg(hw,
-							HW_VAR_FW_LPS_ACTION,
-							(u8 *)(&enter_fwlps));
-
-			} else {
-				/* Reset the power save related parameters. */
-				ppsc->dot11_psmode = EACTIVE;
-			}
-		}
-	}
+	rtw_fw_set_pwr_mode(rtwdev);
+	rtw_flag_clear(rtwdev, RTW_FLAG_LEISURE_PS);
 }
 
-/* Interrupt safe routine to enter the leisure power save mode.*/
-static void rtl_lps_enter_core(struct ieee80211_hw *hw)
+static void rtw_enter_lps_core(struct rtw_dev *rtwdev)
 {
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtw_lps_conf *conf = &rtwdev->lps_conf;
 
-	if (!ppsc->fwctrl_lps)
-		return;
-
-	if (rtlpriv->sec.being_setkey)
-		return;
+	conf->state = RTW_RF_OFF;
+	conf->awake_interval = 1;
+	conf->rlbm = 1;
+	conf->smart_ps = 2;
 
-	if (rtlpriv->link_info.busytraffic)
-		return;
-
-	/*sleep after linked 10s, to let DHCP and 4-way handshake ok enough!! */
-	if (mac->cnt_after_linked < 5)
-		return;
-
-	if (mac->opmode == NL80211_IFTYPE_ADHOC)
-		return;
-
-	if (mac->link_state != MAC80211_LINKED)
-		return;
-
-	mutex_lock(&rtlpriv->locks.lps_mutex);
-
-	/* Don't need to check (ppsc->dot11_psmode == EACTIVE), because
-	 * bt_ccoexist may ask to enter lps.
-	 * In normal case, this constraint move to rtl_lps_set_psmode().
-	 */
-	RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
-		 "Enter 802.11 power save mode...\n");
-	rtl_lps_set_psmode(hw, EAUTOPS);
-
-	mutex_unlock(&rtlpriv->locks.lps_mutex);
+	rtw_fw_set_pwr_mode(rtwdev);
+	rtw_flag_set(rtwdev, RTW_FLAG_LEISURE_PS);
 }
 
-/* Interrupt safe routine to leave the leisure power save mode.*/
-static void rtl_lps_leave_core(struct ieee80211_hw *hw)
+void rtw_lps_work(struct work_struct *work)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-
-	mutex_lock(&rtlpriv->locks.lps_mutex);
-
-	if (ppsc->fwctrl_lps) {
-		if (ppsc->dot11_psmode != EACTIVE) {
-
-			/*FIX ME */
-			/*rtlpriv->cfg->ops->enable_interrupt(hw); */
-
-			if (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM &&
-			    RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM) &&
-			    rtlhal->interface == INTF_PCI) {
-				rtlpriv->intf_ops->disable_aspm(hw);
-				RT_CLEAR_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
-			}
-
-			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
-				 "Busy Traffic,Leave 802.11 power save..\n");
-
-			rtl_lps_set_psmode(hw, EACTIVE);
-		}
-	}
-	mutex_unlock(&rtlpriv->locks.lps_mutex);
-}
-
-/* For sw LPS*/
-void rtl_swlps_beacon(struct ieee80211_hw *hw, void *data, unsigned int len)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct ieee80211_hdr *hdr = data;
-	struct ieee80211_tim_ie *tim_ie;
-	u8 *tim;
-	u8 tim_len;
-	bool u_buffed;
-	bool m_buffed;
-
-	if (mac->opmode != NL80211_IFTYPE_STATION)
-		return;
-
-	if (!rtlpriv->psc.swctrl_lps)
-		return;
-
-	if (rtlpriv->mac80211.link_state != MAC80211_LINKED)
-		return;
-
-	if (!rtlpriv->psc.sw_ps_enabled)
-		return;
+	struct rtw_dev *rtwdev = container_of(work, struct rtw_dev,
+					      lps_work.work);
+	struct rtw_lps_conf *conf = &rtwdev->lps_conf;
+	struct rtw_vif *rtwvif = conf->rtwvif;
 
-	if (rtlpriv->psc.fwctrl_lps)
+	if (WARN_ON(!rtwvif))
 		return;
 
-	if (likely(!(hw->conf.flags & IEEE80211_CONF_PS)))
-		return;
-
-	/* check if this really is a beacon */
-	if (!ieee80211_is_beacon(hdr->frame_control))
-		return;
-
-	/* min. beacon length + FCS_LEN */
-	if (len <= 40 + FCS_LEN)
-		return;
-
-	/* and only beacons from the associated BSSID, please */
-	if (!ether_addr_equal_64bits(hdr->addr3, rtlpriv->mac80211.bssid))
-		return;
-
-	rtlpriv->psc.last_beacon = jiffies;
-
-	tim = rtl_find_ie(data, len - FCS_LEN, WLAN_EID_TIM);
-	if (!tim)
-		return;
-
-	if (tim[1] < sizeof(*tim_ie))
-		return;
-
-	tim_len = tim[1];
-	tim_ie = (struct ieee80211_tim_ie *) &tim[2];
-
-	if (!WARN_ON_ONCE(!hw->conf.ps_dtim_period))
-		rtlpriv->psc.dtim_counter = tim_ie->dtim_count;
-
-	/* Check whenever the PHY can be turned off again. */
-
-	/* 1. What about buffered unicast traffic for our AID? */
-	u_buffed = ieee80211_check_tim(tim_ie, tim_len,
-				       rtlpriv->mac80211.assoc_id);
-
-	/* 2. Maybe the AP wants to send multicast/broadcast data? */
-	m_buffed = tim_ie->bitmap_ctrl & 0x01;
-	rtlpriv->psc.multi_buffered = m_buffed;
-
-	/* unicast will process by mac80211 through
-	 * set ~IEEE80211_CONF_PS, So we just check
-	 * multicast frames here */
-	if (!m_buffed) {
-		/* back to low-power land. and delay is
-		 * prevent null power save frame tx fail */
-		queue_delayed_work(rtlpriv->works.rtl_wq,
-				   &rtlpriv->works.ps_work, MSECS(5));
-	} else {
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
-			 "u_bufferd: %x, m_buffered: %x\n", u_buffed, m_buffed);
-	}
+	if (conf->mode == RTW_MODE_LPS)
+		rtw_enter_lps_core(rtwdev);
+	else
+		rtw_leave_lps_core(rtwdev);
 }
-EXPORT_SYMBOL_GPL(rtl_swlps_beacon);
 
-void rtl_swlps_rf_awake(struct ieee80211_hw *hw)
+void rtw_enter_lps_irqsafe(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtw_lps_conf *conf = &rtwdev->lps_conf;
 
-	if (!rtlpriv->psc.swctrl_lps)
-		return;
-	if (mac->link_state != MAC80211_LINKED)
+	if (rtwvif->in_lps)
 		return;
 
-	if (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM &&
-	    RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {
-		rtlpriv->intf_ops->disable_aspm(hw);
-		RT_CLEAR_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
-	}
-
-	mutex_lock(&rtlpriv->locks.lps_mutex);
-	rtl_ps_set_rf_state(hw, ERFON, RF_CHANGE_BY_PS);
-	mutex_unlock(&rtlpriv->locks.lps_mutex);
-}
-
-void rtl_swlps_rfon_wq_callback(void *data)
-{
-	struct rtl_works *rtlworks =
-	    container_of_dwork_rtl(data, struct rtl_works, ps_rfon_wq);
-	struct ieee80211_hw *hw = rtlworks->hw;
+	conf->mode = RTW_MODE_LPS;
+	conf->rtwvif = rtwvif;
+	rtwvif->in_lps = true;
 
-	rtl_swlps_rf_awake(hw);
+	ieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->lps_work, 0);
 }
 
-void rtl_swlps_rf_sleep(struct ieee80211_hw *hw)
+void rtw_leave_lps_irqsafe(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	u8 sleep_intv;
-
-	if (!rtlpriv->psc.sw_ps_enabled)
-		return;
-
-	if ((rtlpriv->sec.being_setkey) ||
-	    (mac->opmode == NL80211_IFTYPE_ADHOC))
-		return;
-
-	/*sleep after linked 10s, to let DHCP and 4-way handshake ok enough!! */
-	if ((mac->link_state != MAC80211_LINKED) || (mac->cnt_after_linked < 5))
-		return;
-
-	if (rtlpriv->link_info.busytraffic)
-		return;
+	struct rtw_lps_conf *conf = &rtwdev->lps_conf;
 
-	spin_lock(&rtlpriv->locks.rf_ps_lock);
-	if (rtlpriv->psc.rfchange_inprogress) {
-		spin_unlock(&rtlpriv->locks.rf_ps_lock);
+	if (!rtwvif->in_lps)
 		return;
-	}
-	spin_unlock(&rtlpriv->locks.rf_ps_lock);
-
-	mutex_lock(&rtlpriv->locks.lps_mutex);
-	rtl_ps_set_rf_state(hw, ERFSLEEP, RF_CHANGE_BY_PS);
-	mutex_unlock(&rtlpriv->locks.lps_mutex);
-
-	if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM &&
-	    !RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {
-		rtlpriv->intf_ops->enable_aspm(hw);
-		RT_SET_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
-	}
-
-	/* here is power save alg, when this beacon is DTIM
-	 * we will set sleep time to dtim_period * n;
-	 * when this beacon is not DTIM, we will set sleep
-	 * time to sleep_intv = rtlpriv->psc.dtim_counter or
-	 * MAX_SW_LPS_SLEEP_INTV(default set to 5) */
-
-	if (rtlpriv->psc.dtim_counter == 0) {
-		if (hw->conf.ps_dtim_period == 1)
-			sleep_intv = hw->conf.ps_dtim_period * 2;
-		else
-			sleep_intv = hw->conf.ps_dtim_period;
-	} else {
-		sleep_intv = rtlpriv->psc.dtim_counter;
-	}
 
-	if (sleep_intv > MAX_SW_LPS_SLEEP_INTV)
-		sleep_intv = MAX_SW_LPS_SLEEP_INTV;
+	conf->mode = RTW_MODE_ACTIVE;
+	conf->rtwvif = rtwvif;
+	rtwvif->in_lps = false;
 
-	/* this print should always be dtim_conter = 0 &
-	 * sleep  = dtim_period, that meaons, we should
-	 * awake before every dtim */
-	RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
-		 "dtim_counter:%x will sleep :%d beacon_intv\n",
-		  rtlpriv->psc.dtim_counter, sleep_intv);
-
-	/* we tested that 40ms is enough for sw & hw sw delay */
-	queue_delayed_work(rtlpriv->works.rtl_wq, &rtlpriv->works.ps_rfon_wq,
-			MSECS(sleep_intv * mac->vif->bss_conf.beacon_int - 40));
+	ieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->lps_work, 0);
 }
 
-void rtl_lps_change_work_callback(struct work_struct *work)
+bool rtw_in_lps(struct rtw_dev *rtwdev)
 {
-	struct rtl_works *rtlworks =
-	    container_of(work, struct rtl_works, lps_change_work);
-	struct ieee80211_hw *hw = rtlworks->hw;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	if (rtlpriv->enter_ps)
-		rtl_lps_enter_core(hw);
-	else
-		rtl_lps_leave_core(hw);
+	return rtw_flag_check(rtwdev, RTW_FLAG_LEISURE_PS);
 }
-EXPORT_SYMBOL_GPL(rtl_lps_change_work_callback);
 
-void rtl_lps_enter(struct ieee80211_hw *hw)
+void rtw_enter_lps(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	if (!in_interrupt())
-		return rtl_lps_enter_core(hw);
-	rtlpriv->enter_ps = true;
-	schedule_work(&rtlpriv->works.lps_change_work);
-}
-EXPORT_SYMBOL_GPL(rtl_lps_enter);
-
-void rtl_lps_leave(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	if (!in_interrupt())
-		return rtl_lps_leave_core(hw);
-	rtlpriv->enter_ps = false;
-	schedule_work(&rtlpriv->works.lps_change_work);
-}
-EXPORT_SYMBOL_GPL(rtl_lps_leave);
-
-void rtl_swlps_wq_callback(void *data)
-{
-	struct rtl_works *rtlworks = container_of_dwork_rtl(data,
-				     struct rtl_works,
-				     ps_work);
-	struct ieee80211_hw *hw = rtlworks->hw;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	bool ps = false;
-
-	ps = (hw->conf.flags & IEEE80211_CONF_PS);
-
-	/* we can sleep after ps null send ok */
-	if (rtlpriv->psc.state_inap) {
-		rtl_swlps_rf_sleep(hw);
-
-		if (rtlpriv->psc.state && !ps) {
-			rtlpriv->psc.sleep_ms = jiffies_to_msecs(jiffies -
-						 rtlpriv->psc.last_action);
-		}
-
-		if (ps)
-			rtlpriv->psc.last_slept = jiffies;
-
-		rtlpriv->psc.last_action = jiffies;
-		rtlpriv->psc.state = ps;
-	}
-}
+	struct rtw_lps_conf *conf = &rtwdev->lps_conf;
 
-static void rtl_p2p_noa_ie(struct ieee80211_hw *hw, void *data,
-			   unsigned int len)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct ieee80211_mgmt *mgmt = data;
-	struct rtl_p2p_ps_info *p2pinfo = &(rtlpriv->psc.p2p_ps_info);
-	u8 *pos, *end, *ie;
-	u16 noa_len;
-	static u8 p2p_oui_ie_type[4] = {0x50, 0x6f, 0x9a, 0x09};
-	u8 noa_num, index , i, noa_index = 0;
-	bool find_p2p_ie = false , find_p2p_ps_ie = false;
-	pos = (u8 *)mgmt->u.beacon.variable;
-	end = data + len;
-	ie = NULL;
-
-	while (pos + 1 < end) {
-		if (pos + 2 + pos[1] > end)
-			return;
-
-		if (pos[0] == 221 && pos[1] > 4) {
-			if (memcmp(&pos[2], p2p_oui_ie_type, 4) == 0) {
-				ie = pos + 2+4;
-				break;
-			}
-		}
-		pos += 2 + pos[1];
-	}
-
-	if (ie == NULL)
+	if (WARN_ON(!rtwvif))
 		return;
-	find_p2p_ie = true;
-	/*to find noa ie*/
-	while (ie + 1 < end) {
-		noa_len = READEF2BYTE((__le16 *)&ie[1]);
-		if (ie + 3 + ie[1] > end)
-			return;
-
-		if (ie[0] == 12) {
-			find_p2p_ps_ie = true;
-			if ((noa_len - 2) % 13 != 0) {
-				RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
-					 "P2P notice of absence: invalid length.%d\n",
-					 noa_len);
-				return;
-			} else {
-				noa_num = (noa_len - 2) / 13;
-			}
-			noa_index = ie[3];
-			if (rtlpriv->psc.p2p_ps_info.p2p_ps_mode ==
-			    P2P_PS_NONE || noa_index != p2pinfo->noa_index) {
-				RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,
-					 "update NOA ie.\n");
-				p2pinfo->noa_index = noa_index;
-				p2pinfo->opp_ps = (ie[4] >> 7);
-				p2pinfo->ctwindow = ie[4] & 0x7F;
-				p2pinfo->noa_num = noa_num;
-				index = 5;
-				for (i = 0; i < noa_num; i++) {
-					p2pinfo->noa_count_type[i] =
-							READEF1BYTE(ie+index);
-					index += 1;
-					p2pinfo->noa_duration[i] =
-						 READEF4BYTE((__le32 *)ie+index);
-					index += 4;
-					p2pinfo->noa_interval[i] =
-						 READEF4BYTE((__le32 *)ie+index);
-					index += 4;
-					p2pinfo->noa_start_time[i] =
-						 READEF4BYTE((__le32 *)ie+index);
-					index += 4;
-				}
-
-				if (p2pinfo->opp_ps == 1) {
-					p2pinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
-					/* Driver should wait LPS entering
-					 * CTWindow
-					 */
-					if (rtlpriv->psc.fw_current_inpsmode)
-						rtl_p2p_ps_cmd(hw,
-							       P2P_PS_ENABLE);
-				} else if (p2pinfo->noa_num > 0) {
-					p2pinfo->p2p_ps_mode = P2P_PS_NOA;
-					rtl_p2p_ps_cmd(hw, P2P_PS_ENABLE);
-				} else if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {
-					rtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);
-				}
-			}
-			break;
-		}
-		ie += 3 + noa_len;
-	}
-
-	if (find_p2p_ie == true) {
-		if ((p2pinfo->p2p_ps_mode > P2P_PS_NONE) &&
-		    (find_p2p_ps_ie == false))
-			rtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);
-	}
-}
-
-static void rtl_p2p_action_ie(struct ieee80211_hw *hw, void *data,
-			      unsigned int len)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct ieee80211_mgmt *mgmt = data;
-	struct rtl_p2p_ps_info *p2pinfo = &(rtlpriv->psc.p2p_ps_info);
-	u8 noa_num, index , i , noa_index = 0;
-	u8 *pos, *end, *ie;
-	u16 noa_len;
-	static u8 p2p_oui_ie_type[4] = {0x50, 0x6f, 0x9a, 0x09};
-
-	pos = (u8 *)&mgmt->u.action.category;
-	end = data + len;
-	ie = NULL;
-
-	if (pos[0] == 0x7f) {
-		if (memcmp(&pos[1], p2p_oui_ie_type, 4) == 0)
-			ie = pos + 3+4;
-	}
 
-	if (ie == NULL)
+	if (rtwvif->in_lps)
 		return;
 
-	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "action frame find P2P IE.\n");
-	/*to find noa ie*/
-	while (ie + 1 < end) {
-		noa_len = READEF2BYTE((__le16 *)&ie[1]);
-		if (ie + 3 + ie[1] > end)
-			return;
-
-		if (ie[0] == 12) {
-			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "find NOA IE.\n");
-			RT_PRINT_DATA(rtlpriv, COMP_FW, DBG_LOUD, "noa ie ",
-				      ie, noa_len);
-			if ((noa_len - 2) % 13 != 0) {
-				RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,
-					 "P2P notice of absence: invalid length.%d\n",
-					 noa_len);
-				return;
-			} else {
-				noa_num = (noa_len - 2) / 13;
-			}
-			noa_index = ie[3];
-			if (rtlpriv->psc.p2p_ps_info.p2p_ps_mode ==
-			    P2P_PS_NONE || noa_index != p2pinfo->noa_index) {
-				p2pinfo->noa_index = noa_index;
-				p2pinfo->opp_ps = (ie[4] >> 7);
-				p2pinfo->ctwindow = ie[4] & 0x7F;
-				p2pinfo->noa_num = noa_num;
-				index = 5;
-				for (i = 0; i < noa_num; i++) {
-					p2pinfo->noa_count_type[i] =
-							READEF1BYTE(ie+index);
-					index += 1;
-					p2pinfo->noa_duration[i] =
-							 READEF4BYTE((__le32 *)ie+index);
-					index += 4;
-					p2pinfo->noa_interval[i] =
-							 READEF4BYTE((__le32 *)ie+index);
-					index += 4;
-					p2pinfo->noa_start_time[i] =
-							 READEF4BYTE((__le32 *)ie+index);
-					index += 4;
-				}
-
-				if (p2pinfo->opp_ps == 1) {
-					p2pinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
-					/* Driver should wait LPS entering
-					 * CTWindow
-					 */
-					if (rtlpriv->psc.fw_current_inpsmode)
-						rtl_p2p_ps_cmd(hw,
-							       P2P_PS_ENABLE);
-				} else if (p2pinfo->noa_num > 0) {
-					p2pinfo->p2p_ps_mode = P2P_PS_NOA;
-					rtl_p2p_ps_cmd(hw, P2P_PS_ENABLE);
-				} else if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {
-					rtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);
-				}
-			}
-			break;
-		}
-		ie += 3 + noa_len;
-	}
-}
+	conf->mode = RTW_MODE_LPS;
+	conf->rtwvif = rtwvif;
+	rtwvif->in_lps = true;
 
-void rtl_p2p_ps_cmd(struct ieee80211_hw *hw , u8 p2p_ps_state)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *rtlps = rtl_psc(rtl_priv(hw));
-	struct rtl_p2p_ps_info  *p2pinfo = &(rtlpriv->psc.p2p_ps_info);
-
-	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, " p2p state %x\n" , p2p_ps_state);
-	switch (p2p_ps_state) {
-	case P2P_PS_DISABLE:
-		p2pinfo->p2p_ps_state = p2p_ps_state;
-		rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
-					      &p2p_ps_state);
-		p2pinfo->noa_index = 0;
-		p2pinfo->ctwindow = 0;
-		p2pinfo->opp_ps = 0;
-		p2pinfo->noa_num = 0;
-		p2pinfo->p2p_ps_mode = P2P_PS_NONE;
-		if (rtlps->fw_current_inpsmode) {
-			if (rtlps->smart_ps == 0) {
-				rtlps->smart_ps = 2;
-				rtlpriv->cfg->ops->set_hw_reg(hw,
-					 HW_VAR_H2C_FW_PWRMODE,
-					 &rtlps->pwr_mode);
-			}
-
-		}
-		break;
-	case P2P_PS_ENABLE:
-		if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {
-			p2pinfo->p2p_ps_state = p2p_ps_state;
-
-			if (p2pinfo->ctwindow > 0) {
-				if (rtlps->smart_ps != 0) {
-					rtlps->smart_ps = 0;
-					rtlpriv->cfg->ops->set_hw_reg(hw,
-						 HW_VAR_H2C_FW_PWRMODE,
-						 &rtlps->pwr_mode);
-				}
-			}
-			rtlpriv->cfg->ops->set_hw_reg(hw,
-				 HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
-				 &p2p_ps_state);
-
-		}
-		break;
-	case P2P_PS_SCAN:
-	case P2P_PS_SCAN_DONE:
-	case P2P_PS_ALLSTASLEEP:
-		if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {
-			p2pinfo->p2p_ps_state = p2p_ps_state;
-			rtlpriv->cfg->ops->set_hw_reg(hw,
-				 HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
-				 &p2p_ps_state);
-		}
-		break;
-	default:
-		break;
-	}
-	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,
-		 "ctwindow %x oppps %x\n",
-		 p2pinfo->ctwindow , p2pinfo->opp_ps);
-	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,
-		 "count %x duration %x index %x interval %x start time %x noa num %x\n",
-		 p2pinfo->noa_count_type[0],
-		 p2pinfo->noa_duration[0],
-		 p2pinfo->noa_index,
-		 p2pinfo->noa_interval[0],
-		 p2pinfo->noa_start_time[0],
-		 p2pinfo->noa_num);
-	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "end\n");
+	rtw_enter_lps_core(rtwdev);
 }
 
-void rtl_p2p_info(struct ieee80211_hw *hw, void *data, unsigned int len)
+void rtw_leave_lps(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif)
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct ieee80211_hdr *hdr = data;
+	struct rtw_lps_conf *conf = &rtwdev->lps_conf;
 
-	if (!mac->p2p)
-		return;
-	if (mac->link_state != MAC80211_LINKED)
-		return;
-	/* min. beacon length + FCS_LEN */
-	if (len <= 40 + FCS_LEN)
+	if (WARN_ON(!rtwvif))
 		return;
 
-	/* and only beacons from the associated BSSID, please */
-	if (!ether_addr_equal_64bits(hdr->addr3, rtlpriv->mac80211.bssid))
+	if (!rtwvif->in_lps)
 		return;
 
-	/* check if this really is a beacon */
-	if (!(ieee80211_is_beacon(hdr->frame_control) ||
-	      ieee80211_is_probe_resp(hdr->frame_control) ||
-	      ieee80211_is_action(hdr->frame_control)))
-		return;
+	conf->mode = RTW_MODE_ACTIVE;
+	conf->rtwvif = rtwvif;
+	rtwvif->in_lps = false;
 
-	if (ieee80211_is_action(hdr->frame_control))
-		rtl_p2p_action_ie(hw , data , len - FCS_LEN);
-	else
-		rtl_p2p_noa_ie(hw , data , len - FCS_LEN);
+	rtw_leave_lps_core(rtwdev);
 }
-EXPORT_SYMBOL_GPL(rtl_p2p_info);
diff -upr /home/finger/rtlwifi_new1/ps.h drivers/net/wireless/realtek/rtw88/ps.h
--- /home/finger/rtlwifi_new1/ps.h	2019-06-14 10:13:19.934404745 -0500
+++ drivers/net/wireless/realtek/rtw88/ps.h	2019-05-29 10:27:03.759295168 -0500
@@ -1,50 +1,20 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef __REALTEK_RTL_PCI_PS_H__
-#define __REALTEK_RTL_PCI_PS_H__
-
-#define MAX_SW_LPS_SLEEP_INTV	5
-
-bool rtl_ps_enable_nic(struct ieee80211_hw *hw);
-bool rtl_ps_disable_nic(struct ieee80211_hw *hw);
-void rtl_ips_nic_off(struct ieee80211_hw *hw);
-void rtl_ips_nic_on(struct ieee80211_hw *hw);
-void rtl_ips_nic_off_wq_callback(void *data);
-void rtl_lps_enter(struct ieee80211_hw *hw);
-void rtl_lps_leave(struct ieee80211_hw *hw);
-
-void rtl_lps_set_psmode(struct ieee80211_hw *hw, u8 rt_psmode);
-
-void rtl_swlps_beacon(struct ieee80211_hw *hw, void *data, unsigned int len);
-void rtl_swlps_wq_callback(void *data);
-void rtl_swlps_rfon_wq_callback(void *data);
-void rtl_swlps_rf_awake(struct ieee80211_hw *hw);
-void rtl_swlps_rf_sleep(struct ieee80211_hw *hw);
-void rtl_p2p_ps_cmd(struct ieee80211_hw *hw , u8 p2p_ps_state);
-void rtl_p2p_info(struct ieee80211_hw *hw, void *data, unsigned int len);
-void rtl_lps_change_work_callback(struct work_struct *work);
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright(c) 2018-2019  Realtek Corporation
+ */
+
+#ifndef __RTW_PS_H_
+#define __RTW_PS_H_
+
+#define RTW_LPS_THRESHOLD	2
+
+int rtw_enter_ips(struct rtw_dev *rtwdev);
+int rtw_leave_ips(struct rtw_dev *rtwdev);
+
+void rtw_lps_work(struct work_struct *work);
+void rtw_enter_lps_irqsafe(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif);
+void rtw_leave_lps_irqsafe(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif);
+void rtw_enter_lps(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif);
+void rtw_leave_lps(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif);
+bool rtw_in_lps(struct rtw_dev *rtwdev);
 
 #endif
Only in drivers/net/wireless/realtek/rtw88/: ps.o
Only in drivers/net/wireless/realtek/rtw88/: .ps.o.cmd
Only in /home/finger/rtlwifi_new1/: pwrseqcmd.h
Only in /home/finger/rtlwifi_new1/: rc.c
Only in /home/finger/rtlwifi_new1/: rc.h
Only in /home/finger/rtlwifi_new1/: README.md
diff -upr /home/finger/rtlwifi_new1/regd.c drivers/net/wireless/realtek/rtw88/regd.c
--- /home/finger/rtlwifi_new1/regd.c	2019-06-14 10:13:19.934404745 -0500
+++ drivers/net/wireless/realtek/rtw88/regd.c	2019-05-29 10:30:20.888271546 -0500
@@ -1,540 +1,398 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/* Copyright(c) 2018-2019  Realtek Corporation
+ */
 
-#include "wifi.h"
+#include "main.h"
 #include "regd.h"
+#include "debug.h"
+#include "phy.h"
 
-static struct country_code_to_enum_rd allCountries[] = {
-	{COUNTRY_CODE_FCC, "US"},
-	{COUNTRY_CODE_IC, "US"},
-	{COUNTRY_CODE_ETSI, "EC"},
-	{COUNTRY_CODE_SPAIN, "EC"},
-	{COUNTRY_CODE_FRANCE, "EC"},
-	{COUNTRY_CODE_MKK, "JP"},
-	{COUNTRY_CODE_MKK1, "JP"},
-	{COUNTRY_CODE_ISRAEL, "EC"},
-	{COUNTRY_CODE_TELEC, "JP"},
-	{COUNTRY_CODE_MIC, "JP"},
-	{COUNTRY_CODE_GLOBAL_DOMAIN, "JP"},
-	{COUNTRY_CODE_WORLD_WIDE_13, "EC"},
-	{COUNTRY_CODE_TELEC_NETGEAR, "EC"},
-	{COUNTRY_CODE_WORLD_WIDE_13_5G_ALL, "US"},
-};
-
-/*
- *Only these channels all allow active
- *scan on all world regulatory domains
- */
-#define RTL819x_2GHZ_CH01_11	\
-	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
+#define COUNTRY_CHPLAN_ENT(_alpha2, _chplan, _txpwr_regd) \
+	{.alpha2 = (_alpha2), \
+	 .chplan = (_chplan), \
+	 .txpwr_regd = (_txpwr_regd) \
+	}
 
-/*
- *We enable active scan on these a case
- *by case basis by regulatory domain
+/* If country code is not correctly defined in efuse,
+ * use worldwide country code and txpwr regd.
  */
-#define RTL819x_2GHZ_CH12_13	\
-	REG_RULE(2467-10, 2472+10, 40, 0, 20,\
-	NL80211_RRF_PASSIVE_SCAN)
-
-#define RTL819x_2GHZ_CH14	\
-	REG_RULE(2484-10, 2484+10, 40, 0, 20, \
-	NL80211_RRF_PASSIVE_SCAN | \
-	NL80211_RRF_NO_OFDM)
-
-
-/* 5G chan 36 - chan 64*/
-#define RTL819x_5GHZ_5150_5350	\
-	REG_RULE(5150-10, 5350+10, 80, 0, 30, 0)
-/* 5G chan 100 - chan 165*/
-#define RTL819x_5GHZ_5470_5850	\
-	REG_RULE(5470-10, 5850+10, 80, 0, 30, 0)
-/* 5G chan 149 - chan 165*/
-#define RTL819x_5GHZ_5725_5850	\
-	REG_RULE(5725-10, 5850+10, 80, 0, 30, 0)
-
-#define RTL819x_5GHZ_ALL	\
-	(RTL819x_5GHZ_5150_5350, RTL819x_5GHZ_5470_5850)
-
-static const struct ieee80211_regdomain rtl_regdom_11 = {
-	.n_reg_rules = 1,
-	.alpha2 = "99",
-	.reg_rules = {
-		      RTL819x_2GHZ_CH01_11,
-		      }
-};
-
-static const struct ieee80211_regdomain rtl_regdom_12_13 = {
-	.n_reg_rules = 2,
-	.alpha2 = "99",
-	.reg_rules = {
-		      RTL819x_2GHZ_CH01_11,
-			  RTL819x_2GHZ_CH12_13,
-		      }
-};
-
-static const struct ieee80211_regdomain rtl_regdom_no_midband = {
-	.n_reg_rules = 3,
-	.alpha2 = "99",
-	.reg_rules = {
-		      RTL819x_2GHZ_CH01_11,
-			  RTL819x_5GHZ_5150_5350,
-			  RTL819x_5GHZ_5725_5850,
-		      }
-};
-
-static const struct ieee80211_regdomain rtl_regdom_60_64 = {
-	.n_reg_rules = 3,
-	.alpha2 = "99",
-	.reg_rules = {
-		      RTL819x_2GHZ_CH01_11,
-			  RTL819x_2GHZ_CH12_13,
-			  RTL819x_5GHZ_5725_5850,
-		      }
-};
-
-static const struct ieee80211_regdomain rtl_regdom_14_60_64 = {
-	.n_reg_rules = 4,
-	.alpha2 = "99",
-	.reg_rules = {
-		      RTL819x_2GHZ_CH01_11,
-			  RTL819x_2GHZ_CH12_13,
-			  RTL819x_2GHZ_CH14,
-			  RTL819x_5GHZ_5725_5850,
-		      }
-};
-
-static const struct ieee80211_regdomain rtl_regdom_12_13_5g_all = {
-	.n_reg_rules = 4,
-	.alpha2 = "99",
-	.reg_rules = {
-			RTL819x_2GHZ_CH01_11,
-			RTL819x_2GHZ_CH12_13,
-			RTL819x_5GHZ_5150_5350,
-			RTL819x_5GHZ_5470_5850,
-		}
-};
+static const struct rtw_regulatory rtw_defined_chplan =
+	COUNTRY_CHPLAN_ENT("00", RTW_CHPLAN_REALTEK_DEFINE, RTW_REGD_WW);
 
-static const struct ieee80211_regdomain rtl_regdom_14 = {
-	.n_reg_rules = 3,
-	.alpha2 = "99",
-	.reg_rules = {
-		      RTL819x_2GHZ_CH01_11,
-			  RTL819x_2GHZ_CH12_13,
-			  RTL819x_2GHZ_CH14,
-		      }
+static const struct rtw_regulatory all_chplan_map[] = {
+	COUNTRY_CHPLAN_ENT("AD", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("AE", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("AF", RTW_CHPLAN_ETSI1_ETSI4, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("AG", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("AI", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("AL", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("AM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("AN", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("AO", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("AQ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("AR", RTW_CHPLAN_FCC2_FCC7, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("AS", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("AT", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("AU", RTW_CHPLAN_WORLD_ACMA1, RTW_REGD_ACMA),
+	COUNTRY_CHPLAN_ENT("AW", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("AZ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BA", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BB", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("BD", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BF", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BG", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BH", RTW_CHPLAN_WORLD_ETSI7, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BI", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BJ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BM", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("BN", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BO", RTW_CHPLAN_WORLD_FCC7, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("BR", RTW_CHPLAN_FCC2_FCC1, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("BS", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("BT", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BV", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BW", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BY", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("BZ", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("CA", RTW_CHPLAN_IC1_IC2, RTW_REGD_IC),
+	COUNTRY_CHPLAN_ENT("CC", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CD", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CF", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CG", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CH", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CI", RTW_CHPLAN_ETSI1_ETSI4, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CK", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CL", RTW_CHPLAN_WORLD_CHILE1, RTW_REGD_CHILE),
+	COUNTRY_CHPLAN_ENT("CM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CN", RTW_CHPLAN_WORLD_ETSI7, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CO", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("CR", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("CV", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CX", RTW_CHPLAN_WORLD_ACMA1, RTW_REGD_ACMA),
+	COUNTRY_CHPLAN_ENT("CY", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("CZ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("DE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("DJ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("DK", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("DM", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("DO", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("DZ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("EC", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("EE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("EG", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("EH", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("ER", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("ES", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("ET", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("FI", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("FJ", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("FK", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("FM", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("FO", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("FR", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GA", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GB", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GD", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("GE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GF", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GG", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GH", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GI", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GL", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GN", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GP", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GQ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GR", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GS", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GT", RTW_CHPLAN_FCC2_FCC7, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("GU", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("GW", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("GY", RTW_CHPLAN_FCC1_NCC3, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("HK", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("HM", RTW_CHPLAN_WORLD_ACMA1, RTW_REGD_ACMA),
+	COUNTRY_CHPLAN_ENT("HN", RTW_CHPLAN_WORLD_FCC5, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("HR", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("HT", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("HU", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("ID", RTW_CHPLAN_ETSI1_ETSI12, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("IE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("IL", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("IM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("IN", RTW_CHPLAN_WORLD_ETSI7, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("IO", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("IQ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("IR", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("IS", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("IT", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("JE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("JM", RTW_CHPLAN_WORLD_FCC5, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("JO", RTW_CHPLAN_WORLD_ETSI8, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("JP", RTW_CHPLAN_MKK1_MKK1, RTW_REGD_MKK),
+	COUNTRY_CHPLAN_ENT("KE", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("KG", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("KH", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("KI", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("KM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("KN", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("KR", RTW_CHPLAN_KCC1_KCC3, RTW_REGD_KCC),
+	COUNTRY_CHPLAN_ENT("KW", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("KY", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("KZ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LA", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LB", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LC", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("LI", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LK", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LR", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LS", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LT", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LU", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LV", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("LY", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MA", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MC", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MD", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("ME", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MF", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("MG", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MH", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("MK", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("ML", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MN", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MO", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MP", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("MQ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MR", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MS", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MT", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MU", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MV", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MW", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MX", RTW_CHPLAN_FCC2_FCC7, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("MY", RTW_CHPLAN_WORLD_ETSI15, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("MZ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("NA", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("NC", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("NE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("NF", RTW_CHPLAN_WORLD_ACMA1, RTW_REGD_ACMA),
+	COUNTRY_CHPLAN_ENT("NG", RTW_CHPLAN_WORLD_ETSI20, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("NI", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("NL", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("NO", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("NP", RTW_CHPLAN_WORLD_ETSI7, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("NR", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("NU", RTW_CHPLAN_WORLD_ACMA1, RTW_REGD_ACMA),
+	COUNTRY_CHPLAN_ENT("NZ", RTW_CHPLAN_WORLD_ACMA1, RTW_REGD_ACMA),
+	COUNTRY_CHPLAN_ENT("OM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("PA", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("PE", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("PF", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("PG", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("PH", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("PK", RTW_CHPLAN_WORLD_ETSI10, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("PL", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("PM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("PR", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("PT", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("PW", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("PY", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("QA", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("RE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("RO", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("RS", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("RU", RTW_CHPLAN_WORLD_ETSI14, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("RW", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SA", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SB", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SC", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("SE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SG", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SH", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SI", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SJ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SK", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SL", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SN", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SO", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("SR", RTW_CHPLAN_FCC2_FCC17, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("ST", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("SV", RTW_CHPLAN_WORLD_FCC3, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("SX", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("SZ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TC", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TD", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TF", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TG", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TH", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TJ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TK", RTW_CHPLAN_WORLD_ACMA1, RTW_REGD_ACMA),
+	COUNTRY_CHPLAN_ENT("TM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TN", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TO", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TR", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TT", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("TV", RTW_CHPLAN_ETSI1_NULL, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("TW", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("TZ", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("UA", RTW_CHPLAN_WORLD_ETSI3, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("UG", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("US", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("UY", RTW_CHPLAN_WORLD_FCC3, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("UZ", RTW_CHPLAN_WORLD_ETSI6, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("VA", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("VC", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("VE", RTW_CHPLAN_WORLD_FCC3, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("VG", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("VI", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("VN", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("VU", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("WF", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("WS", RTW_CHPLAN_FCC2_FCC11, RTW_REGD_FCC),
+	COUNTRY_CHPLAN_ENT("YE", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("YT", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("ZA", RTW_CHPLAN_WORLD_ETSI2, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("ZM", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
+	COUNTRY_CHPLAN_ENT("ZW", RTW_CHPLAN_WORLD_ETSI1, RTW_REGD_ETSI),
 };
 
-static bool _rtl_is_radar_freq(u16 center_freq)
-{
-	return center_freq >= 5260 && center_freq <= 5700;
-}
-
-static void _rtl_reg_apply_beaconing_flags(struct wiphy *wiphy,
+static void rtw_regd_apply_beaconing_flags(struct wiphy *wiphy,
 					   enum nl80211_reg_initiator initiator)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
 	enum nl80211_band band;
-#else
-	enum ieee80211_band band;
-#endif
 	struct ieee80211_supported_band *sband;
 	const struct ieee80211_reg_rule *reg_rule;
 	struct ieee80211_channel *ch;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
-	u32 bandwidth = 0;
-	int r;
-#endif
 	unsigned int i;
 
 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
-
 		if (!wiphy->bands[band])
 			continue;
 
 		sband = wiphy->bands[band];
-
 		for (i = 0; i < sband->n_channels; i++) {
 			ch = &sband->channels[i];
-			if (_rtl_is_radar_freq(ch->center_freq) ||
-			    (ch->flags & IEEE80211_CHAN_RADAR))
+
+			reg_rule = freq_reg_info(wiphy,
+						 MHZ_TO_KHZ(ch->center_freq));
+			if (IS_ERR(reg_rule))
 				continue;
-			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
-				reg_rule = freq_reg_info(wiphy,
-							 ch->center_freq);
-				if (IS_ERR(reg_rule))
-					continue;
-#else
-				r = freq_reg_info(wiphy, ch->center_freq,
-						  bandwidth, &reg_rule);
-				if (r)
-					continue;
-#endif
-				/*
-				 *If 11d had a rule for this channel ensure
-				 *we enable adhoc/beaconing if it allows us to
-				 *use it. Note that we would have disabled it
-				 *by applying our static world regdomain by
-				 *default during init, prior to calling our
-				 *regulatory_hint().
-				 */
-
-				if (!(reg_rule->flags & NL80211_RRF_NO_IBSS))
-					ch->flags &= ~IEEE80211_CHAN_NO_IBSS;
-				if (!(reg_rule->flags &
-				      NL80211_RRF_PASSIVE_SCAN))
-					ch->flags &=
-					    ~IEEE80211_CHAN_PASSIVE_SCAN;
-			} else {
-				if (ch->beacon_found)
-					ch->flags &= ~(IEEE80211_CHAN_NO_IBSS |
-						   IEEE80211_CHAN_PASSIVE_SCAN);
-			}
+
+			ch->flags &= ~IEEE80211_CHAN_DISABLED;
+
+			if (!(reg_rule->flags & NL80211_RRF_NO_IR))
+				ch->flags &= ~IEEE80211_CHAN_NO_IR;
 		}
 	}
 }
 
-/* Allows active scan scan on Ch 12 and 13 */
-static void _rtl_reg_apply_active_scan_flags(struct wiphy *wiphy,
-					     enum nl80211_reg_initiator
-					     initiator)
+static void rtw_regd_apply_hw_cap_flags(struct wiphy *wiphy)
 {
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_channel *ch;
-	const struct ieee80211_reg_rule *reg_rule;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
-	u32 bandwidth = 0;
-	int r;
-#endif
-
-	if (!wiphy->bands[NL80211_BAND_2GHZ])
-		return;
-	sband = wiphy->bands[NL80211_BAND_2GHZ];
+	struct rtw_dev *rtwdev = hw->priv;
+	struct rtw_efuse *efuse = &rtwdev->efuse;
+	int i;
 
-	/*
-	 *If no country IE has been received always enable active scan
-	 *on these channels. This is only done for specific regulatory SKUs
-	 */
-	if (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-		ch = &sband->channels[11];	/* CH 12 */
-		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
-		ch = &sband->channels[12];	/* CH 13 */
-		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+	if (efuse->hw_cap.bw & BIT(RTW_CHANNEL_WIDTH_80))
 		return;
-	}
 
-	/*
-	 *If a country IE has been recieved check its rule for this
-	 *channel first before enabling active scan. The passive scan
-	 *would have been enforced by the initial processing of our
-	 *custom regulatory domain.
-	 */
-
-	ch = &sband->channels[11];	/* CH 12 */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
-	reg_rule = freq_reg_info(wiphy, ch->center_freq);
-	if (!IS_ERR(reg_rule)) {
-#else
-	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
-	if (!r) {
-#endif
-		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
-			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
-	}
+	sband = wiphy->bands[NL80211_BAND_2GHZ];
+	if (!sband)
+		goto out_5g;
 
-	ch = &sband->channels[12];	/* CH 13 */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
-	reg_rule = freq_reg_info(wiphy, ch->center_freq);
-	if (!IS_ERR(reg_rule)) {
-#else
-	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
-	if (!r) {
-#endif
-		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
-			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+	for (i = 0; i < sband->n_channels; i++) {
+		ch = &sband->channels[i];
+		ch->flags |= IEEE80211_CHAN_NO_80MHZ;
 	}
-}
-
-/*
- *Always apply Radar/DFS rules on
- *freq range 5260 MHz - 5700 MHz
- */
-static void _rtl_reg_apply_radar_flags(struct wiphy *wiphy)
-{
-	struct ieee80211_supported_band *sband;
-	struct ieee80211_channel *ch;
-	unsigned int i;
-
-	if (!wiphy->bands[NL80211_BAND_5GHZ])
-		return;
 
+out_5g:
 	sband = wiphy->bands[NL80211_BAND_5GHZ];
+	if (!sband)
+		return;
 
 	for (i = 0; i < sband->n_channels; i++) {
 		ch = &sband->channels[i];
-		if (!_rtl_is_radar_freq(ch->center_freq))
-			continue;
-
-		/*
-		 *We always enable radar detection/DFS on this
-		 *frequency range. Additionally we also apply on
-		 *this frequency range:
-		 *- If STA mode does not yet have DFS supports disable
-		 * active scanning
-		 *- If adhoc mode does not support DFS yet then disable
-		 * adhoc in the frequency.
-		 *- If AP mode does not yet support radar detection/DFS
-		 *do not allow AP mode
-		 */
-		if (!(ch->flags & IEEE80211_CHAN_DISABLED))
-			ch->flags |= IEEE80211_CHAN_RADAR |
-			    IEEE80211_CHAN_NO_IBSS |
-			    IEEE80211_CHAN_PASSIVE_SCAN;
+		ch->flags |= IEEE80211_CHAN_NO_80MHZ;
 	}
 }
 
-static void _rtl_reg_apply_world_flags(struct wiphy *wiphy,
-				       enum nl80211_reg_initiator initiator,
-				       struct rtl_regulatory *reg)
+static void rtw_regd_apply_world_flags(struct wiphy *wiphy,
+				       enum nl80211_reg_initiator initiator)
 {
-	_rtl_reg_apply_beaconing_flags(wiphy, initiator);
-	_rtl_reg_apply_active_scan_flags(wiphy, initiator);
-	return;
+	rtw_regd_apply_beaconing_flags(wiphy, initiator);
 }
 
-static void _rtl_dump_channel_map(struct wiphy *wiphy)
+static struct rtw_regulatory rtw_regd_find_reg_by_name(char *alpha2)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
-	enum nl80211_band band;
-#else
-	enum ieee80211_band band;
-#endif
-	struct ieee80211_supported_band *sband;
-	struct ieee80211_channel *ch;
 	unsigned int i;
 
-	for (band = 0; band < NUM_NL80211_BANDS; band++) {
-		if (!wiphy->bands[band])
-			continue;
-		sband = wiphy->bands[band];
-		for (i = 0; i < sband->n_channels; i++)
-			ch = &sband->channels[i];
+	for (i = 0; i < ARRAY_SIZE(all_chplan_map); i++) {
+		if (!memcmp(all_chplan_map[i].alpha2, alpha2, 2))
+			return all_chplan_map[i];
 	}
+
+	return rtw_defined_chplan;
 }
 
-static int _rtl_reg_notifier_apply(struct wiphy *wiphy,
-				   struct regulatory_request *request,
-				   struct rtl_regulatory *reg)
+static int rtw_regd_notifier_apply(struct rtw_dev *rtwdev,
+				   struct wiphy *wiphy,
+				   struct regulatory_request *request)
 {
-	/* We always apply this */
-	_rtl_reg_apply_radar_flags(wiphy);
-
-	switch (request->initiator) {
-	case NL80211_REGDOM_SET_BY_DRIVER:
-	case NL80211_REGDOM_SET_BY_CORE:
-	case NL80211_REGDOM_SET_BY_USER:
-		break;
-	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
-		_rtl_reg_apply_world_flags(wiphy, request->initiator, reg);
-		break;
-	}
-
-	_rtl_dump_channel_map(wiphy);
+	if (request->initiator == NL80211_REGDOM_SET_BY_USER)
+		return 0;
+	rtwdev->regd = rtw_regd_find_reg_by_name(request->alpha2);
+	rtw_regd_apply_world_flags(wiphy, request->initiator);
 
 	return 0;
 }
 
-static const struct ieee80211_regdomain *_rtl_regdomain_select(
-						struct rtl_regulatory *reg)
+static int
+rtw_regd_init_wiphy(struct rtw_regulatory *reg, struct wiphy *wiphy,
+		    void (*reg_notifier)(struct wiphy *wiphy,
+					 struct regulatory_request *request))
 {
-	switch (reg->country_code) {
-	case COUNTRY_CODE_FCC:
-		return &rtl_regdom_no_midband;
-	case COUNTRY_CODE_IC:
-		return &rtl_regdom_11;
-	case COUNTRY_CODE_TELEC_NETGEAR:
-		return &rtl_regdom_60_64;
-	case COUNTRY_CODE_ETSI:
-	case COUNTRY_CODE_SPAIN:
-	case COUNTRY_CODE_FRANCE:
-	case COUNTRY_CODE_ISRAEL:
-		return &rtl_regdom_12_13;
-	case COUNTRY_CODE_MKK:
-	case COUNTRY_CODE_MKK1:
-	case COUNTRY_CODE_TELEC:
-	case COUNTRY_CODE_MIC:
-		return &rtl_regdom_14_60_64;
-	case COUNTRY_CODE_GLOBAL_DOMAIN:
-		return &rtl_regdom_14;
-	case COUNTRY_CODE_WORLD_WIDE_13:
-	case COUNTRY_CODE_WORLD_WIDE_13_5G_ALL:
-		return &rtl_regdom_12_13_5g_all;
-	default:
-		return &rtl_regdom_no_midband;
-	}
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
-static int _rtl_regd_init_wiphy(struct rtl_regulatory *reg,
-				struct wiphy *wiphy,
-				void (*reg_notifier)(struct wiphy *wiphy,
-						     struct regulatory_request *
-						     request))
-#else
-static int _rtl_regd_init_wiphy(struct rtl_regulatory *reg,
-				struct wiphy *wiphy,
-				int (*reg_notifier)(struct wiphy *wiphy,
-						    struct regulatory_request *
-						    request))
-#endif
-{
-	const struct ieee80211_regdomain *regd;
-
 	wiphy->reg_notifier = reg_notifier;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
-	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+	wiphy->regulatory_flags &= ~REGULATORY_CUSTOM_REG;
 	wiphy->regulatory_flags &= ~REGULATORY_STRICT_REG;
 	wiphy->regulatory_flags &= ~REGULATORY_DISABLE_BEACON_HINTS;
-#else
-	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
-	wiphy->flags &= ~WIPHY_FLAG_STRICT_REGULATORY;
-	wiphy->flags &= ~WIPHY_FLAG_DISABLE_BEACON_HINTS;
-#endif
-	regd = _rtl_regdomain_select(reg);
-	wiphy_apply_custom_regulatory(wiphy, regd);
-	_rtl_reg_apply_radar_flags(wiphy);
-	_rtl_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
-	return 0;
-}
-
-static struct country_code_to_enum_rd *_rtl_regd_find_country(u16 countrycode)
-{
-	int i;
 
-	for (i = 0; i < ARRAY_SIZE(allCountries); i++) {
-		if (allCountries[i].countrycode == countrycode)
-			return &allCountries[i];
-	}
-	return NULL;
-}
+	rtw_regd_apply_hw_cap_flags(wiphy);
 
-static u8 channel_plan_to_country_code(u8 channelplan)
-{
-	switch (channelplan) {
-	case 0x20:
-	case 0x21:
-		return COUNTRY_CODE_WORLD_WIDE_13;
-	case 0x22:
-		return COUNTRY_CODE_IC;
-	case 0x25:
-		return COUNTRY_CODE_ETSI;
-	case 0x32:
-		return COUNTRY_CODE_TELEC_NETGEAR;
-	case 0x41:
-		return COUNTRY_CODE_GLOBAL_DOMAIN;
-	case 0x7f:
-		return COUNTRY_CODE_WORLD_WIDE_13_5G_ALL;
-	default:
-		return COUNTRY_CODE_MAX; /*Error*/
-	}
+	return 0;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
-int rtl_regd_init(struct ieee80211_hw *hw,
+int rtw_regd_init(struct rtw_dev *rtwdev,
 		  void (*reg_notifier)(struct wiphy *wiphy,
 				       struct regulatory_request *request))
-#else
-int rtl_regd_init(struct ieee80211_hw *hw,
-		  int (*reg_notifier)(struct wiphy *wiphy,
-				      struct regulatory_request *request))
-#endif
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct wiphy *wiphy = hw->wiphy;
-	struct country_code_to_enum_rd *country = NULL;
+	struct wiphy *wiphy = rtwdev->hw->wiphy;
 
-	if (wiphy == NULL || &rtlpriv->regd == NULL)
+	if (!wiphy)
 		return -EINVAL;
 
-	/* init country_code from efuse channel plan */
-	rtlpriv->regd.country_code =
-		channel_plan_to_country_code(rtlpriv->efuse.channel_plan);
-
-	RT_TRACE(rtlpriv, COMP_REGD, DBG_DMESG,
-		 "rtl: EEPROM regdomain: 0x%0x country code: %d\n",
-		 rtlpriv->efuse.channel_plan, rtlpriv->regd.country_code);
-
-	if (rtlpriv->regd.country_code >= COUNTRY_CODE_MAX) {
-		RT_TRACE(rtlpriv, COMP_REGD, DBG_DMESG,
-			 "rtl: EEPROM indicates invalid country code, world wide 13 should be used\n");
-
-		rtlpriv->regd.country_code = COUNTRY_CODE_WORLD_WIDE_13;
-	}
-
-	country = _rtl_regd_find_country(rtlpriv->regd.country_code);
-
-	if (country) {
-		rtlpriv->regd.alpha2[0] = country->iso_name[0];
-		rtlpriv->regd.alpha2[1] = country->iso_name[1];
-	} else {
-		rtlpriv->regd.alpha2[0] = '0';
-		rtlpriv->regd.alpha2[1] = '0';
-	}
-
-	RT_TRACE(rtlpriv, COMP_REGD, DBG_TRACE,
-		 "rtl: Country alpha2 being used: %c%c\n",
-		  rtlpriv->regd.alpha2[0], rtlpriv->regd.alpha2[1]);
-
-	_rtl_regd_init_wiphy(&rtlpriv->regd, wiphy, reg_notifier);
+	rtwdev->regd = rtw_regd_find_reg_by_name(rtwdev->efuse.country_code);
+	rtw_regd_init_wiphy(&rtwdev->regd, wiphy, reg_notifier);
 
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
-void rtl_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
-{
-	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	RT_TRACE(rtlpriv, COMP_REGD, DBG_LOUD, "\n");
-
-	_rtl_reg_notifier_apply(wiphy, request, &rtlpriv->regd);
-}
-#else
-int rtl_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
+void rtw_regd_notifier(struct wiphy *wiphy, struct regulatory_request *request)
 {
 	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtw_dev *rtwdev = hw->priv;
+	struct rtw_hal *hal = &rtwdev->hal;
 
-	RT_TRACE(rtlpriv, COMP_REGD, DBG_LOUD, "\n");
+	rtw_regd_notifier_apply(rtwdev, wiphy, request);
+	rtw_dbg(rtwdev, RTW_DBG_REGD,
+		"get alpha2 %c%c from initiator %d, mapping to chplan 0x%x, txregd %d\n",
+		request->alpha2[0], request->alpha2[1], request->initiator,
+		rtwdev->regd.chplan, rtwdev->regd.txpwr_regd);
 
-	return _rtl_reg_notifier_apply(wiphy, request, &rtlpriv->regd);
+	rtw_phy_set_tx_power_level(rtwdev, hal->current_channel);
 }
-#endif
diff -upr /home/finger/rtlwifi_new1/regd.h drivers/net/wireless/realtek/rtw88/regd.h
--- /home/finger/rtlwifi_new1/regd.h	2019-06-14 10:13:19.934404745 -0500
+++ drivers/net/wireless/realtek/rtw88/regd.h	2019-05-29 10:30:20.888271546 -0500
@@ -1,43 +1,50 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright(c) 2018-2019  Realtek Corporation
+ */
 
-#ifndef __RTL_REGD_H__
-#define __RTL_REGD_H__
+#ifndef __RTW_REGD_H_
+#define __RTW_REGD_H_
 
-/* for kernel 3.14 , both value are changed to IEEE80211_CHAN_NO_IR*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
 #define IEEE80211_CHAN_NO_IBSS IEEE80211_CHAN_NO_IR
 #define IEEE80211_CHAN_PASSIVE_SCAN IEEE80211_CHAN_NO_IR
-#endif
+enum rtw_chplan_id {
+	RTW_CHPLAN_ETSI1_NULL = 0x21,
+	RTW_CHPLAN_WORLD_ETSI1 = 0x26,
+	RTW_CHPLAN_MKK1_MKK1 = 0x27,
+	RTW_CHPLAN_IC1_IC2 = 0x2B,
+	RTW_CHPLAN_WORLD_CHILE1 = 0x2D,
+	RTW_CHPLAN_WORLD_FCC3 = 0x30,
+	RTW_CHPLAN_WORLD_FCC5 = 0x32,
+	RTW_CHPLAN_FCC1_FCC7 = 0x34,
+	RTW_CHPLAN_WORLD_ETSI2 = 0x35,
+	RTW_CHPLAN_WORLD_ETSI3 = 0x36,
+	RTW_CHPLAN_ETSI1_ETSI12 = 0x3D,
+	RTW_CHPLAN_KCC1_KCC2 = 0x3E,
+	RTW_CHPLAN_ETSI1_ETSI4 = 0x42,
+	RTW_CHPLAN_FCC1_NCC3 = 0x44,
+	RTW_CHPLAN_WORLD_ACMA1 = 0x45,
+	RTW_CHPLAN_WORLD_ETSI6 = 0x47,
+	RTW_CHPLAN_WORLD_ETSI7 = 0x48,
+	RTW_CHPLAN_WORLD_ETSI8 = 0x49,
+	RTW_CHPLAN_KCC1_KCC3 = 0x4B,
+	RTW_CHPLAN_WORLD_ETSI10 = 0x51,
+	RTW_CHPLAN_WORLD_ETSI14 = 0x59,
+	RTW_CHPLAN_FCC2_FCC7 = 0x61,
+	RTW_CHPLAN_FCC2_FCC1 = 0x62,
+	RTW_CHPLAN_WORLD_ETSI15 = 0x63,
+	RTW_CHPLAN_WORLD_FCC7 = 0x73,
+	RTW_CHPLAN_FCC2_FCC17 = 0x74,
+	RTW_CHPLAN_WORLD_ETSI20 = 0x75,
+	RTW_CHPLAN_FCC2_FCC11 = 0x76,
+	RTW_CHPLAN_REALTEK_DEFINE = 0x7f,
+};
 
 struct country_code_to_enum_rd {
 	u16 countrycode;
 	const char *iso_name;
 };
 
-enum country_code_type_t {
+enum country_code_type {
 	COUNTRY_CODE_FCC = 0,
 	COUNTRY_CODE_IC = 1,
 	COUNTRY_CODE_ETSI = 2,
@@ -53,20 +60,12 @@ enum country_code_type_t {
 	COUNTRY_CODE_TELEC_NETGEAR = 12,
 	COUNTRY_CODE_WORLD_WIDE_13_5G_ALL = 13,
 
-	/*add new channel plan above this line */
+	/* new channel plan above this */
 	COUNTRY_CODE_MAX
 };
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
-int rtl_regd_init(struct ieee80211_hw *hw,
-		  void (*reg_notifier) (struct wiphy *wiphy,
-		  struct regulatory_request *request));
-void rtl_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
-#else
-int rtl_regd_init(struct ieee80211_hw *hw,
-		  int (*reg_notifier)(struct wiphy *wiphy,
-				      struct regulatory_request *request));
-int rtl_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
-#endif
-
+int rtw_regd_init(struct rtw_dev *rtwdev,
+		  void (*reg_notifier)(struct wiphy *wiphy,
+				       struct regulatory_request *request));
+void rtw_regd_notifier(struct wiphy *wiphy, struct regulatory_request *request);
 #endif
Only in drivers/net/wireless/realtek/rtw88/: regd.o
Only in drivers/net/wireless/realtek/rtw88/: .regd.o.cmd
Only in drivers/net/wireless/realtek/rtw88/: reg.h
Only in /home/finger/rtlwifi_new1/: rtl8188ee
Only in /home/finger/rtlwifi_new1/: rtl8192c
Only in /home/finger/rtlwifi_new1/: rtl8192ce
Only in /home/finger/rtlwifi_new1/: rtl8192cu
Only in /home/finger/rtlwifi_new1/: rtl8192de
Only in /home/finger/rtlwifi_new1/: rtl8192ee
Only in /home/finger/rtlwifi_new1/: rtl8192ee_revised.tar.bz2
Only in /home/finger/rtlwifi_new1/: rtl8192se
Only in /home/finger/rtlwifi_new1/: rtl8723ae
Only in /home/finger/rtlwifi_new1/: rtl8723be
Only in /home/finger/rtlwifi_new1/: rtl8723com
Only in /home/finger/rtlwifi_new1/: rtl8723de
Only in /home/finger/rtlwifi_new1/: rtl8723du
Only in /home/finger/rtlwifi_new1/: rtl8821ae
Only in /home/finger/rtlwifi_new1/: rtl8821CE_WiFi_linux_v5.2.5.1_24855.20171031_COEX20170310-1212.tar.gz
Only in /home/finger/rtlwifi_new1/: rtl8822be
Only in drivers/net/wireless/realtek/rtw88/: rtw8822b.c
Only in drivers/net/wireless/realtek/rtw88/: rtw8822b.h
Only in drivers/net/wireless/realtek/rtw88/: rtw8822b.o
Only in drivers/net/wireless/realtek/rtw88/: .rtw8822b.o.cmd
diff -upr /home/finger/rtlwifi_new1/.rtw8822b.o.d drivers/net/wireless/realtek/rtw88/.rtw8822b.o.d
--- /home/finger/rtlwifi_new1/.rtw8822b.o.d	2019-06-14 10:01:34.511257897 -0500
+++ drivers/net/wireless/realtek/rtw88/.rtw8822b.o.d	2019-06-14 20:51:05.026369945 -0500
@@ -1,7 +1,7 @@
-rtw8822b.o: /home/finger/rtlwifi_new1/rtw8822b.c include/linux/kconfig.h \
- include/generated/autoconf.h include/linux/compiler_types.h \
- include/linux/compiler_attributes.h include/linux/compiler-gcc.h \
- /home/finger/rtlwifi_new1/main.h include/generated/uapi/linux/version.h \
+rtw8822b.o: drivers/net/wireless/realtek/rtw88/rtw8822b.c \
+ include/linux/kconfig.h include/generated/autoconf.h \
+ include/linux/compiler_types.h include/linux/compiler_attributes.h \
+ include/linux/compiler-gcc.h drivers/net/wireless/realtek/rtw88/main.h \
  include/net/mac80211.h include/linux/bug.h arch/x86/include/asm/bug.h \
  include/linux/stringify.h include/asm-generic/bug.h \
  include/linux/compiler.h include/linux/compiler_types.h \
@@ -69,17 +69,11 @@ rtw8822b.o: /home/finger/rtlwifi_new1/rt
  arch/x86/include/uapi/asm/processor-flags.h \
  arch/x86/include/asm/math_emu.h arch/x86/include/asm/ptrace.h \
  arch/x86/include/asm/segment.h arch/x86/include/uapi/asm/ptrace.h \
- arch/x86/include/uapi/asm/ptrace-abi.h \
- arch/x86/include/asm/paravirt_types.h arch/x86/include/asm/desc_defs.h \
- arch/x86/include/asm/kmap_types.h include/asm-generic/kmap_types.h \
+ arch/x86/include/uapi/asm/ptrace-abi.h include/asm-generic/ptrace.h \
+ arch/x86/include/uapi/asm/sigcontext.h \
  arch/x86/include/asm/pgtable_types.h \
  arch/x86/include/asm/pgtable_64_types.h arch/x86/include/asm/sparsemem.h \
- include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/nospec-branch.h \
- include/linux/static_key.h arch/x86/include/asm/alternative-asm.h \
- arch/x86/include/asm/msr-index.h arch/x86/include/asm/spinlock_types.h \
- include/asm-generic/qspinlock_types.h \
- include/asm-generic/qrwlock_types.h include/asm-generic/ptrace.h \
- arch/x86/include/uapi/asm/sigcontext.h arch/x86/include/asm/msr.h \
+ include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/msr.h \
  arch/x86/include/asm/msr-index.h arch/x86/include/uapi/asm/errno.h \
  include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
  arch/x86/include/asm/cpumask.h include/linux/cpumask.h \
@@ -91,21 +85,25 @@ rtw8822b.o: /home/finger/rtlwifi_new1/rt
  include/asm-generic/atomic-instrumented.h \
  include/linux/tracepoint-defs.h include/linux/atomic.h \
  include/linux/atomic-fallback.h include/asm-generic/atomic-long.h \
- include/linux/errno.h include/uapi/linux/errno.h \
+ include/linux/static_key.h include/linux/errno.h \
+ include/uapi/linux/errno.h arch/x86/include/asm/desc_defs.h \
  arch/x86/include/asm/special_insns.h arch/x86/include/asm/fpu/types.h \
  arch/x86/include/asm/unwind_hints.h arch/x86/include/asm/orc_types.h \
  include/linux/personality.h include/uapi/linux/personality.h \
  include/linux/err.h include/linux/irqflags.h \
- arch/x86/include/asm/irqflags.h include/linux/bottom_half.h \
- arch/x86/include/generated/asm/mmiowb.h include/asm-generic/mmiowb.h \
- include/linux/spinlock_types.h include/linux/lockdep.h \
+ arch/x86/include/asm/irqflags.h arch/x86/include/asm/nospec-branch.h \
+ arch/x86/include/asm/alternative-asm.h arch/x86/include/asm/msr-index.h \
+ include/linux/bottom_half.h arch/x86/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h include/linux/spinlock_types.h \
+ arch/x86/include/asm/spinlock_types.h \
+ include/asm-generic/qspinlock_types.h \
+ include/asm-generic/qrwlock_types.h include/linux/lockdep.h \
  include/linux/rwlock_types.h arch/x86/include/asm/spinlock.h \
- arch/x86/include/asm/paravirt.h arch/x86/include/asm/frame.h \
- arch/x86/include/asm/qspinlock.h include/asm-generic/qspinlock.h \
- arch/x86/include/asm/qrwlock.h include/asm-generic/qrwlock.h \
- include/linux/rwlock.h include/linux/spinlock_api_smp.h \
- include/linux/rwlock_api_smp.h include/linux/time32.h \
- include/linux/timex.h include/uapi/linux/timex.h \
+ arch/x86/include/asm/paravirt.h arch/x86/include/asm/qspinlock.h \
+ include/asm-generic/qspinlock.h arch/x86/include/asm/qrwlock.h \
+ include/asm-generic/qrwlock.h include/linux/rwlock.h \
+ include/linux/spinlock_api_smp.h include/linux/rwlock_api_smp.h \
+ include/linux/time32.h include/linux/timex.h include/uapi/linux/timex.h \
  include/uapi/linux/param.h arch/x86/include/uapi/asm/param.h \
  include/asm-generic/param.h include/uapi/asm-generic/param.h \
  arch/x86/include/asm/timex.h arch/x86/include/asm/tsc.h \
@@ -124,24 +122,24 @@ rtw8822b.o: /home/finger/rtlwifi_new1/rt
  include/linux/auxvec.h include/uapi/linux/auxvec.h \
  arch/x86/include/uapi/asm/auxvec.h include/linux/rwsem.h \
  include/linux/osq_lock.h include/linux/completion.h \
- include/linux/uprobes.h include/linux/workqueue.h include/linux/timer.h \
- include/linux/ktime.h include/linux/jiffies.h \
- include/generated/timeconst.h include/linux/timekeeping.h \
- include/linux/timekeeping32.h include/linux/debugobjects.h \
- arch/x86/include/asm/mmu.h include/linux/mutex.h \
- include/linux/debug_locks.h include/linux/page-flags.h \
- include/linux/memory_hotplug.h include/linux/notifier.h \
- include/linux/srcu.h include/linux/rcu_segcblist.h \
+ include/linux/uprobes.h arch/x86/include/asm/uprobes.h \
+ include/linux/notifier.h include/linux/mutex.h \
+ include/linux/debug_locks.h include/linux/srcu.h \
+ include/linux/workqueue.h include/linux/timer.h include/linux/ktime.h \
+ include/linux/jiffies.h include/generated/timeconst.h \
+ include/linux/timekeeping.h include/linux/timekeeping32.h \
+ include/linux/debugobjects.h include/linux/rcu_segcblist.h \
  include/linux/srcutree.h include/linux/rcu_node_tree.h \
- arch/x86/include/asm/mmzone.h arch/x86/include/asm/mmzone_64.h \
- arch/x86/include/asm/smp.h arch/x86/include/asm/mpspec.h \
- arch/x86/include/asm/mpspec_def.h arch/x86/include/asm/x86_init.h \
- arch/x86/include/asm/apicdef.h arch/x86/include/asm/apic.h \
- arch/x86/include/asm/fixmap.h arch/x86/include/asm/acpi.h \
- include/acpi/pdc_intel.h arch/x86/include/asm/numa.h \
- arch/x86/include/asm/topology.h include/asm-generic/topology.h \
- arch/x86/include/asm/realmode.h arch/x86/include/asm/io.h \
- arch/x86/include/generated/asm/early_ioremap.h \
+ arch/x86/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h arch/x86/include/asm/mmzone.h \
+ arch/x86/include/asm/mmzone_64.h arch/x86/include/asm/smp.h \
+ arch/x86/include/asm/mpspec.h arch/x86/include/asm/mpspec_def.h \
+ arch/x86/include/asm/x86_init.h arch/x86/include/asm/apicdef.h \
+ arch/x86/include/asm/apic.h arch/x86/include/asm/fixmap.h \
+ arch/x86/include/asm/acpi.h include/acpi/pdc_intel.h \
+ arch/x86/include/asm/numa.h arch/x86/include/asm/topology.h \
+ include/asm-generic/topology.h arch/x86/include/asm/realmode.h \
+ arch/x86/include/asm/io.h arch/x86/include/generated/asm/early_ioremap.h \
  include/asm-generic/early_ioremap.h include/asm-generic/iomap.h \
  include/asm-generic/pci_iomap.h include/asm-generic/io.h \
  include/linux/logic_pio.h include/linux/fwnode.h include/linux/vmalloc.h \
@@ -281,9 +279,8 @@ rtw8822b.o: /home/finger/rtlwifi_new1/rt
  include/linux/cgroup-defs.h include/linux/bpf-cgroup.h \
  include/linux/bpf.h include/uapi/linux/bpf.h \
  include/uapi/linux/bpf_common.h include/linux/file.h \
- include/linux/rbtree_latch.h include/linux/bpf_types.h \
- include/linux/psi_types.h include/linux/kthread.h \
- include/linux/cgroup_subsys.h include/net/xdp.h \
+ include/linux/rbtree_latch.h include/linux/psi_types.h \
+ include/linux/kthread.h include/linux/cgroup_subsys.h include/net/xdp.h \
  include/uapi/linux/neighbour.h include/linux/netlink.h include/net/scm.h \
  include/linux/security.h include/linux/sched/signal.h \
  include/linux/signal.h include/linux/sched/jobctl.h \
@@ -308,13 +305,11 @@ rtw8822b.o: /home/finger/rtlwifi_new1/rt
  include/linux/vmpressure.h include/linux/eventfd.h \
  include/linux/writeback.h include/linux/flex_proportions.h \
  include/linux/backing-dev-defs.h include/linux/blk_types.h \
- include/linux/bvec.h include/linux/bio.h include/linux/highmem.h \
- arch/x86/include/asm/cacheflush.h include/asm-generic/cacheflush.h \
- include/linux/mempool.h include/linux/filter.h \
- include/linux/cryptohash.h include/linux/set_memory.h \
- arch/x86/include/asm/set_memory.h include/asm-generic/set_memory.h \
- include/linux/kallsyms.h include/linux/module.h include/linux/kmod.h \
- include/linux/umh.h include/linux/elf.h arch/x86/include/asm/elf.h \
+ include/linux/bvec.h include/linux/filter.h include/linux/cryptohash.h \
+ include/linux/set_memory.h arch/x86/include/asm/set_memory.h \
+ include/asm-generic/set_memory.h include/linux/kallsyms.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/x86/include/asm/elf.h \
  arch/x86/include/asm/fsgsbase.h arch/x86/include/asm/vdso.h \
  include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
  include/linux/moduleparam.h include/linux/error-injection.h \
@@ -336,9 +331,14 @@ rtw8822b.o: /home/finger/rtlwifi_new1/rt
  include/uapi/linux/tcp.h include/linux/udp.h include/uapi/linux/udp.h \
  include/net/ieee80211_radiotap.h include/linux/firmware.h \
  include/linux/average.h include/linux/bitfield.h \
- /home/finger/rtlwifi_new1/util.h /home/finger/rtlwifi_new1/hci.h \
- /home/finger/rtlwifi_new1/fw.h /home/finger/rtlwifi_new1/tx.h \
- /home/finger/rtlwifi_new1/rx.h /home/finger/rtlwifi_new1/phy.h \
- /home/finger/rtlwifi_new1/debug.h /home/finger/rtlwifi_new1/rtw8822b.h \
- /home/finger/rtlwifi_new1/rtw8822b_table.h \
- /home/finger/rtlwifi_new1/mac.h /home/finger/rtlwifi_new1/reg.h
+ drivers/net/wireless/realtek/rtw88/util.h \
+ drivers/net/wireless/realtek/rtw88/hci.h \
+ drivers/net/wireless/realtek/rtw88/fw.h \
+ drivers/net/wireless/realtek/rtw88/tx.h \
+ drivers/net/wireless/realtek/rtw88/rx.h \
+ drivers/net/wireless/realtek/rtw88/phy.h \
+ drivers/net/wireless/realtek/rtw88/debug.h \
+ drivers/net/wireless/realtek/rtw88/rtw8822b.h \
+ drivers/net/wireless/realtek/rtw88/rtw8822b_table.h \
+ drivers/net/wireless/realtek/rtw88/mac.h \
+ drivers/net/wireless/realtek/rtw88/reg.h
Only in drivers/net/wireless/realtek/rtw88/: rtw8822b_table.c
Only in drivers/net/wireless/realtek/rtw88/: rtw8822b_table.h
Only in drivers/net/wireless/realtek/rtw88/: rtw8822b_table.o
Only in drivers/net/wireless/realtek/rtw88/: .rtw8822b_table.o.cmd
Only in drivers/net/wireless/realtek/rtw88/: rtw8822c.c
Only in drivers/net/wireless/realtek/rtw88/: rtw8822c.h
Only in drivers/net/wireless/realtek/rtw88/: rtw8822c.o
Only in drivers/net/wireless/realtek/rtw88/: .rtw8822c.o.cmd
diff -upr /home/finger/rtlwifi_new1/.rtw8822c.o.d drivers/net/wireless/realtek/rtw88/.rtw8822c.o.d
--- /home/finger/rtlwifi_new1/.rtw8822c.o.d	2019-06-14 10:01:34.923259735 -0500
+++ drivers/net/wireless/realtek/rtw88/.rtw8822c.o.d	2019-06-14 20:51:06.746378935 -0500
@@ -1,7 +1,7 @@
-rtw8822c.o: /home/finger/rtlwifi_new1/rtw8822c.c include/linux/kconfig.h \
- include/generated/autoconf.h include/linux/compiler_types.h \
- include/linux/compiler_attributes.h include/linux/compiler-gcc.h \
- /home/finger/rtlwifi_new1/main.h include/generated/uapi/linux/version.h \
+rtw8822c.o: drivers/net/wireless/realtek/rtw88/rtw8822c.c \
+ include/linux/kconfig.h include/generated/autoconf.h \
+ include/linux/compiler_types.h include/linux/compiler_attributes.h \
+ include/linux/compiler-gcc.h drivers/net/wireless/realtek/rtw88/main.h \
  include/net/mac80211.h include/linux/bug.h arch/x86/include/asm/bug.h \
  include/linux/stringify.h include/asm-generic/bug.h \
  include/linux/compiler.h include/linux/compiler_types.h \
@@ -69,17 +69,11 @@ rtw8822c.o: /home/finger/rtlwifi_new1/rt
  arch/x86/include/uapi/asm/processor-flags.h \
  arch/x86/include/asm/math_emu.h arch/x86/include/asm/ptrace.h \
  arch/x86/include/asm/segment.h arch/x86/include/uapi/asm/ptrace.h \
- arch/x86/include/uapi/asm/ptrace-abi.h \
- arch/x86/include/asm/paravirt_types.h arch/x86/include/asm/desc_defs.h \
- arch/x86/include/asm/kmap_types.h include/asm-generic/kmap_types.h \
+ arch/x86/include/uapi/asm/ptrace-abi.h include/asm-generic/ptrace.h \
+ arch/x86/include/uapi/asm/sigcontext.h \
  arch/x86/include/asm/pgtable_types.h \
  arch/x86/include/asm/pgtable_64_types.h arch/x86/include/asm/sparsemem.h \
- include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/nospec-branch.h \
- include/linux/static_key.h arch/x86/include/asm/alternative-asm.h \
- arch/x86/include/asm/msr-index.h arch/x86/include/asm/spinlock_types.h \
- include/asm-generic/qspinlock_types.h \
- include/asm-generic/qrwlock_types.h include/asm-generic/ptrace.h \
- arch/x86/include/uapi/asm/sigcontext.h arch/x86/include/asm/msr.h \
+ include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/msr.h \
  arch/x86/include/asm/msr-index.h arch/x86/include/uapi/asm/errno.h \
  include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
  arch/x86/include/asm/cpumask.h include/linux/cpumask.h \
@@ -91,21 +85,25 @@ rtw8822c.o: /home/finger/rtlwifi_new1/rt
  include/asm-generic/atomic-instrumented.h \
  include/linux/tracepoint-defs.h include/linux/atomic.h \
  include/linux/atomic-fallback.h include/asm-generic/atomic-long.h \
- include/linux/errno.h include/uapi/linux/errno.h \
+ include/linux/static_key.h include/linux/errno.h \
+ include/uapi/linux/errno.h arch/x86/include/asm/desc_defs.h \
  arch/x86/include/asm/special_insns.h arch/x86/include/asm/fpu/types.h \
  arch/x86/include/asm/unwind_hints.h arch/x86/include/asm/orc_types.h \
  include/linux/personality.h include/uapi/linux/personality.h \
  include/linux/err.h include/linux/irqflags.h \
- arch/x86/include/asm/irqflags.h include/linux/bottom_half.h \
- arch/x86/include/generated/asm/mmiowb.h include/asm-generic/mmiowb.h \
- include/linux/spinlock_types.h include/linux/lockdep.h \
+ arch/x86/include/asm/irqflags.h arch/x86/include/asm/nospec-branch.h \
+ arch/x86/include/asm/alternative-asm.h arch/x86/include/asm/msr-index.h \
+ include/linux/bottom_half.h arch/x86/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h include/linux/spinlock_types.h \
+ arch/x86/include/asm/spinlock_types.h \
+ include/asm-generic/qspinlock_types.h \
+ include/asm-generic/qrwlock_types.h include/linux/lockdep.h \
  include/linux/rwlock_types.h arch/x86/include/asm/spinlock.h \
- arch/x86/include/asm/paravirt.h arch/x86/include/asm/frame.h \
- arch/x86/include/asm/qspinlock.h include/asm-generic/qspinlock.h \
- arch/x86/include/asm/qrwlock.h include/asm-generic/qrwlock.h \
- include/linux/rwlock.h include/linux/spinlock_api_smp.h \
- include/linux/rwlock_api_smp.h include/linux/time32.h \
- include/linux/timex.h include/uapi/linux/timex.h \
+ arch/x86/include/asm/paravirt.h arch/x86/include/asm/qspinlock.h \
+ include/asm-generic/qspinlock.h arch/x86/include/asm/qrwlock.h \
+ include/asm-generic/qrwlock.h include/linux/rwlock.h \
+ include/linux/spinlock_api_smp.h include/linux/rwlock_api_smp.h \
+ include/linux/time32.h include/linux/timex.h include/uapi/linux/timex.h \
  include/uapi/linux/param.h arch/x86/include/uapi/asm/param.h \
  include/asm-generic/param.h include/uapi/asm-generic/param.h \
  arch/x86/include/asm/timex.h arch/x86/include/asm/tsc.h \
@@ -124,24 +122,24 @@ rtw8822c.o: /home/finger/rtlwifi_new1/rt
  include/linux/auxvec.h include/uapi/linux/auxvec.h \
  arch/x86/include/uapi/asm/auxvec.h include/linux/rwsem.h \
  include/linux/osq_lock.h include/linux/completion.h \
- include/linux/uprobes.h include/linux/workqueue.h include/linux/timer.h \
- include/linux/ktime.h include/linux/jiffies.h \
- include/generated/timeconst.h include/linux/timekeeping.h \
- include/linux/timekeeping32.h include/linux/debugobjects.h \
- arch/x86/include/asm/mmu.h include/linux/mutex.h \
- include/linux/debug_locks.h include/linux/page-flags.h \
- include/linux/memory_hotplug.h include/linux/notifier.h \
- include/linux/srcu.h include/linux/rcu_segcblist.h \
+ include/linux/uprobes.h arch/x86/include/asm/uprobes.h \
+ include/linux/notifier.h include/linux/mutex.h \
+ include/linux/debug_locks.h include/linux/srcu.h \
+ include/linux/workqueue.h include/linux/timer.h include/linux/ktime.h \
+ include/linux/jiffies.h include/generated/timeconst.h \
+ include/linux/timekeeping.h include/linux/timekeeping32.h \
+ include/linux/debugobjects.h include/linux/rcu_segcblist.h \
  include/linux/srcutree.h include/linux/rcu_node_tree.h \
- arch/x86/include/asm/mmzone.h arch/x86/include/asm/mmzone_64.h \
- arch/x86/include/asm/smp.h arch/x86/include/asm/mpspec.h \
- arch/x86/include/asm/mpspec_def.h arch/x86/include/asm/x86_init.h \
- arch/x86/include/asm/apicdef.h arch/x86/include/asm/apic.h \
- arch/x86/include/asm/fixmap.h arch/x86/include/asm/acpi.h \
- include/acpi/pdc_intel.h arch/x86/include/asm/numa.h \
- arch/x86/include/asm/topology.h include/asm-generic/topology.h \
- arch/x86/include/asm/realmode.h arch/x86/include/asm/io.h \
- arch/x86/include/generated/asm/early_ioremap.h \
+ arch/x86/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h arch/x86/include/asm/mmzone.h \
+ arch/x86/include/asm/mmzone_64.h arch/x86/include/asm/smp.h \
+ arch/x86/include/asm/mpspec.h arch/x86/include/asm/mpspec_def.h \
+ arch/x86/include/asm/x86_init.h arch/x86/include/asm/apicdef.h \
+ arch/x86/include/asm/apic.h arch/x86/include/asm/fixmap.h \
+ arch/x86/include/asm/acpi.h include/acpi/pdc_intel.h \
+ arch/x86/include/asm/numa.h arch/x86/include/asm/topology.h \
+ include/asm-generic/topology.h arch/x86/include/asm/realmode.h \
+ arch/x86/include/asm/io.h arch/x86/include/generated/asm/early_ioremap.h \
  include/asm-generic/early_ioremap.h include/asm-generic/iomap.h \
  include/asm-generic/pci_iomap.h include/asm-generic/io.h \
  include/linux/logic_pio.h include/linux/fwnode.h include/linux/vmalloc.h \
@@ -281,9 +279,8 @@ rtw8822c.o: /home/finger/rtlwifi_new1/rt
  include/linux/cgroup-defs.h include/linux/bpf-cgroup.h \
  include/linux/bpf.h include/uapi/linux/bpf.h \
  include/uapi/linux/bpf_common.h include/linux/file.h \
- include/linux/rbtree_latch.h include/linux/bpf_types.h \
- include/linux/psi_types.h include/linux/kthread.h \
- include/linux/cgroup_subsys.h include/net/xdp.h \
+ include/linux/rbtree_latch.h include/linux/psi_types.h \
+ include/linux/kthread.h include/linux/cgroup_subsys.h include/net/xdp.h \
  include/uapi/linux/neighbour.h include/linux/netlink.h include/net/scm.h \
  include/linux/security.h include/linux/sched/signal.h \
  include/linux/signal.h include/linux/sched/jobctl.h \
@@ -308,13 +305,11 @@ rtw8822c.o: /home/finger/rtlwifi_new1/rt
  include/linux/vmpressure.h include/linux/eventfd.h \
  include/linux/writeback.h include/linux/flex_proportions.h \
  include/linux/backing-dev-defs.h include/linux/blk_types.h \
- include/linux/bvec.h include/linux/bio.h include/linux/highmem.h \
- arch/x86/include/asm/cacheflush.h include/asm-generic/cacheflush.h \
- include/linux/mempool.h include/linux/filter.h \
- include/linux/cryptohash.h include/linux/set_memory.h \
- arch/x86/include/asm/set_memory.h include/asm-generic/set_memory.h \
- include/linux/kallsyms.h include/linux/module.h include/linux/kmod.h \
- include/linux/umh.h include/linux/elf.h arch/x86/include/asm/elf.h \
+ include/linux/bvec.h include/linux/filter.h include/linux/cryptohash.h \
+ include/linux/set_memory.h arch/x86/include/asm/set_memory.h \
+ include/asm-generic/set_memory.h include/linux/kallsyms.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/x86/include/asm/elf.h \
  arch/x86/include/asm/fsgsbase.h arch/x86/include/asm/vdso.h \
  include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
  include/linux/moduleparam.h include/linux/error-injection.h \
@@ -336,9 +331,14 @@ rtw8822c.o: /home/finger/rtlwifi_new1/rt
  include/uapi/linux/tcp.h include/linux/udp.h include/uapi/linux/udp.h \
  include/net/ieee80211_radiotap.h include/linux/firmware.h \
  include/linux/average.h include/linux/bitfield.h \
- /home/finger/rtlwifi_new1/util.h /home/finger/rtlwifi_new1/hci.h \
- /home/finger/rtlwifi_new1/fw.h /home/finger/rtlwifi_new1/tx.h \
- /home/finger/rtlwifi_new1/rx.h /home/finger/rtlwifi_new1/phy.h \
- /home/finger/rtlwifi_new1/debug.h /home/finger/rtlwifi_new1/rtw8822c.h \
- /home/finger/rtlwifi_new1/rtw8822c_table.h \
- /home/finger/rtlwifi_new1/mac.h /home/finger/rtlwifi_new1/reg.h
+ drivers/net/wireless/realtek/rtw88/util.h \
+ drivers/net/wireless/realtek/rtw88/hci.h \
+ drivers/net/wireless/realtek/rtw88/fw.h \
+ drivers/net/wireless/realtek/rtw88/tx.h \
+ drivers/net/wireless/realtek/rtw88/rx.h \
+ drivers/net/wireless/realtek/rtw88/phy.h \
+ drivers/net/wireless/realtek/rtw88/debug.h \
+ drivers/net/wireless/realtek/rtw88/rtw8822c.h \
+ drivers/net/wireless/realtek/rtw88/rtw8822c_table.h \
+ drivers/net/wireless/realtek/rtw88/mac.h \
+ drivers/net/wireless/realtek/rtw88/reg.h
Only in drivers/net/wireless/realtek/rtw88/: rtw8822c_table.c
Only in drivers/net/wireless/realtek/rtw88/: rtw8822c_table.h
Only in drivers/net/wireless/realtek/rtw88/: rtw8822c_table.o
Only in drivers/net/wireless/realtek/rtw88/: .rtw8822c_table.o.cmd
Only in /home/finger/rtlwifi_new1/: rtw88.diffs
Only in drivers/net/wireless/realtek/rtw88/: rtw88.mod.c
Only in drivers/net/wireless/realtek/rtw88/: rtw88.o
Only in drivers/net/wireless/realtek/rtw88/: .rtw88.o.cmd
Only in drivers/net/wireless/realtek/rtw88/: rtwpci.mod.c
Only in drivers/net/wireless/realtek/rtw88/: rtwpci.o
Only in drivers/net/wireless/realtek/rtw88/: .rtwpci.o.cmd
Only in /home/finger/rtlwifi_new1/: rtw_sta_info.h
Only in drivers/net/wireless/realtek/rtw88/: rx.c
Only in drivers/net/wireless/realtek/rtw88/: rx.h
Only in drivers/net/wireless/realtek/rtw88/: rx.o
Only in drivers/net/wireless/realtek/rtw88/: .rx.o.cmd
diff -upr /home/finger/rtlwifi_new1/.rx.o.d drivers/net/wireless/realtek/rtw88/.rx.o.d
--- /home/finger/rtlwifi_new1/.rx.o.d	2019-06-14 10:01:31.803245817 -0500
+++ drivers/net/wireless/realtek/rtw88/.rx.o.d	2019-06-14 20:50:59.646341826 -0500
@@ -1,13 +1,12 @@
-rx.o: /home/finger/rtlwifi_new1/rx.c include/linux/kconfig.h \
+rx.o: drivers/net/wireless/realtek/rtw88/rx.c include/linux/kconfig.h \
  include/generated/autoconf.h include/linux/compiler_types.h \
  include/linux/compiler_attributes.h include/linux/compiler-gcc.h \
- /home/finger/rtlwifi_new1/main.h include/generated/uapi/linux/version.h \
- include/net/mac80211.h include/linux/bug.h arch/x86/include/asm/bug.h \
- include/linux/stringify.h include/asm-generic/bug.h \
- include/linux/compiler.h include/linux/compiler_types.h \
- include/uapi/linux/types.h arch/x86/include/uapi/asm/types.h \
- include/uapi/asm-generic/types.h include/asm-generic/int-ll64.h \
- include/uapi/asm-generic/int-ll64.h \
+ drivers/net/wireless/realtek/rtw88/main.h include/net/mac80211.h \
+ include/linux/bug.h arch/x86/include/asm/bug.h include/linux/stringify.h \
+ include/asm-generic/bug.h include/linux/compiler.h \
+ include/linux/compiler_types.h include/uapi/linux/types.h \
+ arch/x86/include/uapi/asm/types.h include/uapi/asm-generic/types.h \
+ include/asm-generic/int-ll64.h include/uapi/asm-generic/int-ll64.h \
  arch/x86/include/uapi/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h include/uapi/asm-generic/bitsperlong.h \
  include/uapi/linux/posix_types.h include/linux/stddef.h \
@@ -69,17 +68,11 @@ rx.o: /home/finger/rtlwifi_new1/rx.c inc
  arch/x86/include/uapi/asm/processor-flags.h \
  arch/x86/include/asm/math_emu.h arch/x86/include/asm/ptrace.h \
  arch/x86/include/asm/segment.h arch/x86/include/uapi/asm/ptrace.h \
- arch/x86/include/uapi/asm/ptrace-abi.h \
- arch/x86/include/asm/paravirt_types.h arch/x86/include/asm/desc_defs.h \
- arch/x86/include/asm/kmap_types.h include/asm-generic/kmap_types.h \
+ arch/x86/include/uapi/asm/ptrace-abi.h include/asm-generic/ptrace.h \
+ arch/x86/include/uapi/asm/sigcontext.h \
  arch/x86/include/asm/pgtable_types.h \
  arch/x86/include/asm/pgtable_64_types.h arch/x86/include/asm/sparsemem.h \
- include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/nospec-branch.h \
- include/linux/static_key.h arch/x86/include/asm/alternative-asm.h \
- arch/x86/include/asm/msr-index.h arch/x86/include/asm/spinlock_types.h \
- include/asm-generic/qspinlock_types.h \
- include/asm-generic/qrwlock_types.h include/asm-generic/ptrace.h \
- arch/x86/include/uapi/asm/sigcontext.h arch/x86/include/asm/msr.h \
+ include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/msr.h \
  arch/x86/include/asm/msr-index.h arch/x86/include/uapi/asm/errno.h \
  include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
  arch/x86/include/asm/cpumask.h include/linux/cpumask.h \
@@ -91,21 +84,25 @@ rx.o: /home/finger/rtlwifi_new1/rx.c inc
  include/asm-generic/atomic-instrumented.h \
  include/linux/tracepoint-defs.h include/linux/atomic.h \
  include/linux/atomic-fallback.h include/asm-generic/atomic-long.h \
- include/linux/errno.h include/uapi/linux/errno.h \
+ include/linux/static_key.h include/linux/errno.h \
+ include/uapi/linux/errno.h arch/x86/include/asm/desc_defs.h \
  arch/x86/include/asm/special_insns.h arch/x86/include/asm/fpu/types.h \
  arch/x86/include/asm/unwind_hints.h arch/x86/include/asm/orc_types.h \
  include/linux/personality.h include/uapi/linux/personality.h \
  include/linux/err.h include/linux/irqflags.h \
- arch/x86/include/asm/irqflags.h include/linux/bottom_half.h \
- arch/x86/include/generated/asm/mmiowb.h include/asm-generic/mmiowb.h \
- include/linux/spinlock_types.h include/linux/lockdep.h \
+ arch/x86/include/asm/irqflags.h arch/x86/include/asm/nospec-branch.h \
+ arch/x86/include/asm/alternative-asm.h arch/x86/include/asm/msr-index.h \
+ include/linux/bottom_half.h arch/x86/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h include/linux/spinlock_types.h \
+ arch/x86/include/asm/spinlock_types.h \
+ include/asm-generic/qspinlock_types.h \
+ include/asm-generic/qrwlock_types.h include/linux/lockdep.h \
  include/linux/rwlock_types.h arch/x86/include/asm/spinlock.h \
- arch/x86/include/asm/paravirt.h arch/x86/include/asm/frame.h \
- arch/x86/include/asm/qspinlock.h include/asm-generic/qspinlock.h \
- arch/x86/include/asm/qrwlock.h include/asm-generic/qrwlock.h \
- include/linux/rwlock.h include/linux/spinlock_api_smp.h \
- include/linux/rwlock_api_smp.h include/linux/time32.h \
- include/linux/timex.h include/uapi/linux/timex.h \
+ arch/x86/include/asm/paravirt.h arch/x86/include/asm/qspinlock.h \
+ include/asm-generic/qspinlock.h arch/x86/include/asm/qrwlock.h \
+ include/asm-generic/qrwlock.h include/linux/rwlock.h \
+ include/linux/spinlock_api_smp.h include/linux/rwlock_api_smp.h \
+ include/linux/time32.h include/linux/timex.h include/uapi/linux/timex.h \
  include/uapi/linux/param.h arch/x86/include/uapi/asm/param.h \
  include/asm-generic/param.h include/uapi/asm-generic/param.h \
  arch/x86/include/asm/timex.h arch/x86/include/asm/tsc.h \
@@ -124,24 +121,24 @@ rx.o: /home/finger/rtlwifi_new1/rx.c inc
  include/linux/auxvec.h include/uapi/linux/auxvec.h \
  arch/x86/include/uapi/asm/auxvec.h include/linux/rwsem.h \
  include/linux/osq_lock.h include/linux/completion.h \
- include/linux/uprobes.h include/linux/workqueue.h include/linux/timer.h \
- include/linux/ktime.h include/linux/jiffies.h \
- include/generated/timeconst.h include/linux/timekeeping.h \
- include/linux/timekeeping32.h include/linux/debugobjects.h \
- arch/x86/include/asm/mmu.h include/linux/mutex.h \
- include/linux/debug_locks.h include/linux/page-flags.h \
- include/linux/memory_hotplug.h include/linux/notifier.h \
- include/linux/srcu.h include/linux/rcu_segcblist.h \
+ include/linux/uprobes.h arch/x86/include/asm/uprobes.h \
+ include/linux/notifier.h include/linux/mutex.h \
+ include/linux/debug_locks.h include/linux/srcu.h \
+ include/linux/workqueue.h include/linux/timer.h include/linux/ktime.h \
+ include/linux/jiffies.h include/generated/timeconst.h \
+ include/linux/timekeeping.h include/linux/timekeeping32.h \
+ include/linux/debugobjects.h include/linux/rcu_segcblist.h \
  include/linux/srcutree.h include/linux/rcu_node_tree.h \
- arch/x86/include/asm/mmzone.h arch/x86/include/asm/mmzone_64.h \
- arch/x86/include/asm/smp.h arch/x86/include/asm/mpspec.h \
- arch/x86/include/asm/mpspec_def.h arch/x86/include/asm/x86_init.h \
- arch/x86/include/asm/apicdef.h arch/x86/include/asm/apic.h \
- arch/x86/include/asm/fixmap.h arch/x86/include/asm/acpi.h \
- include/acpi/pdc_intel.h arch/x86/include/asm/numa.h \
- arch/x86/include/asm/topology.h include/asm-generic/topology.h \
- arch/x86/include/asm/realmode.h arch/x86/include/asm/io.h \
- arch/x86/include/generated/asm/early_ioremap.h \
+ arch/x86/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h arch/x86/include/asm/mmzone.h \
+ arch/x86/include/asm/mmzone_64.h arch/x86/include/asm/smp.h \
+ arch/x86/include/asm/mpspec.h arch/x86/include/asm/mpspec_def.h \
+ arch/x86/include/asm/x86_init.h arch/x86/include/asm/apicdef.h \
+ arch/x86/include/asm/apic.h arch/x86/include/asm/fixmap.h \
+ arch/x86/include/asm/acpi.h include/acpi/pdc_intel.h \
+ arch/x86/include/asm/numa.h arch/x86/include/asm/topology.h \
+ include/asm-generic/topology.h arch/x86/include/asm/realmode.h \
+ arch/x86/include/asm/io.h arch/x86/include/generated/asm/early_ioremap.h \
  include/asm-generic/early_ioremap.h include/asm-generic/iomap.h \
  include/asm-generic/pci_iomap.h include/asm-generic/io.h \
  include/linux/logic_pio.h include/linux/fwnode.h include/linux/vmalloc.h \
@@ -281,9 +278,8 @@ rx.o: /home/finger/rtlwifi_new1/rx.c inc
  include/linux/cgroup-defs.h include/linux/bpf-cgroup.h \
  include/linux/bpf.h include/uapi/linux/bpf.h \
  include/uapi/linux/bpf_common.h include/linux/file.h \
- include/linux/rbtree_latch.h include/linux/bpf_types.h \
- include/linux/psi_types.h include/linux/kthread.h \
- include/linux/cgroup_subsys.h include/net/xdp.h \
+ include/linux/rbtree_latch.h include/linux/psi_types.h \
+ include/linux/kthread.h include/linux/cgroup_subsys.h include/net/xdp.h \
  include/uapi/linux/neighbour.h include/linux/netlink.h include/net/scm.h \
  include/linux/security.h include/linux/sched/signal.h \
  include/linux/signal.h include/linux/sched/jobctl.h \
@@ -308,13 +304,11 @@ rx.o: /home/finger/rtlwifi_new1/rx.c inc
  include/linux/vmpressure.h include/linux/eventfd.h \
  include/linux/writeback.h include/linux/flex_proportions.h \
  include/linux/backing-dev-defs.h include/linux/blk_types.h \
- include/linux/bvec.h include/linux/bio.h include/linux/highmem.h \
- arch/x86/include/asm/cacheflush.h include/asm-generic/cacheflush.h \
- include/linux/mempool.h include/linux/filter.h \
- include/linux/cryptohash.h include/linux/set_memory.h \
- arch/x86/include/asm/set_memory.h include/asm-generic/set_memory.h \
- include/linux/kallsyms.h include/linux/module.h include/linux/kmod.h \
- include/linux/umh.h include/linux/elf.h arch/x86/include/asm/elf.h \
+ include/linux/bvec.h include/linux/filter.h include/linux/cryptohash.h \
+ include/linux/set_memory.h arch/x86/include/asm/set_memory.h \
+ include/asm-generic/set_memory.h include/linux/kallsyms.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/x86/include/asm/elf.h \
  arch/x86/include/asm/fsgsbase.h arch/x86/include/asm/vdso.h \
  include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
  include/linux/moduleparam.h include/linux/error-injection.h \
@@ -336,5 +330,7 @@ rx.o: /home/finger/rtlwifi_new1/rx.c inc
  include/uapi/linux/tcp.h include/linux/udp.h include/uapi/linux/udp.h \
  include/net/ieee80211_radiotap.h include/linux/firmware.h \
  include/linux/average.h include/linux/bitfield.h \
- /home/finger/rtlwifi_new1/util.h /home/finger/rtlwifi_new1/hci.h \
- /home/finger/rtlwifi_new1/rx.h /home/finger/rtlwifi_new1/ps.h
+ drivers/net/wireless/realtek/rtw88/util.h \
+ drivers/net/wireless/realtek/rtw88/hci.h \
+ drivers/net/wireless/realtek/rtw88/rx.h \
+ drivers/net/wireless/realtek/rtw88/ps.h
Only in drivers/net/wireless/realtek/rtw88/: sec.c
Only in drivers/net/wireless/realtek/rtw88/: sec.h
Only in drivers/net/wireless/realtek/rtw88/: sec.o
Only in drivers/net/wireless/realtek/rtw88/: .sec.o.cmd
Only in /home/finger/rtlwifi_new1/: stats.c
Only in /home/finger/rtlwifi_new1/: stats.h
Only in /home/finger/rtlwifi_new1/: .stats.o.d
Only in /home/finger/rtlwifi_new1/: tools
Only in drivers/net/wireless/realtek/rtw88/: tx.c
Only in drivers/net/wireless/realtek/rtw88/: tx.h
Only in drivers/net/wireless/realtek/rtw88/: tx.o
Only in drivers/net/wireless/realtek/rtw88/: .tx.o.cmd
diff -upr /home/finger/rtlwifi_new1/.tx.o.d drivers/net/wireless/realtek/rtw88/.tx.o.d
--- /home/finger/rtlwifi_new1/.tx.o.d	2019-06-14 10:01:32.543249118 -0500
+++ drivers/net/wireless/realtek/rtw88/.tx.o.d	2019-06-14 20:50:58.942338147 -0500
@@ -1,13 +1,12 @@
-tx.o: /home/finger/rtlwifi_new1/tx.c include/linux/kconfig.h \
+tx.o: drivers/net/wireless/realtek/rtw88/tx.c include/linux/kconfig.h \
  include/generated/autoconf.h include/linux/compiler_types.h \
  include/linux/compiler_attributes.h include/linux/compiler-gcc.h \
- /home/finger/rtlwifi_new1/main.h include/generated/uapi/linux/version.h \
- include/net/mac80211.h include/linux/bug.h arch/x86/include/asm/bug.h \
- include/linux/stringify.h include/asm-generic/bug.h \
- include/linux/compiler.h include/linux/compiler_types.h \
- include/uapi/linux/types.h arch/x86/include/uapi/asm/types.h \
- include/uapi/asm-generic/types.h include/asm-generic/int-ll64.h \
- include/uapi/asm-generic/int-ll64.h \
+ drivers/net/wireless/realtek/rtw88/main.h include/net/mac80211.h \
+ include/linux/bug.h arch/x86/include/asm/bug.h include/linux/stringify.h \
+ include/asm-generic/bug.h include/linux/compiler.h \
+ include/linux/compiler_types.h include/uapi/linux/types.h \
+ arch/x86/include/uapi/asm/types.h include/uapi/asm-generic/types.h \
+ include/asm-generic/int-ll64.h include/uapi/asm-generic/int-ll64.h \
  arch/x86/include/uapi/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h include/uapi/asm-generic/bitsperlong.h \
  include/uapi/linux/posix_types.h include/linux/stddef.h \
@@ -69,17 +68,11 @@ tx.o: /home/finger/rtlwifi_new1/tx.c inc
  arch/x86/include/uapi/asm/processor-flags.h \
  arch/x86/include/asm/math_emu.h arch/x86/include/asm/ptrace.h \
  arch/x86/include/asm/segment.h arch/x86/include/uapi/asm/ptrace.h \
- arch/x86/include/uapi/asm/ptrace-abi.h \
- arch/x86/include/asm/paravirt_types.h arch/x86/include/asm/desc_defs.h \
- arch/x86/include/asm/kmap_types.h include/asm-generic/kmap_types.h \
+ arch/x86/include/uapi/asm/ptrace-abi.h include/asm-generic/ptrace.h \
+ arch/x86/include/uapi/asm/sigcontext.h \
  arch/x86/include/asm/pgtable_types.h \
  arch/x86/include/asm/pgtable_64_types.h arch/x86/include/asm/sparsemem.h \
- include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/nospec-branch.h \
- include/linux/static_key.h arch/x86/include/asm/alternative-asm.h \
- arch/x86/include/asm/msr-index.h arch/x86/include/asm/spinlock_types.h \
- include/asm-generic/qspinlock_types.h \
- include/asm-generic/qrwlock_types.h include/asm-generic/ptrace.h \
- arch/x86/include/uapi/asm/sigcontext.h arch/x86/include/asm/msr.h \
+ include/asm-generic/pgtable-nop4d.h arch/x86/include/asm/msr.h \
  arch/x86/include/asm/msr-index.h arch/x86/include/uapi/asm/errno.h \
  include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
  arch/x86/include/asm/cpumask.h include/linux/cpumask.h \
@@ -91,21 +84,25 @@ tx.o: /home/finger/rtlwifi_new1/tx.c inc
  include/asm-generic/atomic-instrumented.h \
  include/linux/tracepoint-defs.h include/linux/atomic.h \
  include/linux/atomic-fallback.h include/asm-generic/atomic-long.h \
- include/linux/errno.h include/uapi/linux/errno.h \
+ include/linux/static_key.h include/linux/errno.h \
+ include/uapi/linux/errno.h arch/x86/include/asm/desc_defs.h \
  arch/x86/include/asm/special_insns.h arch/x86/include/asm/fpu/types.h \
  arch/x86/include/asm/unwind_hints.h arch/x86/include/asm/orc_types.h \
  include/linux/personality.h include/uapi/linux/personality.h \
  include/linux/err.h include/linux/irqflags.h \
- arch/x86/include/asm/irqflags.h include/linux/bottom_half.h \
- arch/x86/include/generated/asm/mmiowb.h include/asm-generic/mmiowb.h \
- include/linux/spinlock_types.h include/linux/lockdep.h \
+ arch/x86/include/asm/irqflags.h arch/x86/include/asm/nospec-branch.h \
+ arch/x86/include/asm/alternative-asm.h arch/x86/include/asm/msr-index.h \
+ include/linux/bottom_half.h arch/x86/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h include/linux/spinlock_types.h \
+ arch/x86/include/asm/spinlock_types.h \
+ include/asm-generic/qspinlock_types.h \
+ include/asm-generic/qrwlock_types.h include/linux/lockdep.h \
  include/linux/rwlock_types.h arch/x86/include/asm/spinlock.h \
- arch/x86/include/asm/paravirt.h arch/x86/include/asm/frame.h \
- arch/x86/include/asm/qspinlock.h include/asm-generic/qspinlock.h \
- arch/x86/include/asm/qrwlock.h include/asm-generic/qrwlock.h \
- include/linux/rwlock.h include/linux/spinlock_api_smp.h \
- include/linux/rwlock_api_smp.h include/linux/time32.h \
- include/linux/timex.h include/uapi/linux/timex.h \
+ arch/x86/include/asm/paravirt.h arch/x86/include/asm/qspinlock.h \
+ include/asm-generic/qspinlock.h arch/x86/include/asm/qrwlock.h \
+ include/asm-generic/qrwlock.h include/linux/rwlock.h \
+ include/linux/spinlock_api_smp.h include/linux/rwlock_api_smp.h \
+ include/linux/time32.h include/linux/timex.h include/uapi/linux/timex.h \
  include/uapi/linux/param.h arch/x86/include/uapi/asm/param.h \
  include/asm-generic/param.h include/uapi/asm-generic/param.h \
  arch/x86/include/asm/timex.h arch/x86/include/asm/tsc.h \
@@ -124,24 +121,24 @@ tx.o: /home/finger/rtlwifi_new1/tx.c inc
  include/linux/auxvec.h include/uapi/linux/auxvec.h \
  arch/x86/include/uapi/asm/auxvec.h include/linux/rwsem.h \
  include/linux/osq_lock.h include/linux/completion.h \
- include/linux/uprobes.h include/linux/workqueue.h include/linux/timer.h \
- include/linux/ktime.h include/linux/jiffies.h \
- include/generated/timeconst.h include/linux/timekeeping.h \
- include/linux/timekeeping32.h include/linux/debugobjects.h \
- arch/x86/include/asm/mmu.h include/linux/mutex.h \
- include/linux/debug_locks.h include/linux/page-flags.h \
- include/linux/memory_hotplug.h include/linux/notifier.h \
- include/linux/srcu.h include/linux/rcu_segcblist.h \
+ include/linux/uprobes.h arch/x86/include/asm/uprobes.h \
+ include/linux/notifier.h include/linux/mutex.h \
+ include/linux/debug_locks.h include/linux/srcu.h \
+ include/linux/workqueue.h include/linux/timer.h include/linux/ktime.h \
+ include/linux/jiffies.h include/generated/timeconst.h \
+ include/linux/timekeeping.h include/linux/timekeeping32.h \
+ include/linux/debugobjects.h include/linux/rcu_segcblist.h \
  include/linux/srcutree.h include/linux/rcu_node_tree.h \
- arch/x86/include/asm/mmzone.h arch/x86/include/asm/mmzone_64.h \
- arch/x86/include/asm/smp.h arch/x86/include/asm/mpspec.h \
- arch/x86/include/asm/mpspec_def.h arch/x86/include/asm/x86_init.h \
- arch/x86/include/asm/apicdef.h arch/x86/include/asm/apic.h \
- arch/x86/include/asm/fixmap.h arch/x86/include/asm/acpi.h \
- include/acpi/pdc_intel.h arch/x86/include/asm/numa.h \
- arch/x86/include/asm/topology.h include/asm-generic/topology.h \
- arch/x86/include/asm/realmode.h arch/x86/include/asm/io.h \
- arch/x86/include/generated/asm/early_ioremap.h \
+ arch/x86/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h arch/x86/include/asm/mmzone.h \
+ arch/x86/include/asm/mmzone_64.h arch/x86/include/asm/smp.h \
+ arch/x86/include/asm/mpspec.h arch/x86/include/asm/mpspec_def.h \
+ arch/x86/include/asm/x86_init.h arch/x86/include/asm/apicdef.h \
+ arch/x86/include/asm/apic.h arch/x86/include/asm/fixmap.h \
+ arch/x86/include/asm/acpi.h include/acpi/pdc_intel.h \
+ arch/x86/include/asm/numa.h arch/x86/include/asm/topology.h \
+ include/asm-generic/topology.h arch/x86/include/asm/realmode.h \
+ arch/x86/include/asm/io.h arch/x86/include/generated/asm/early_ioremap.h \
  include/asm-generic/early_ioremap.h include/asm-generic/iomap.h \
  include/asm-generic/pci_iomap.h include/asm-generic/io.h \
  include/linux/logic_pio.h include/linux/fwnode.h include/linux/vmalloc.h \
@@ -281,9 +278,8 @@ tx.o: /home/finger/rtlwifi_new1/tx.c inc
  include/linux/cgroup-defs.h include/linux/bpf-cgroup.h \
  include/linux/bpf.h include/uapi/linux/bpf.h \
  include/uapi/linux/bpf_common.h include/linux/file.h \
- include/linux/rbtree_latch.h include/linux/bpf_types.h \
- include/linux/psi_types.h include/linux/kthread.h \
- include/linux/cgroup_subsys.h include/net/xdp.h \
+ include/linux/rbtree_latch.h include/linux/psi_types.h \
+ include/linux/kthread.h include/linux/cgroup_subsys.h include/net/xdp.h \
  include/uapi/linux/neighbour.h include/linux/netlink.h include/net/scm.h \
  include/linux/security.h include/linux/sched/signal.h \
  include/linux/signal.h include/linux/sched/jobctl.h \
@@ -308,13 +304,11 @@ tx.o: /home/finger/rtlwifi_new1/tx.c inc
  include/linux/vmpressure.h include/linux/eventfd.h \
  include/linux/writeback.h include/linux/flex_proportions.h \
  include/linux/backing-dev-defs.h include/linux/blk_types.h \
- include/linux/bvec.h include/linux/bio.h include/linux/highmem.h \
- arch/x86/include/asm/cacheflush.h include/asm-generic/cacheflush.h \
- include/linux/mempool.h include/linux/filter.h \
- include/linux/cryptohash.h include/linux/set_memory.h \
- arch/x86/include/asm/set_memory.h include/asm-generic/set_memory.h \
- include/linux/kallsyms.h include/linux/module.h include/linux/kmod.h \
- include/linux/umh.h include/linux/elf.h arch/x86/include/asm/elf.h \
+ include/linux/bvec.h include/linux/filter.h include/linux/cryptohash.h \
+ include/linux/set_memory.h arch/x86/include/asm/set_memory.h \
+ include/asm-generic/set_memory.h include/linux/kallsyms.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/x86/include/asm/elf.h \
  arch/x86/include/asm/fsgsbase.h arch/x86/include/asm/vdso.h \
  include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
  include/linux/moduleparam.h include/linux/error-injection.h \
@@ -336,6 +330,8 @@ tx.o: /home/finger/rtlwifi_new1/tx.c inc
  include/uapi/linux/tcp.h include/linux/udp.h include/uapi/linux/udp.h \
  include/net/ieee80211_radiotap.h include/linux/firmware.h \
  include/linux/average.h include/linux/bitfield.h \
- /home/finger/rtlwifi_new1/util.h /home/finger/rtlwifi_new1/hci.h \
- /home/finger/rtlwifi_new1/tx.h /home/finger/rtlwifi_new1/fw.h \
- /home/finger/rtlwifi_new1/ps.h
+ drivers/net/wireless/realtek/rtw88/util.h \
+ drivers/net/wireless/realtek/rtw88/hci.h \
+ drivers/net/wireless/realtek/rtw88/tx.h \
+ drivers/net/wireless/realtek/rtw88/fw.h \
+ drivers/net/wireless/realtek/rtw88/ps.h
Only in /home/finger/rtlwifi_new1/: usb.c
Only in /home/finger/rtlwifi_new1/: usb.h
Only in /home/finger/rtlwifi_new1/: .usb.o.d
Only in drivers/net/wireless/realtek/rtw88/: util.c
Only in drivers/net/wireless/realtek/rtw88/: util.h
Only in drivers/net/wireless/realtek/rtw88/: util.o
Only in drivers/net/wireless/realtek/rtw88/: .util.o.cmd
Only in /home/finger/rtlwifi_new1/: wifi.h
